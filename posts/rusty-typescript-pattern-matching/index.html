<!DOCTYPE html>
<html lang='zh' ><meta charset="utf-8">
<meta name="viewport" content="width=device-width">


<title>Rusty Typescript -- Pattern Matching | ç§˜å¯†</title>

<meta name="generator" content="Hugo Eureka 0.8.3" />
<link rel="stylesheet" href="/css/eureka.min.css">
<script defer src="/js/eureka.min.js"></script>

<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link rel="preload"
  href="https://fonts.googleapis.com/css2?family=Lora:wght@400;600;700&family=Noto+Serif+SC:wght@400;600;700&display=swap"
  as="style" onload="this.onload=null;this.rel='stylesheet'">

<link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@10.1.0/build/styles/solarized-light.min.css"
   media="print"
  onload="this.media='all';this.onload=null" crossorigin>
<script defer src="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@10.1.0/build/highlight.min.js"
   crossorigin></script>

  <script defer src="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@10.1.0/build/languages/dart.min.js"
     crossorigin></script>

<script defer src="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.14.0/js/all.min.js"
   integrity="sha256-uNYoXefWRqv&#43;PsIF/OflNmwtKM4lStn9yrz2gVl6ymo="  crossorigin></script>




<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css"
   integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3&#43;Aro6EYUG4&#43;cU&#43;KJWu/X"  media="print"
  onload="this.media='all';this.onload=null" crossorigin>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.js" 
  integrity="sha384-g7c&#43;Jr9ZivxKLnZTDUhnkOnsh30B4H0rpLUpJ4jAIKs4fnJI&#43;sEnkvrMWph2EDg4"  crossorigin></script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/contrib/auto-render.min.js"
   integrity="sha384-mll67QQFJfxn0IYznZYonOWZ644AWYC&#43;Pt2cHqMaRhXVrursRwvLnLaebdGIlYNa"  crossorigin></script>
<script>
  document.addEventListener("DOMContentLoaded", function () {
    renderMathInElement(document.body, {
      delimiters: [
        { left: "$$", right: "$$", display: true },
        { left: "$", right: "$", display: false },
        { left: "\\(", right: "\\)", display: false },
        { left: "\\[", right: "\\]", display: true }
      ],
    });
  });
</script>


<script defer src="https://cdn.jsdelivr.net/npm/mermaid@8.9.2/dist/mermaid.min.js" 
  integrity="sha256-Zmpaaj&#43;GXFsPF5WdPArSrnW3b30dovldeKsW00xBVwE="  crossorigin></script>


<link rel="icon" type="image/png" sizes="32x32" href="/images/icon_hu64421c6c7700f606f0ad45d807017b09_5843_32x32_fill_box_center_3.png">
<link rel="apple-touch-icon" sizes="180x180" href="/images/icon_hu64421c6c7700f606f0ad45d807017b09_5843_180x180_fill_box_center_3.png">

<meta name="description"
  content="å¦‚ä½•ç”¨ ts å®ç° rust çš„ Optionã€Resultã€match ç‰¹æ€§">
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [{
      "@type": "ListItem",
      "position": 1 ,
      "name":"æ–‡ç« ",
      "item":"/posts/"},{
      "@type": "ListItem",
      "position": 2 ,
      "name":"Rusty Typescript -- Pattern Matching",
      "item":"/posts/rusty-typescript-pattern-matching/"}]
}
</script>



<script type="application/ld+json">
{
    "@context": "https://schema.org",
    "@type": "Article",
    "mainEntityOfPage": {
        "@type": "WebPage",
        "@id": "/posts/rusty-typescript-pattern-matching/"
    },
    "headline": "Rusty Typescript -- Pattern Matching | ç§˜å¯†","datePublished": "2022-09-12T18:02:35+08:00",
    "dateModified": "2022-09-12T18:02:35+08:00",
    "wordCount":  8064 ,
    "author": {
        "@type": "Person",
        "name": ["werifu"]
    },
    "publisher": {
        "@type": "Person",
        "name": "Werifu",
        "logo": {
            "@type": "ImageObject",
            "url": "/images/icon.png"
        }
        },
    "description": "å¦‚ä½•ç”¨ ts å®ç° rust çš„ Optionã€Resultã€match ç‰¹æ€§"
}
</script><meta property="og:title" content="Rusty Typescript -- Pattern Matching | ç§˜å¯†" />
<meta property="og:type" content="article" />


<meta property="og:image" content="/images/icon.png">


<meta property="og:url" content="/posts/rusty-typescript-pattern-matching/" />



<meta property="og:description" content="å¦‚ä½•ç”¨ ts å®ç° rust çš„ Optionã€Resultã€match ç‰¹æ€§" />



<meta property="og:locale" content="zh" />




<meta property="og:site_name" content="ç§˜å¯†" />






<meta property="article:published_time" content="2022-09-12T18:02:35&#43;08:00" />


<meta property="article:modified_time" content="2022-09-12T18:02:35&#43;08:00" />



<meta property="article:section" content="posts" />


<meta property="article:tag" content="TypeScript" />

<meta property="article:tag" content="Rust" />





<body class="flex flex-col min-h-screen">
  <header class="fixed flex items-center w-full min-h-16 pl-scrollbar z-50 bg-secondary-bg shadow-sm">
    <div class="w-full max-w-screen-xl mx-auto"><script>
    let storageColorScheme = localStorage.getItem("lightDarkMode")
    if (((storageColorScheme == 'Auto' || storageColorScheme == null) && window.matchMedia("(prefers-color-scheme: dark)").matches) || storageColorScheme == "Dark") {
        document.getElementsByTagName('html')[0].classList.add('dark')
    }
</script>
<nav class="flex items-center justify-between flex-wrap px-4 py-4 md:py-0">
    <a href="/" class="mr-6 text-primary-text text-xl font-bold">ç§˜å¯†</a>
    <button id="navbar-btn" class="md:hidden flex items-center px-3 py-2" aria-label="Open Navbar">
        <i class="fas fa-bars"></i>
    </button>

    <div id="target"
        class="hidden block md:flex md:flex-grow md:justify-between md:items-center w-full md:w-auto text-primary-text z-20">
        <div class="md:flex md:h-16 text-sm md:flex-grow pb-4 md:pb-0 border-b md:border-b-0">
            <a href="/#about" class="block mt-4 md:inline-block md:mt-0 md:h-(16-4px) md:leading-(16-4px) box-border md:border-t-2 md:border-b-2  border-transparent  mr-4">About</a>
            <a href="/posts/" class="block mt-4 md:inline-block md:mt-0 md:h-(16-4px) md:leading-(16-4px) box-border md:border-t-2 md:border-b-2  selected-menu-item  mr-4">Posts</a>
            <a href="/doujins/" class="block mt-4 md:inline-block md:mt-0 md:h-(16-4px) md:leading-(16-4px) box-border md:border-t-2 md:border-b-2  border-transparent  mr-4">Doujins</a>
        </div>

        <div class="flex">
            <div class="relative pt-4 md:pt-0">
                <div class="cursor-pointer hover:text-eureka" id="lightDarkMode">
                    <i class="fas fa-adjust"></i>
                </div>
                <div class="fixed hidden inset-0 opacity-0 h-full w-full cursor-default z-30" id="is-open">
                </div>
                <div class="absolute flex flex-col left-0 md:left-auto right-auto md:right-0 hidden bg-secondary-bg w-48 rounded py-2 border border-tertiary-bg cursor-pointer z-40"
                    id='lightDarkOptions'>
                    <span class="px-4 py-1 hover:text-eureka" name="Light">æµ…è‰²</span>
                    <span class="px-4 py-1 hover:text-eureka" name="Dark">æ·±è‰²</span>
                    <span class="px-4 py-1 hover:text-eureka" name="Auto">è‡ªåŠ¨</span>
                </div>
            </div>
        </div>
    </div>

    <div class="fixed hidden inset-0 opacity-0 h-full w-full cursor-default z-0" id="is-open-mobile">
    </div>

</nav>
<script>
    
    let element = document.getElementById('lightDarkMode')
    if (storageColorScheme == null || storageColorScheme == 'Auto') {
        document.addEventListener('DOMContentLoaded', () => {
            window.matchMedia("(prefers-color-scheme: dark)").addEventListener('change', switchDarkMode)
        })
    } else if (storageColorScheme == "Light") {
        element.firstElementChild.classList.remove('fa-adjust')
        element.firstElementChild.setAttribute("data-icon", 'sun')
        element.firstElementChild.classList.add('fa-sun')
    } else if (storageColorScheme == "Dark") {
        element.firstElementChild.classList.remove('fa-adjust')
        element.firstElementChild.setAttribute("data-icon", 'moon')
        element.firstElementChild.classList.add('fa-moon')
    }

    document.addEventListener('DOMContentLoaded', () => {
        getcolorscheme();
        switchBurger();
    });
</script>
</div>
  </header>
  <main class="flex-grow pt-16">
    <div class="pl-scrollbar">
      <div class="w-full max-w-screen-xl lg:px-4 xl:px-8 mx-auto">


<div class="grid grid-cols-2 lg:grid-cols-8 gap-4 lg:pt-12">
    <div
        class="col-span-2  lg:col-span-6 bg-secondary-bg rounded px-6 py-8">
        <h1 class="font-bold text-3xl text-primary-text">Rusty Typescript -- Pattern Matching</h1>
        <div class="flex flex-wrap flex-row items-center mt-2 text-tertiary-text">
    <div class="mr-6 my-2">
        <i class="fas fa-calendar mr-1"></i>
        <span>2022-09-12</span>
    </div>
    <div class="mr-6 my-2">
        <i class="fas fa-clock mr-1"></i>
        <span>17åˆ†é’Ÿé˜…è¯»æ—¶é•¿</span>
    </div>
    
    

    
</div>
        
        
        

        <div class="content">
            <p>æœ¬æ–‡ç« å†…å®¹ï¼šä½¿ç”¨ TypeScript å®ç° Rust çš„éƒ¨åˆ†æ¨¡å¼åŒ¹é…ç‰¹æ€§ï¼ˆmatchã€Optionã€Resultï¼‰</p>
<p>æ ‡é¢˜å¯ä»¥ç†è§£ä¸ºã€Š Rust å‘³çš„ TypeScript ã€‹</p>
<blockquote>
<p>é˜…è¯»é¡»çŸ¥ï¼š</p>
<ol>
<li>æ— éœ€ Rust åŸºç¡€çŸ¥è¯†ï¼Œä¹Ÿä¸ Rust æœ€éš¾çš„å†…å­˜å®‰å…¨æ¨¡å‹æ— å…³</li>
<li>åŒ…å«å¯¹æ¨¡å¼åŒ¹é…çš„ç†è§£</li>
<li>åŒ…å«ä¸€ç§å®ç°çš„å¼€æºä»£ç è®²è§£</li>
<li>å°‘é‡ç±»å‹ä½“æ“</li>
</ol>
</blockquote>
<h2 id="æ¨¡å¼åŒ¹é…-pattern-matching">æ¨¡å¼åŒ¹é… (Pattern Matching)</h2>
<h3 id="æ˜¯ä»€ä¹ˆ">æ˜¯ä»€ä¹ˆ</h3>
<ul>
<li>å‡½æ•°å¼ç¼–ç¨‹é‡Œçš„æ¦‚å¿µ</li>
</ul>
<blockquote>
<p>æ¨¡å¼åŒ¹é…æ˜¯æ£€æŸ¥ç»™å®šè®°å·åºåˆ—ä¸­ï¼Œæ˜¯å¦å­˜åœ¨æŸç§æ¨¡å¼çš„ç»„æˆéƒ¨åˆ†çš„è¡Œä¸ºã€‚â€”â€”ç»´åŸº</p>
<p>pattern matching is the act of checking a given sequence of tokens for the presence of the constituents of some pattern. â€”â€” Wikipedia</p>
</blockquote>
<p>æ¨¡å¼å¯ä»¥ç†è§£ä¸ºã€è§„å¾‹ã€‘ã€‚å®šä¹‰å¬èµ·æ¥å¾ˆæŠ½è±¡ï¼Œä¸¾ä¸€ç‚¹ä¾‹å­ä¹‹åæ˜¯å¾ˆå®¹æ˜“ç†è§£è¿™ä¸ªåå­—çš„ã€‚</p>
<ul>
<li>switchã€RegExp æ˜¯ä¸€ç§æ¨¡å¼åŒ¹é…</li>
</ul>
<pre><code class="language-rust">fn main() {
    let x = 1;
    match x {
        1 =&gt; println!(&quot;one&quot;),
        2 =&gt; println!(&quot;two&quot;),
        _ =&gt; println!(&quot;anything&quot;),
    }
}
</code></pre>
<p>æœ€ç®€å•çš„ä½¿ç”¨å°±åƒä¸€ä¸ª switchï¼Œä½†æ˜¯é™¤äº†èƒ½åŒ¹é…å‡ºå€¼ï¼Œä¹Ÿèƒ½åŒ¹é…å‡ºä½ç½®ã€ç”šè‡³åå­—ã€‚</p>
<p>å¯¹åé¢è¿™å¥æ˜¯ä¸æ˜¯æœ‰ç‚¹æƒ³æ³•ï¼Ÿ</p>
<pre><code class="language-js">const { a, b } = { a: 1, b: 2 };
// a should be 1; b should be 2.

const [ a, _, ...c ] = [ 1, 2, 3, 4, 5 ];
// a should be 1; c should be [3,4,5].
</code></pre>
<p>å…¶å®jsé‡Œçš„è§£æ„èµ‹å€¼å°±æ˜¯ä¸€ç§æ¨¡å¼åŒ¹é…ï¼Œé™¤äº†ã€æ¡ä»¶æ‰§è¡Œã€‘ä»¥å¤–ï¼Œè¿˜æœ‰ã€æå–ã€‘å‡ºæƒ³è¦çš„æ•°æ®çš„åŠŸèƒ½ã€‚å›è¿‡å¤´çœ‹æ­£åˆ™è¡¨è¾¾å¼ï¼Œå°±èƒ½å¾ˆå®¹æ˜“ç†è§£è¿™ä¸ªæ¦‚å¿µï¼Œæ—¢å¯ä»¥testå»æµ‹è¯•æ˜¯å¦åŒ¹é…ï¼Œåˆå¯ä»¥execå»æ•è·åŒ¹é…åˆ°çš„æ•°æ®ã€‚</p>
<blockquote>
<p>In contrast to pattern recognition, the match usually has to be exact: &ldquo;either it will or will not be a match.&quot;â€”â€” Wikipedia</p>
</blockquote>
<p>åœ¨ç»´åŸºé‡Œè¿˜æŒ‡å‡ºäº†æ¨¡å¼åŒ¹é…ä¸æ¨¡å¼è¯†åˆ«ï¼ˆPattern Recognitionï¼‰çš„ä¸€ä¸ªåŒºåˆ«ï¼Œå°±æ˜¯å‰è€…ä¸€èˆ¬æ¥è¯´æ˜¯ç²¾ç¡® çš„ï¼Œè¦ä¹ˆä¼šè¢«åŒ¹é…ï¼Œè¦ä¹ˆä¸ä¼šè¢«åŒ¹é…ï¼ˆå¯¹äºä¸€ä¸ªåˆ†æ”¯æ¥è¯´ï¼‰ï¼Œä¸ä¼šæœ‰ç½®ä¿¡åº¦å¤šå°‘çš„åŒ¹é…æƒ…å†µã€‚</p>
<h3 id="å¥½å¤„åœ¨å“ª">å¥½å¤„åœ¨å“ª</h3>
<h4 id="ç¬¦åˆäººç±»æ€è€ƒæ–¹å¼çš„è®¾è®¡">ç¬¦åˆäººç±»æ€è€ƒæ–¹å¼çš„è®¾è®¡</h4>
<ul>
<li>ä½¿ç”¨ if å¹¶ä¸æ˜¯æˆ‘ä»¬çš„ç¬¬ä¸€æ€è€ƒæ–¹å¼</li>
</ul>
<p>æ¯”å¦‚æˆ‘ä»¬ç°åœ¨æƒ³è¦è®¡ç®—æŸä¸€ä¸ªè§„åˆ™äºŒç»´å›¾å½¢çš„å‘¨é•¿ï¼Œè¿™ä¸ªå›¾å½¢å¯èƒ½æ˜¯çŸ©å½¢ã€åœ†å½¢æˆ–è€…ä¸‰è§’å½¢ï¼Œé‚£ä¹ˆæˆ‘ä»¬å†™ä»£ç çš„æ—¶å€™å¯èƒ½ä¼šè¿™æ ·å†™ï¼š</p>
<pre><code class="language-rust">let c;
if (shape == Rectangle) {
    let len, wide = shape.len, shape.wide;
    c = (len + wide) * 2;
} else if (shape == Circle) {
    let r = shape.r;
    c = pi * r * 2;
} else if (shape == Triangle) {
    let {side1, side2, side3} = shape;
    c = side1 + side2 + side3;
}
</code></pre>
<p>è¿™ç§ä»£ç ä¸æˆ‘ä»¬çš„æ€è€ƒæ–¹å¼æœ‰ç›¸æ‚–çš„åœ°æ–¹ï¼š</p>
<ol>
<li>æˆ‘ä»¬è¾¨è¯†ä¸€ä¸ªäºŒç»´å›¾å½¢çš„æ—¶å€™å¹¶ä¸æ˜¯ç”¨æ’é™¤æ³•çš„ï¼Œæˆ‘ä»¬å¯ä»¥ä¸€çœ¼çœ‹å‡ºæ¥è¿™æ˜¯ä»€ä¹ˆå›¾å½¢ï¼Œä¸éœ€è¦ä¸€æ­¥æ­¥æ’é™¤</li>
<li>è¿™ç§ä»£ç éœ€è¦å…ˆå‡è®¾ä¸€ä¸ªå‘¨é•¿æœªçŸ¥ï¼ˆå³å˜é‡cï¼‰çš„å›¾å½¢ï¼Œä¹‹åå†è¿›è¡Œå¡«å……ï¼Œé£é™©å°±æ˜¯å¯èƒ½ç›´åˆ°æœ€åçš„ else if éƒ½æ²¡åŒ¹é…ä¸Šï¼Œè¿™æ · c å°±æˆäº†ä¸€ä¸ªæœªåˆå§‹åŒ–çš„å€¼ï¼ˆUninitialized variableï¼‰ï¼Œä¼—æ‰€å‘¨çŸ¥è¿™ç§æƒ…å†µå¸¸å¸¸å¯¼è‡´ bug / undefined behavior</li>
</ol>
<p>å› æ­¤ï¼Œæˆ‘ä»¬å¸Œæœ›æœ‰ä¸€ç§æ›´åŠ é˜³é—´çš„å†™æ³•ï¼š</p>
<pre><code class="language-rust">let c = match shape {
  Rectangle {len, wide} =&gt; (len+wide)*2,
  Circle {r} =&gt; pi * r * 2,
  Triangle {side1, side2, side3} =&gt; side1 + side2 + side3,
};
</code></pre>
<p>å³ä½¿æ˜¯æ²¡å­¦è¿‡matchè¯­æ³•çš„äººåº”è¯¥ä¹Ÿèƒ½çœ‹æ‡‚è¿™æ ·çš„å†™æ³•ï¼Œè¯­ä¹‰ä¸Šå¯ä»¥ç†è§£ä¸ºï¼š</p>
<p>æˆ‘ä»¬æƒ³è®¡ç®—cï¼Œéœ€è¦å¯¹å®ƒçš„ç±»å‹è¿›è¡Œä¸€æ¬¡åŒ¹é…ï¼Œè€Œä¸”æˆ‘ä»¬å¯ä»¥çœ‹å‡ºæ˜¯ä¸‰ç§ç±»å‹ä¸­çš„ä¸€ç§ï¼Œç„¶åæˆ‘ä»¬å°†ä»å¯¹åº”çš„ç±»å‹é‡Œæå–å‡ºéœ€è¦çš„å‚æ•°å¹¶è¿›è¡Œè®¡ç®—ï¼ˆçœ‹æˆä¸€ä¸ªè§£æ„èµ‹å€¼ï¼‰ã€‚</p>
<p>è¿™é‡Œæ˜¯å¦è§£å†³äº†ä¸Šè¿°å¯èƒ½å¯¼è‡´ubçš„é—®é¢˜ï¼Ÿç­”æ¡ˆæ˜¯åœ¨ç¼–è¯‘å™¨çš„å¸®åŠ©ä¸‹ï¼Œæ˜¯å¯ä»¥çš„ã€‚åœ¨ç±»å‹å®‰å…¨çš„è§„åˆ™ä¸‹ï¼Œæˆ‘ä»¬åº”å½“çŸ¥é“shapeçš„å–å€¼èŒƒå›´ï¼Œå¦‚æœæœ‰ç¬¬å››ç§å›¾å½¢ï¼Œé‚£ä¹ˆåº”å½“åœ¨æŸä¸ªåœ°æ–¹ï¼ˆæ¯”å¦‚ç±»å‹å£°æ˜ï¼‰ä¸Šæœ‰æ‰€ä½“ç°ï¼Œå¦‚æœä¸èƒ½åŒ¹é…å‡ºç»“æœï¼Œé‚£ä¹ˆè¿™æ¡matchè¡¨è¾¾å¼å°†ä¸çŸ¥é“è¿”å›ä»€ä¹ˆæ•°æ®ï¼Œåº”è¯¥æŠ›å‡ºé”™è¯¯ã€‚</p>
<p>è™½ç„¶æ„Ÿè§‰ä¾‹å­æœ‰ç‚¹å°åˆ»æ„ï¼Œä½†æˆ‘è§‰å¾—å¯¹ç†è§£æ¨¡å¼åŒ¹é…çš„å¥½å¤„å¾ˆæœ‰å¸®åŠ©ã€‚</p>
<h4 id="æ¡ä»¶æ‰§è¡Œä¸æå–çš„å…¼å¾—">ã€æ¡ä»¶æ‰§è¡Œã€‘ä¸ã€æå–ã€‘çš„å…¼å¾—</h4>
<ul>
<li>If åªèƒ½åšåˆ°æ¡ä»¶ç­›é€‰ï¼Œå´ä¸å¥½åšèµ‹å€¼</li>
</ul>
<blockquote>
<p>å½“ç„¶ä¹Ÿå¯ä»¥ç”¨ if (a = 114514) è¿™æ ·çš„æ··æ²Œå†™æ³•ï¼Œä½†æ˜¯åœ¨å®è·µä¸Šä¸€èˆ¬æ˜¯æ‹’ç»è¿™ç§å†™æ³•çš„ï¼Œå› ä¸ºè¿™å¹¶ä¸æ˜¯â€œæœ‰æ¡ä»¶â€åœ°èµ‹å€¼ï¼Œæ—©å·²ä¸è¢«æå€¡</p>
</blockquote>
<p>åœ¨ä¸Šé¢çš„ä¾‹å­ä¸­ï¼Œæˆ‘ä»¬åœ¨æ¯ä¸ªåˆ¤æ–­ååŠ ä¸Šä¸€è¡Œèµ‹å€¼ï¼ˆä¸åŠ ä¹Ÿè¡Œï¼Œä½†æ˜¯ä½ çš„æˆå‘˜è°ƒç”¨å°†ä¼šå¾ˆå•°å—¦ï¼‰ï¼Œå®é™…ä¸Šæ˜¯ä¸å¤ªæœ‰é¢å¤–ä¿¡æ¯é‡çš„è¯­å¥ï¼Œ<em>æˆ‘ç›¸ä¿¡ä¼˜é›…æµç•…çš„ä»£ç åº”å¦‚è‡ªç„¶è¯­è¨€ä¸€æ ·å¥½è¯»</em></p>
<blockquote>
<p>åœ¨ Rust é‡Œç¡®å®æœ‰å¸¦æ¡ä»¶çš„èµ‹å€¼ï¼Œè¯·è‡ªè¡Œå­¦ä¹  if let è¯­æ³•</p>
</blockquote>
<h4 id="ä»è¯­å¥åˆ°è¡¨è¾¾å¼-çš„è½¬å˜">ä»è¯­å¥åˆ°è¡¨è¾¾å¼ çš„è½¬å˜</h4>
<ul>
<li>è¡¨è¾¾å¼æä¾›äº†æ›´çµæ´»çš„å†™æ³•</li>
</ul>
<p>æ³¨æ„ç”„åˆ«è¯­å¥å’Œè¡¨è¾¾å¼ï¼ˆstatement vs expressionï¼‰</p>
<p>æ¥è§¦è¿‡ç¼–è¯‘åŸç†çš„è¯åº”è¯¥èƒ½è®°ä½åŒºåˆ«ï¼Œå¿˜è®°äº†ä¹Ÿä¸è¦ç´§ï¼Œç®€å•æ¦‚æ‹¬å°±æ˜¯ï¼š</p>
<ol>
<li>è¯­å¥æ˜¯ä¸€ä¸ªè¿‡ç¨‹</li>
<li>è¡¨è¾¾å¼æ˜¯ä¸€ä¸ªå€¼</li>
</ol>
<p>æ¯”å¦‚ç®­å¤´å‡½æ•°() =&gt; 1ï¼Œæˆ‘ä»¬å¶å°”æ‰“é¡ºæ‰‹åœ¨1åå¤šäº†ä¸ªåˆ†å·çš„æ—¶å€™ï¼Œç¼–è¯‘å™¨å¾€å¾€ä¼šå°è¯•çº æ­£ä½ ï¼Œå› ä¸º1;æ˜¯è¯­å¥ï¼Œè€Œä¸æ˜¯è¡¨è¾¾å¼ã€‚
å†æ¯”å¦‚æˆ‘ä»¬å†™ jsxï¼š</p>
<pre><code class="language-jsx">// valid
&lt;div&gt;{ condition ? 'true': 'false' }&lt;/div&gt;
// invalid
&lt;div&gt; { if (condition) {'true';} else { 'false'; } } &lt;/div&gt;
</code></pre>
<p>æˆ‘æƒ³ä¸Šé¢ä¸¤æ®µæƒ³è¡¨è¾¾çš„æ˜¯åŒä¸€ä¸ªè¯­ä¹‰ï¼šå¦‚æœæ¡ä»¶æˆç«‹ï¼Œé‚£ä¹ˆæ¸²æŸ“ <code>&lt;div&gt;true&lt;/div&gt;</code> ï¼Œå¦åˆ™æ¸²æŸ“ <code>&lt;div&gt;false&lt;/div&gt;</code></p>
<p>ä½†æ˜¯æ˜¾ç„¶ä¸‹é¢çš„æ˜¯éæ³•çš„ï¼Œå› ä¸ºå®ƒæ˜¯ä¸€ä¸ª if è¯­å¥ï¼Œè€Œä¸æ˜¯è¡¨è¾¾å¼ï¼Œä¸å…·æœ‰å€¼ã€‚</p>
<p>ä»ä¸Šé¢ä¸¾è¿‡çš„å›¾å½¢å‘¨é•¿çš„ä¾‹å­é‡Œï¼Œæˆ‘ä»¬åœ¨matchåå¯ä»¥ç›´æ¥èµ‹å€¼ç»™cï¼Œå› æ­¤matchæ˜¯ä¸€ä¸ªè¡¨è¾¾å¼è€Œä¸æ˜¯å€¼</p>
<p>è¿™ä¹Ÿæ˜¯è·Ÿswitchçš„ä¸€ä¸ªåŒºåˆ«ï¼Œå› ä¸ºswitchä¹Ÿæ˜¯ä¸€ä¸ªè¯­å¥è€Œä¸æ˜¯è¡¨è¾¾å¼ã€‚</p>
<p>è¡¨è¾¾å¼æœ‰æ¯”è¯­å¥æ›´çµæ´»çš„ç‰¹ç‚¹ï¼Œå› ä¸ºexpressionæ˜¯statementçš„ç»„æˆï¼Œå½“è¡¨è¾¾å¼ä¸èµ‹å€¼ç»™å˜é‡çš„æ—¶å€™æˆ‘ä»¬ä¹Ÿå¯ä»¥å½“åšä¸€ä¸ªåªåŒ…å«ä¸€ä¸ªexpressionçš„statementï¼Œè¿™ç§è®¾è®¡æœ‰åŠ©äºæ›´ä¼˜é›…åœ°ç¼–ç¨‹ã€‚</p>
<h3 id="æ€§èƒ½æœ‰æå‡å—">æ€§èƒ½æœ‰æå‡å—ï¼Ÿ</h3>
<p>å®é™…ä¸Šæ¨¡å¼åŒ¹é…å¸¦æ¥çš„æ˜¯æŠ½è±¡å±‚é¢çš„å‡åï¼Œè®¡ç®—æœºæ€»å½’æ— æ³•åƒäººç±»ä¸€æ ·æ€è€ƒï¼Œå› æ­¤åœ¨æ€§èƒ½æ–¹é¢å¹¶ä¸æ˜¯å…¶ä¼˜åŠ¿ï¼Œåº•å±‚å®ç°å°±æ˜¯ä¸€å † if elseã€‚</p>
<p>å¯ä»¥å‚è€ƒè¿™ä¸ªå›ç­”ï¼šHow is match implemented in a language like Rust?</p>
<p>å…¶ä¸­çš„å›ç­”ç»™äº†è¿™ä¸ªä¾‹å­ï¼š</p>
<pre><code class="language-rust">enum Result {
  SingleResult(i32),
  TwoResults(i32, i32),
  Error
}

match someResult {
  Result::SingleResult(res) =&gt; f(res),
  Result::TwoResults(res1, res2) =&gt; g(res1, res2),
  Result::Error =&gt; error()
}
</code></pre>
<p>ä¸Šé¢çš„ enum æ˜¯ Rust é‡Œçš„æšä¸¾å€¼ï¼Œä¸å¤§å¤šè¯­è¨€ä¸ä¸€æ ·çš„æ˜¯ï¼ŒRust çš„æšä¸¾å€¼é‡Œæ˜¯å¯ä»¥æºå¸¦é¢å¤–çš„ä¿¡æ¯çš„ï¼ˆå¯ä»¥æ˜¯ç»“æ„ã€æ•°ç»„ã€å…ƒç»„ã€åŸºæœ¬ç±»å‹ç­‰ç­‰ï¼‰</p>
<p>å…¶å®ç°åçš„Cä»£ç å¤§æ¦‚å¦‚ä¸‹</p>
<pre><code class="language-c">struct Result {
  enum {
    SingleResult, TwoResults, Error
  } tag;
  union {
    struct {
      int arg1;
    } singleResult;
    struct {
      int arg1;
      int arg2;
    } twoResults;
  } value;
};

switch(someResult.tag) {
  case SingleResult: {
    int res = someResult.value.singleResult.arg1;
    f(res);
    break;
  }
  case TwoResults: {
    int res1 = someResult.value.twoResults.arg1;
    int res2 = someResult.value.twoResults.arg2;
    g(res1, res2);
    break;
  }
  case Error: {
    error();
    break;
  }
}
</code></pre>
<p>ä¸Šé¢çš„unionåœ¨TypeScripté‡Œæœ‰æ›´ä¸ºä¼˜é›…çš„è¡¨è¾¾ï¼ˆç¼ºç‚¹æ˜¯æ²¡æŠŠSingleResultä¸{arg1: number}ç»‘å®šèµ·æ¥ï¼‰ï¼š</p>
<pre><code class="language-typescript">interface Result {
    tag: enum ResultTag { SingleResult, TwoResults, Error },
    value: {arg1: number} | {arg1: number, arg2: number},
}
</code></pre>
<p>è¿™ä¸ªæ¶‰åŠä»£æ•°æ•°æ®ç±»å‹ï¼ˆAlgebraic Data Typeï¼‰ï¼ŒæŒ‡å¯ä»¥è¿›è¡Œä»£æ•°è¿ç®—çš„ç±»å‹ï¼ˆæ¯”å¦‚ |ï¼Œ&amp; ç­‰ï¼‰ï¼Œä¸æ˜¯è®²è¿°é‡ç‚¹ï¼Œè¯·è‡ªå·±æŸ¥é˜…èµ„æ–™ <a href="https://en.wikipedia.org/wiki/Algebraic_data_type">Algebraic_data_typeâ€”â€”wiki</a></p>
<h2 id="rust-çš„-optiont-resultt-e-ä¸-match">Rust çš„ Option<T>, Result&lt;T, E&gt; ä¸ match</h2>
<h3 id="optiont">Option<T></h3>
<pre><code class="language-rust">enum Option&lt;T&gt; {
    None,
    Some(T),
}
</code></pre>
<p>å°–æ‹¬å·å¾ˆå®¹æ˜“çœ‹å‡ºæ¥æ˜¯æ³›å‹çš„æ„æ€ï¼Œè€Œ Some(T) ä»£è¡¨ä¸€ä¸ª Some ä¸­å¯ä»¥æºå¸¦ä¸€ä¸ªTç±»å‹çš„å€¼ï¼Œæ¯”å¦‚ Option<i32> è¿™ä¸ªæšä¸¾ç±»å‹åŒ…æ‹¬äº† None æˆ–è€… Some(i32) ä¸¤ç§æšä¸¾å€¼ï¼Œè€Œ Some(114514) å°±æ˜¯ä¸€ä¸ªOption<i32>ç±»å‹ã€‚</p>
<p>é‡æ–°æ€è€ƒä¸€ä¸‹ä¸Šé¢è¯´çš„æºå¸¦ä¸åŒç±»å‹å€¼çš„ enum çš„åº•å±‚å®ç°ï¼Œå°±æ˜¯é‚£ä¸ª unionï¼Œå°±èƒ½ç†è§£â€œæºå¸¦å€¼çš„æšä¸¾å€¼â€è¿™ä»¶äº‹ã€‚</p>
<p>ä¸€ä¸ª Option ç±»å‹çš„å€¼ä»£è¡¨å…¶å¤„äºæœ‰å€¼ï¼ˆSomeï¼‰è·Ÿæ²¡å€¼ï¼ˆNoneï¼‰çš„å åŠ æ€ï¼Œå¯¹å…¶è¿›è¡Œè§‚å¯Ÿï¼ˆåŒ¹é…ï¼‰å°†åå¡Œåˆ°å…¶ä¸­ä¸€ä¸ªçŠ¶æ€ XD</p>
<p>å¦‚æœè§£æå‡ºæ¥è¿™ä¸ªå€¼æ˜¯Someï¼Œé‚£ä¹ˆæˆ‘ä»¬å°†å¯ä»¥ç±»å‹å®‰å…¨åœ° è®¿é—®åˆ°å…¶é‡Œé¢çš„å€¼ã€‚ï¼ˆæ„å‘³ç€ç¼–è¯‘å™¨å¯ä»¥å¸®åŠ©ä½ è§„èŒƒè¡Œä¸ºï¼Œä¹Ÿå¯ä»¥å¸®ä½ åšå¥½è¯­æ³•æç¤ºï¼Œè®¿é—®é‡Œé¢çš„å€¼ä¸€å®šæ˜¯ç±»å‹å®‰å…¨çš„ï¼Œå³ä¸ä¼šåœ¨ç±»å‹ä¸Šç¿»è½¦ï¼‰</p>
<h3 id="resultt-e">Result&lt;T, E&gt;</h3>
<pre><code class="language-rust">enum Result&lt;T, E&gt; {
    Ok(T),
    Err(E),
 }
</code></pre>
<p>æˆ‘è®¤ä¸ºä¸Šé¢è®²è¿‡ Option åï¼Œç†è§£ Result åº”è¯¥ä¹Ÿå¾ˆç®€å•ï¼Œä¸€ä¸ª Result ç±»å‹çš„å€¼å¤„äºæˆåŠŸä¸å¤±è´¥çš„å åŠ æ€ï¼Œå¦‚æœæˆåŠŸï¼Œå°±èƒ½ç±»å‹å®‰å…¨åœ°è®¿é—®å…¶ä¸­çš„ T ç±»å‹ä½†æ— æ³•è®¿é—® E ç±»å‹çš„å€¼ï¼ˆunion åªèƒ½åŒæ—¶å­˜åœ¨ä¸€ä¸ªå¯¹å§ï¼‰ï¼Œå¦‚æœå¤±è´¥ï¼Œæˆ‘ä»¬èƒ½å®‰å…¨åœ°è®¿é—®é”™è¯¯é‡Œçš„ E ç±»å‹ï¼Œæ­¤æ—¶åˆæ— æ³•è®¿é—® T ç±»å‹çš„å€¼ã€‚</p>
<p>å¾ˆæ˜æ˜¾è¿™ä¸ªå¯ä»¥ç”¨åœ¨é”™è¯¯å¤„ç†çš„é¢†åŸŸï¼Œæˆ‘è§‰å¾—ä¼šå¾ˆå®¹æ˜“è”æƒ³åˆ°å¤§é“è‡³ç®€çš„ go</p>
<pre><code class="language-go">res, err := function()
if err != nil {
    // handle the error
}
use(res)
</code></pre>
<p>å¶å°”èƒ½è§åˆ° gopher ç®¡è‡ªå·±å« if err != nil å·¥ç¨‹å¸ˆï¼Œå› ä¸ºä¸€ä¸ªå¯èƒ½å‘ç”Ÿé”™è¯¯çš„å‡½æ•°å¾€å¾€æ˜¯è¿™ä¹ˆè¿”å›æ•°æ®çš„ï¼Œé€šè¿‡æ ¡éªŒæ˜¯å¦æœ‰ err æ¥åˆ¤æ–­æˆåŠŸä¸å¦ï¼Œè¿™ç§å¤„ç†æ–¹å¼çš„ç¼ºé™·é™¤äº†å†™èµ·æ¥å¾ˆå•°å—¦å¤–ï¼Œè¿˜æœ‰ä¸€ä¸ªç¼ºé™·ï¼Œå°±æ˜¯å¤„ç†å¯èƒ½ä¸åˆ°ä½ã€‚</p>
<pre><code class="language-go">res, err := function()
if err != nil {
    fmt.println(&quot;some error|&quot;, err)
    // forget to return!
}
// use an invalid res!
use(res)
</code></pre>
<p>å®é™…ä¸Šï¼Œè¿™ç§é”™è¯¯å¤„ç†å…¨å‡­è‡ªè§‰ï¼Œæˆ‘ä»¬å°†æ­£ç¡®å¤„ç†çš„ç»“æœä¸é”™è¯¯å¤„ç†çš„å¤±è´¥åŸå› ä¸€èµ·è¿”å›ï¼Œåªèƒ½é€šè¿‡ç¨‹åºå‘˜è‡ªè§‰å»å¤„ç†è¿™ç§å…³ç³»ï¼Œä½†å¶å°”å¯èƒ½åœ¨å¤„ç† err åï¼Œå¿˜è®° return äº†ï¼Œè€Œä¸”ä¹Ÿæ²¡å¯¹ res è¿›è¡Œå†å¤„ç†ï¼Œå¯¼è‡´æ‰§è¡Œæµç»§ç»­è¿›è¡Œä¸‹å»ï¼Œè®¿é—®äº†ä¸è¯¥è®¿é—®çš„resï¼ˆæ­¤æ—¶æ— æ³•çŸ¥é“æ˜¯ä»€ä¹ˆå€¼ï¼‰ï¼Œå°†ä¼šäº§ç”Ÿ ubã€‚</p>
<p>è€Œ Result æ˜¯è§£å†³è¿™ä¸ªé—®é¢˜çš„åˆ©å™¨ï¼Œå› ä¸ºå¤„äºæˆåŠŸçŠ¶æ€çš„ç»“æœæ— æ³•è®¿é—®å¤±è´¥çŠ¶æ€çš„ç±»å‹ï¼Œè€Œå¤±è´¥çš„ç»“æœæ— æ³•è®¿é—®æˆåŠŸæ—¶çš„æ•°æ®ï¼Œå³ä½¿ä»£ç è¿˜æ²¡å¼€å§‹è·‘ï¼Œä½ ä¹ŸçŸ¥é“è‚¯å®šä¸ä¼šå‡ºé”™ã€‚</p>
<p>å¸¸ç”¨çš„é”™è¯¯å¤„ç†è¿˜æœ‰try catchç³»åˆ—ï¼Œä¾ç„¶éœ€è¦é è‡ªè§‰ï¼Œå¸¸æœ‰å¿˜è®°åœ¨throwableçš„å‡½æ•°å¤–åŠ tryï¼Œå¯¼è‡´æ— æ³•æ­£å¸¸æ•è·åˆ°é”™è¯¯ï¼ˆUncaught errorï¼‰çš„äº‹å‘ç”Ÿï¼ˆæ¯”å¦‚å¯¹å†…å±‚å‡½æ•°ä¸äº†è§£çš„è¯å°±æ— æ³•çŸ¥é“æ˜¯å¦throwableï¼Œè™½ç„¶å¸¸æœ‰å…œåº•çš„æœ€å¤–å±‚tryï¼Œä½†æ˜¯åœ¨æŠ›å‡ºé”™è¯¯åå´ä¼šä¸­æ–­æ‰§è¡Œæµï¼Œæ— æ³•è¿”å›åˆ°æŸä¸ªæƒ³å›å»çš„åœ°æ–¹ï¼Œçµæ´»æ€§æ¯”è¾ƒä½ï¼Œè€Œä¸”å†™èµ·æ¥ç¼©è¿›ç¡®å®ä¸æ€ä¹ˆå¥½çœ‹ã€‚</p>
<blockquote>
<p>ğŸ¤”Promiseå¯¹è±¡ä¸ä¸Šé¢æåˆ°çš„ Optionã€Result æºè‡ªåŒæ ·çš„è®¾è®¡æ€æƒ³ï¼Œå…ˆå å‘ï¼Œåœ¨è¿è¡Œæ—¶å†ç¡®å®šè¿™ä¸ªå‘é‡Œåº”å½“å¡«å…¥å•¥ï¼Œä¸åŒçš„ç»“æœçŠ¶æ€ä¹‹é—´æ˜¯éš”ç¦»çš„ï¼Œä»è€Œåšåˆ°ã€ç¼–è¯‘æœŸç¡®å®šçš„ã€‘ç±»å‹å®‰å…¨ï¼ŒåŒæ—¶ä¹Ÿæ–¹ä¾¿æ›´ç›´è§‚çš„é“¾å¼è°ƒç”¨ï¼Œåœ¨å‡½æ•°å¼ç¼–ç¨‹ä¸­ï¼Œè¿™ç§æ¦‚å¿µå« Monadï¼ˆå•å­ï¼‰ã€‚
<a href="https://zh.wikipedia.org/wiki/%E5%8D%95%E5%AD%90_(%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B)#%E8%AF%AD%E6%B3%95%E7%B3%96do%E8%A1%A8%E7%A4%BA%E6%B3%95">wiki-Monad</a></p>
</blockquote>
<h3 id="match">match</h3>
<p>æ¨¡å¼æ˜¯ Rust ä¸­ç‰¹æ®Šçš„è¯­æ³•ï¼Œå®ƒç”¨æ¥åŒ¹é…ç±»å‹ä¸­çš„ç»“æ„ï¼Œæ— è®ºç±»å‹æ˜¯ç®€å•è¿˜æ˜¯å¤æ‚ã€‚ç»“åˆä½¿ç”¨æ¨¡å¼å’Œ match è¡¨è¾¾å¼ä»¥åŠå…¶ä»–ç»“æ„å¯ä»¥æä¾›æ›´å¤šå¯¹ç¨‹åºæ§åˆ¶æµçš„æ”¯é…æƒã€‚æ¨¡å¼ç”±å¦‚ä¸‹ä¸€äº›å†…å®¹ç»„åˆè€Œæˆï¼š</p>
<ul>
<li>å­—é¢å€¼</li>
<li>è§£æ„çš„æ•°ç»„ã€æšä¸¾ã€ç»“æ„ä½“æˆ–è€…å…ƒç»„</li>
<li>å˜é‡</li>
<li>é€šé…ç¬¦</li>
<li>å ä½ç¬¦
é€šè¿‡ä»¥ä¸‹ä»£ç æ¥ç†è§£ï¼š</li>
</ul>
<pre><code class="language-rust">enum Message {
    Quit,
    Move { x: i32, y: i32 },
    Write(String),
    ChangeColor(i32, i32, i32),
}

fn main() {
    let msg = Message::ChangeColor(0, 160, 255);
    match msg {
        Message::Quit =&gt; {
            println!(&quot;The Quit variant has no data to destructure.&quot;)
        }
        Message::Move =&gt; {
            println!(
                &quot;Move in the x direction {} and in the y direction {}&quot;,
                x, y
            );
        }
        Message::Write(text) =&gt; println!(&quot;Text message: {}&quot;, text),
        Message::ChangeColor(r, g, b) =&gt; println!(
            &quot;Change the color to red {}, green {}, and blue {}&quot;,
            r, g, b
        ),
    }
}
</code></pre>
<p>ä»£ç æ¥è‡ª <a href="https://kaisery.github.io/trpl-zh-cn/ch18-00-patterns.html">æ¨¡å¼ä¸æ¨¡å¼åŒ¹é… - Rust ç¨‹åºè®¾è®¡è¯­è¨€ ç®€ä½“ä¸­æ–‡ç‰ˆ</a></p>
<p>å…¶å®å°±æ˜¯åŒ¹é…æˆåŠŸåè¿˜èƒ½æ•è·å…¶ä¸­çš„å€¼ã€‚</p>
<h2 id="optiont-in-ts">Option<T> in TS</h2>
<p>å‰é¢è®²äº†éå¸¸éå¸¸å¤šçš„é“ºå«ï¼Œç»ˆäºåˆ°æ­£é¢˜äº†ï¼Œå¦‚ä½•åœ¨ TS é‡Œå®ç°ä¸Šé¢è®²äº†ä¸€å¤§é€šçš„è¿™äº›ç‰¹å¾ï¼Ÿ
ä¸‹é¢çš„å†…å®¹æ˜¯å¯¹ä¸€ä¸ªå¼€æºå®ç° oxide.ts çš„æºç è§£è¯» <a href="https://github.com/traverse1984/oxide.ts">ä»“åº“åœ°å€</a>ï¼Œæºç æµ‹è¯•ã€æ–‡æ¡£å…¨è¦†ç›–ï¼Œå ªç§°ä¼˜é›…çš„ä»“åº“ï¼Œä¹Ÿå¾ˆæ¨èé˜…è¯»ã€‚</p>
<pre><code class="language-ts">// src/common.ts
export const SymbolT = Symbol('T');
export const SymbolVal = Symbol('Val');

// src/option.ts
export type Some&lt;T&gt; = OptionType&lt;T&gt; &amp; { [SymbolT]: true };
export type None = OptionType&lt;never&gt; &amp; { [SymbolT]: false };
class OptionType&lt;T&gt; {
   readonly [SymbolT]: boolean;
   readonly [SymbolVal]: T;

   constructor(val: T, some: boolean) {
      this[SymbolT] = some;
      this[SymbolVal] = val;
   }
}
</code></pre>
<p>Option çš„æ ¸å¿ƒæ˜¯å®ç°ä¸€ä¸ª OptionType<T>ï¼Œè€Œ Some<T> ä¸ None å‡æºè‡ª OptionTypeã€‚</p>
<p>SymbolT å’Œ SymbolVal æ˜¯ä¸¤ä¸ª Symbol ç±»å‹çš„å€¼ï¼Œæ„å‘³ç€ OptionType é‡Œå…¶ä»–çš„é”®ä¸ä¼šä¸è¿™ä¿©å‘ç”Ÿå†²çªï¼ˆjsçš„ç±»å‹å› ä¸ºä½¿ç”¨å­—ç¬¦ä¸²ä½œæˆå‘˜åçš„ç¼˜æ•…å¸¸æœ‰å†²çªå‘ç”Ÿçš„æƒ…å†µï¼Œæ¯”å¦‚ obj[&rsquo;toString&rsquo;] å°±ä¸æŸä¸ªå†…ç½®æ–¹æ³•å†²çªäº†ï¼‰</p>
<p>æœ‰äº† Some<T> å’Œ None ç±»å‹ï¼Œå¦‚ä½•åˆ›å»ºä¸€ä¸ªè¿™ä¸ªç±»å‹çš„å€¼ï¼Ÿé€šè¿‡æ„é€ å‡½æ•°å°±è¡Œäº†</p>
<pre><code class="language-ts">export const None = Object.freeze(
   new OptionType&lt;never&gt;(undefined as never, false)
) as None;

/// ä½¿ç”¨ Some()
export function Some&lt;T&gt;(val: T): Some&lt;T&gt; {
   return new OptionType(val, true) as Some&lt;T&gt;;
}
</code></pre>
<p>Tips: å˜é‡åè·Ÿç±»å‹åæ˜¯ä¸å†²çªçš„ï¼Œæ„å‘³ç€ä¸‹é¢çš„ä»£ç æˆç«‹ã€‚</p>
<pre><code class="language-ts">type a = number;
function a(): a {
   return 1;
}
</code></pre>
<p>Object.freeze çš„ä½œç”¨æ˜¯åˆ›å»ºä¸€ä¸ªæ— æ³•å¢åˆ æ”¹å­—æ®µçš„å¯¹è±¡</p>
<p>æˆ‘ä»¬é€šè¿‡ä¸‹é¢çš„æ–¹å¼åˆ†åˆ«åˆ›å»ºå˜é‡</p>
<p><img src="https://s3.bmp.ovh/imgs/2022/09/12/4b434da806866e36.png" alt=""></p>
<p>åˆ†åˆ«æ‰“å°a, bï¼Œå¯ä»¥å¾—åˆ°ä»¥ä¸‹ç»“æœ</p>
<p><img src="https://s3.bmp.ovh/imgs/2022/09/12/6f77ad5dce7924d8.png" alt=""></p>
<p>åŸºäºSymbol(Val)å’ŒSymbol(T)è¿™ä¸¤ä¸ªå­—æ®µï¼Œæˆ‘ä»¬å¯ä»¥æ„é€ å‡ºè®¸å¤šæœ‰ç”¨çš„æ–¹æ³•ï¼Œä¸ºäº†æ‰¾ä¸€ä¸ªæ— æ³•é™æ€ç¼–è¯‘æœŸç¡®å®šçš„ä¾‹å­ï¼ˆå³è¿è¡Œåæ‰çŸ¥é“æˆä¸æˆåŠŸï¼‰ï¼Œæˆ‘å…ˆæ„é€ ä¸€ä¸ª Rusty ï¼ˆæœ‰ Rust é£æ ¼çš„ï¼‰çš„å¤„ç†å‡½æ•°åœ¨è¿™ã€‚</p>
<pre><code class="language-ts">function rustyParseInt(str: string): Option&lt;number&gt; {
  const res = parseInt(str);
  if (isNaN(res)) {
    return None;
  }
  return Some(res);
}
</code></pre>
<p>ä¸Šè¿°å‡½æ•°æ˜¯å¯¹ parseIntçš„åŒ…è£…ï¼ŒåŸç”Ÿ parseInt åœ¨è§£æå¤±è´¥æ—¶ä¼šè¿”å›ä¸€ä¸ª NaNï¼Œæˆ‘ä»¬å°†NaNæ”¹æˆNoneï¼Œè§£ææˆåŠŸåˆ™è¿”å›Some</p>
<p>çœ‹ä¸‹é¢çš„æ–¹æ³•ï¼š</p>
<pre><code class="language-ts">/// Optionå¿…é¡»æ˜¯ä¸€ä¸ªSomeï¼Œå¦åˆ™æŠ›å‡ºé”™è¯¯ï¼ˆåœ¨rusté‡Œæ˜¯panicï¼‰
expect(this: Option&lt;T&gt;, msg: string): T {
   if (this[SymbolT]) {
      return this[SymbolVal];
   } else {
      throw new Error(msg);
   }
}

// example.ts
const a: number = rustyParseInt('would_fail').expect('fail_reason');
</code></pre>
<p>expectå¯ä»¥è§†ä¸ºå¯¹ã€æŸä¸ªOptionçš„å®ä¾‹åº”æ˜¯Someã€‘çš„æ–­è¨€ï¼Œå¹¶è¿”å›å…¶ä¸­çš„ç±»å‹ï¼Œå¦‚æœä¸æ˜¯Someå°†æŠ›å‡ºé”™è¯¯ã€‚</p>
<p>è¿è¡Œexample.tsåå°†ä¼šæŠ›å‡ºç†ç”±ä¸ºfail_reasonçš„é”™è¯¯</p>
<p><img src="https://s3.bmp.ovh/imgs/2022/09/12/776e341a4281694e.png" alt=""></p>
<p>ç”±expectï¼Œåˆå¯ä»¥åŒ…è£…å‡ºå¤šç§æ–¹æ³•</p>
<pre><code class="language-ts">unwrap(this: Option&lt;T&gt;): T;
unwrapOr(this: Option&lt;T&gt;, def: T): T;
unwrapOrElse(this: Option&lt;T&gt;, f: () =&gt; T): T;
</code></pre>
<h3 id="å¯¹åŸæœ‰-api-çš„å®‰å…¨å°è£…">å¯¹åŸæœ‰ API çš„å®‰å…¨å°è£…</h3>
<p>è¯¥åº“æä¾›äº† safe å‡½æ•°ï¼Œç”¨äºå®‰å…¨åœ° æ•è·ä¸€ä¸ªåŒæ­¥/å¼‚æ­¥å‡½æ•°çš„ç»“æœä¸ºOption<T>ï¼Œè€Œä¸ä¼šæŠ›å‡ºé”™è¯¯æˆ–è€…å¼•å‘rejectã€‚</p>
<p>ä¸‹é¢æˆªå›¾å³safeçš„å®ç°ä»£ç ï¼Œvscodeèƒ½åœ¨thené‡Œåšå‡ºæ­£ç¡®çš„ç±»å‹æ¨æ–­ã€‚</p>
<p><img src="https://s3.bmp.ovh/imgs/2022/09/12/46bb13f5b5e1e01e.png" alt=""></p>
<p>ä¹ä¸€çœ‹ä¸Šé¢æœ‰ä¸‰ä¸ªsafeï¼ŒJS/TS å¹¶ä¸æ”¯æŒå‡½æ•°é‡è½½ï¼ˆFunction Overrideï¼‰ï¼Œè¿™æ˜¯ TS çš„ Function Overload çš„ç‰¹æ€§ï¼Œè¯¦è§æ–‡æ¡£ functions overloadã€‚</p>
<p>æ„æ€æ˜¯ï¼Œä¸Šé¢ä¸¤ä¸ªsafeæ˜¯å®é™…ä½¿ç”¨æ—¶çš„åº”å½“çº¦æŸçš„å‡½æ•°ç±»å‹ï¼Œæœ€ä¸‹é¢çš„safeæ˜¯å¯¹ä¸Šé¢ä¸¤ç§ç­¾åçš„å…¼å®¹æ€§å®ç°ã€‚</p>
<pre><code class="language-ts">function makeDate(timestamp: number): Date;
function makeDate(m: number, d: number, y: number): Date;
function makeDate(mOrTimestamp: number, d?: number, y?: number): Date {
  if (d !== undefined &amp;&amp; y !== undefined) {
    return new Date(y, mOrTimestamp, d);
  } else {
    return new Date(mOrTimestamp);
  }
}
const d1 = makeDate(12345678);
const d2 = makeDate(5, 5, 5);
const d3 = makeDate(1, 3);
// No overload expects 2 arguments, but overloads do exist that expect either 1 or 3 arguments.
</code></pre>
<p>ä¸Šé¢æ˜¯å®˜æ–¹çš„ä¾‹å­ï¼Œçœ‹ä¸€ä¸‹å°±æ‡‚äº†ï¼Œd1, d2 éƒ½å¯ä»¥è¢«æ­£å¸¸ç¼–è¯‘ï¼Œd3 åˆ™é€šè¿‡ä¸äº†ç±»å‹æ£€æŸ¥ï¼Œå°½ç®¡ç¬¦åˆç¬¬ä¸‰ä¸ªmakeDateçš„å‡½æ•°ç­¾åã€‚</p>
<p><img src="https://s3.bmp.ovh/imgs/2022/09/12/46bb13f5b5e1e01e.png" alt=""></p>
<p>å›åˆ°ä¸Šé¢ safe çš„å®ç°ï¼ˆä¸å‰é¢æ˜¯åŒä¸€å¼ å›¾ï¼Œæ–¹ä¾¿è§‚çœ‹ï¼‰ï¼Œç¬¬ä¸€ä¸ªç­¾åæ¥å—çš„æ˜¯ä¸€ä¸ªåŒæ­¥å‡½æ•°åŠè¯¥å‡½æ•°çš„å‚æ•°ï¼Œé€šè¿‡ PromiseLike æ¥çº¦æŸæ˜¯å¦å¼‚æ­¥å‡½æ•°ï¼Œæ˜¯åˆ™è¦æ±‚è¿”å›å€¼ä¸ºneverç±»å‹ï¼Œä»£è¡¨ä¸€ä¸ªä¸ä¼šè¿”å›çš„å‡½æ•°ï¼ˆä¸€å®šä¼šthrowï¼Œæˆ–æ˜¯æ— é™å¾ªç¯ï¼‰ï¼Œæ—¢ç„¶æ— æ³•è¿”å›ä¹Ÿå°±ä¸ä¼šéœ€è¦safeåŒ…è£…è¿”å›å€¼ã€‚</p>
<p>ä¸€ä¸ª PromiseLike æ¥å£è¦æ±‚å®ç° then(onfulfilled, onerjected)ï¼Œå…·ä½“çœ‹TSçš„å®˜æ–¹æ–‡æ¡£ <a href="https://microsoft.github.io/PowerBI-JavaScript/interfaces/_node_modules_typedoc_node_modules_typescript_lib_lib_es5_d_.promiselike.html">PromiseLike æ¥å£æ–‡æ¡£</a></p>
<p>ç¬¬äºŒä¸ªç­¾åæ¥å—ä¸€ä¸ª Promise å¯¹è±¡ä½œä¸ºå‚æ•°ï¼Œå…¶å®å°±æ˜¯å¼‚æ­¥å‡½æ•°æ‰§è¡Œåçš„è¿”å›å€¼ã€‚è¿”å›ä¸€ä¸ª Promise&lt;Option<T>&gt;çš„ç»“æœï¼Œæ³¨æ„ä¸€ä¸ªOption&lt;Promise<T>&gt;çš„ç±»å‹æ˜¯æ²¡æœ‰å®ç”¨æ„ä¹‰çš„ï¼Œå› ä¸ºä¸ç®¡resolveè¿˜æ˜¯rejectï¼Œéƒ½ä¼šå¾—åˆ°ä¸€ä¸ªSomeç»“æœï¼Œæ‰€ä»¥ä¸€ä¸ªå®ç”¨çš„åŒ…è£…åº”å½“æ˜¯ Promise&lt;Some<T>&gt;ä¸Promise<None>ï¼Œå¯¹åº”äº†resolveä¸rejectçš„ç»“æœã€‚</p>
<p>å®ç°ä¸Šå¾ˆç®€å•ï¼ŒæŠŠ throwã€reject åŒ…è£…æˆ None, æŠŠ resolve å’Œæ­£å¸¸æ‰§è¡ŒåŒ…è£…ä¸º Some å³å¯ã€‚</p>
<h3 id="å…¶ä»–çš„æ–¹æ³•">å…¶ä»–çš„æ–¹æ³•</h3>
<p>Option æä¾›äº†ä¸€äº›å…¶ä»–çš„æ–¹æ³•ï¼Œå®ç°éƒ½å¾ˆç®€å•ï¼Œæ„ä¹‰ä¹Ÿæ¸…æ¥šæ‰€ä»¥ä¸è¯¦ç»†ä»‹ç»ã€‚</p>
<pre><code class="language-ts">isNone()
isSome()
map&lt;U&gt;(this: Option&lt;T&gt;, f: (val: T) =&gt; U): Option&lt;U&gt;
</code></pre>
<h2 id="resultt-e-in-ts">Result&lt;T, E&gt; in TS</h2>
<p>Result è·Ÿ Option çš„å®ç°å°±æ²¡æœ‰å¤ªå¤§å·®åˆ«äº†ï¼Œé™¤äº† Result åœ¨å¤±è´¥æ—¶å¯ä»¥æºå¸¦é”™è¯¯ä¿¡æ¯</p>
<pre><code class="language-ts">export type Ok&lt;T&gt; = ResultType&lt;T, never&gt;;
export type Err&lt;E&gt; = ResultType&lt;never, E&gt;;
export class ResultType&lt;T, E&gt; {
   readonly [SymbolT]: boolean;
   readonly [SymbolVal]: T | E;

   constructor(val: T | E, ok: boolean) {
      this[SymbolVal] = val;
      this[SymbolT] = ok;
   }
}
</code></pre>
<p>Ok ä¸ Err çš„æ„é€ æ–¹å¼ä¹Ÿå¾ˆç®€å•</p>
<pre><code class="language-ts">export function Ok&lt;T&gt;(val: T): Ok&lt;T&gt; {
   return new ResultType&lt;T, never&gt;(val, true);
}
export function Err&lt;E&gt;(val: E): Err&lt;E&gt; {
   return new ResultType&lt;never, E&gt;(val, false);
}
</code></pre>
<h2 id="match-in-ts">match in TS</h2>
<p>oxide.ts å¯¹ match çš„å®ç°åº”è¯¥æ˜¯æœ€å¥½ç©çš„åœ°æ–¹ï¼Œåœ¨çœ‹å¦‚ä½•å®ç°ä¹‹å‰ï¼Œå…ˆçœ‹å®ç°äº†æ€æ ·çš„åŠŸèƒ½</p>
<pre><code class="language-ts">// mapped matching
const num = Option(10);
const res = match(num, {
   Some: (n) =&gt; n + 1,
   _: () =&gt; 0,
});
assert.equal(res, 11);

// chained matching
function matchArr(arr: number[]): string {
   return match(arr, [
      [[1], &quot;1&quot;],
      [[2, (x) =&gt; x &gt; 10], &quot;2, &gt; 10&quot;],
      [[_, 6, 9, _], (a) =&gt; a.join(&quot;, &quot;)],
      () =&gt; &quot;other&quot;,
   ]);
}
assert.equal(matchArr([1, 2, 3]), &quot;1&quot;);
assert.equal(matchArr([2, 12, 6]), &quot;2, &gt; 10&quot;);
assert.equal(matchArr([2, 4, 6]), &quot;other&quot;);
assert.equal(matchArr([3, 6, 9]), &quot;other&quot;);
assert.equal(matchArr([3, 6, 9, 12]), &quot;3, 6, 9, 12&quot;);
</code></pre>
<ol>
<li>Mapped matching å®ç°äº†å¯¹ Option / Result çš„åŒ¹é…ï¼Œ</li>
<li>Chained matching å®ç°äº†æ›´åŠ çµæ´»ã€å®šåˆ¶åŒ–çš„åŒ¹é…ï¼Œå¯ä»¥åŒ¹é…å…·ä½“çš„å€¼ã€ä¹Ÿå¯ä»¥ä½¿ç”¨è§„åˆ™å»åŒ¹é…</li>
</ol>
<h3 id="å®ç°">å®ç°</h3>
<p>Match çš„ç›¸å…³å®ç°é•¿ä¸‹é¢è¿™æ ·ï¼š</p>
<pre><code class="language-ts">export const Default: any = () =&gt; {
   throw new Error(&quot;Match failed (exhausted)&quot;);
};
export function match&lt;T, U&gt;(
   val: T,
   pattern: MappedBranches&lt;T, U&gt; | ChainedBranches&lt;T, U&gt;
): U {
   return matchDispatch(val, pattern, Default);
}

function matchDispatch&lt;T, U&gt;(
   val: T,
   pattern: ChainedBranches&lt;T, U&gt; | MappedBranches&lt;T, U&gt;,
   defaultBranch: DefaultBranch&lt;U&gt;
): U {
   if (Array.isArray(pattern)) {
      return matchChained(val, pattern, defaultBranch);
   } else if (isObjectLike(pattern)) {
      return matchMapped(val, pattern, defaultBranch);
   }

   throwInvalidPattern();
}
</code></pre>
<p>matchæ¥æ”¶å¾…åŒ¹é…çš„å€¼è·Ÿåˆ†æ”¯çš„æ¨¡å¼ä½œä¸ºå‚æ•°ï¼Œç„¶åè°ƒç”¨ matchDispatchã€‚</p>
<p>åˆ†æ”¯æœ‰mappedå’Œchainedä¸¤ç§ï¼Œé€šè¿‡ isArray å’Œ isObjectLike åŒºåˆ†ï¼Œç„¶ååˆ†åˆ«è¿›å…¥ mapped å’Œ chained çš„å¤„ç†é€»è¾‘ã€‚</p>
<h4 id="mapped">mapped</h4>
<p>matchMapped åªæ”¯æŒå¯¹ Option å’Œ Result è¿›è¡ŒåŒ¹é…ï¼Œç„¶åå¯¹ pattern ä¸­çš„é¡¹è¿›è¡ŒåŒ¹é…ã€‚</p>
<pre><code class="language-ts">function matchMapped&lt;T, U&gt;(
   val: T,
   pattern: OptionMapped&lt;any, U&gt; &amp; ResultMapped&lt;any, any, U&gt;,
   defaultBranch: DefaultBranch&lt;U&gt;
): U {
   if (Option.is(val)) {
      if (val[SymbolT]) {
         if (pattern.Some) {
            if (typeof pattern.Some === &quot;function&quot;) {
               // å¯¹äº Some ç±»å‹ï¼Œå¦‚æœå…¶åŒ¹é…åè·Ÿçš„æ˜¯ functionï¼Œè¯´æ˜æ˜¯å¯¹å€¼çš„ä»»æ„åŒ¹é…
               return pattern.Some(val[SymbolVal]);
            } else {
               // ä¸æ˜¯functionï¼Œè¯´æ˜å¯èƒ½æœ‰æ›´è¿›ä¸€æ­¥çš„åŒ¹é…ï¼ˆå…·ä½“çš„å€¼ã€ä½ç½®ç­‰ç­‰ï¼‰ï¼Œåˆ™å†æ¬¡è°ƒç”¨dispatchå¯¹å€¼è¿›è¡Œæ›´ç»†åŒ–çš„åŒ¹é…ï¼Œæ³¨æ„çš„æ˜¯ç¬¬ä¸‰ä¸ªå‚æ•°defaultBranchï¼Œå¦‚æœSomeä¸­æä¾›äº†é»˜è®¤åˆ†æ”¯ï¼Œé‚£ä¹ˆè¿›å…¥ï¼Œå¦åˆ™ä¸è¿›å…¥è¯¥åˆ†æ”¯è€Œæ˜¯ä½¿ç”¨å¤–å±‚çš„é»˜è®¤åˆ†æ”¯ï¼ˆå³æœ€å¤–å±‚çš„ _: () =&gt; somethingï¼‰
               return matchDispatch(
                  val[SymbolVal],
                  pattern.Some,
                  typeof pattern._ === &quot;function&quot; ? pattern._ : defaultBranch
               );
            }
         }
      } else if (typeof pattern.None === &quot;function&quot;) {
         // å¯¹NoneåŒ¹é…çš„å¤„ç†
         return pattern.None();
      }
   } else if (Result.is(val)) {
      // å¯¹Resultåˆ†æ”¯çš„å¤„ç†ï¼Œè·ŸOptionåŸºæœ¬ç›¸åŒ
      const Branch = val[SymbolT] ? pattern.Ok : pattern.Err;
      if (Branch) {
         if (typeof Branch === &quot;function&quot;) {
            return Branch(val[SymbolVal]);
         } else {
            // æ—¢æ²¡åœ¨Optionä¸­åŒ¹é…åˆ°ä¹Ÿæ²¡åœ¨Resulté‡ŒåŒ¹é…åˆ°ï¼Œè¿›å…¥é»˜è®¤åˆ†æ”¯ï¼Œå¦‚æœæä¾›äº† _ çš„åŒ¹é…å°±æ‰§è¡Œè‡ªå®šä¹‰çš„é»˜è®¤åˆ†æ”¯ï¼Œå¦åˆ™è¿›å…¥å‚æ•°çš„defaultBranch
            // æœ€ä¸Šé¢çš„ defaultBranch ä¼ å…¥äº†ä¸€ä¸ªä¼šæŠ›å‡ºå¼‚å¸¸çš„å‡½æ•°Defaultï¼Œå³ä»£è¡¨æ²¡æœ‰åˆ†æ”¯èƒ½å¤„ç†valï¼Œè¿™æ˜¯ä¸å¯æ¥å—çš„
            return matchDispatch(
               val[SymbolVal],
               Branch,
               typeof pattern._ === &quot;function&quot; ? pattern._ : defaultBranch
            );
         }
      }
   } else {
      throwInvalidPattern();
   }

   return typeof pattern._ === &quot;function&quot; ? pattern._() : defaultBranch();
}
</code></pre>
<h4 id="chained">chained</h4>
<p>Chained mapping æ”¯æŒæ›´åŠ çµæ´»çš„æ¨¡å¼åŒ¹é…ï¼Œä¸‹é¢å±•ç¤ºéƒ¨åˆ†åŒ¹é…çš„æ–¹å¼</p>
<pre><code class="language-ts">const res = match(input, [
   [1, &quot;number&quot;], // åŒ¹é…å‡†ç¡®çš„å€¼
   [testObj, &quot;object&quot;], // åŒ¹é…å‡†ç¡®çš„å¯¹è±¡ï¼ˆæµ…ï¼ŒåŒä¸€ä¸ªå¯¹è±¡æ‰èƒ½åŒ¹é…ä¸Šï¼‰
   [&quot;test&quot;, (val) =&gt; `string ${val}`], // åŒ¹é…å‡†ç¡®çš„å€¼ï¼Œå¹¶ä½¿ç”¨å‡½æ•°ä½œä¸ºResultï¼Œä»¥æ•è·åˆ° match çš„ input å€¼
   [(val) =&gt; val === true, &quot;true&quot;], // æä¾› filter ä½œä¸ºåŒ¹é…æ¡ä»¶
   [(val) =&gt; (val as number) &gt; 5, (val) =&gt; `num ${val}`], // æä¾› filter ä¸ºåŒ¹é…æ¡ä»¶ï¼Œå¹¶ä½¿ç”¨å‡½æ•°ä½œä¸º Result æ•è· input
   [Fn(returnTrue), &quot;fn true&quot;], // åŒ¹é…ä¸€ä¸ªå‡½æ•° returnTrueï¼Œä½¿ç”¨ Fn() åŒ…è£…ä»¥è·Ÿ filter åŒºåˆ†å¼€
   [Fn(returnFalse), &quot;fn false&quot;], // åŒ¹é…ä¸€ä¸ªå‡½æ•° returnFalseï¼Œä½¿ç”¨ Fn() åŒ…è£…ä»¥è·Ÿ filter åŒºåˆ†å¼€
   () =&gt; &quot;default&quot;, // é»˜è®¤åŒ¹é…ï¼Œå¦‚æœæ²¡æ³•åŒ¹é…åˆ°ä¸Šè¿°é¡¹å°†æ‰§è¡Œ
]);
</code></pre>
<pre><code class="language-ts">type ChainedBranches&lt;T, U&gt; =
   | Branch&lt;T, U&gt;[]
   | [...Branch&lt;T, U&gt;[], DefaultBranch&lt;U&gt;];

function matchChained&lt;T, U&gt;(
   val: T,
   pattern: ChainedBranches&lt;T, U&gt;,
   defaultBranch: DefaultBranch&lt;U&gt;
): U {
   // éå† chianed branchesï¼Œå¾—åˆ°æ¯ä¸ªåˆ†æ”¯
   for (const branch of pattern) {
      // åˆ†æ”¯å…è®¸æ¥å—å‡½æ•°ä½œä¸ºåˆ†æ”¯ï¼Œé™å®šä¸ºç»è¿‡ `Fn&lt;U&gt;` wrap è¿‡çš„å‡½æ•°ä»¥åŠé»˜è®¤çš„åˆ†æ”¯ () =&gt; U
      if (typeof branch === &quot;function&quot;) {
         return (branch as Fn&lt;U&gt;)[FnVal] ? (branch as Fn&lt;U&gt;)[FnVal] : branch();
      } else {
         const [cond, result] = branch;
         // æ¯ä¸ªåˆ†æ”¯åˆ†ä¸ºæ¡ä»¶ä¸ç»“æœï¼Œä½¿ç”¨ matches åˆ¤æ–­æ˜¯å¦åŒ¹é…ä¸Šäº†ï¼Œåœ¨åŒ¹é…ä¸Šçš„æƒ…å†µä¸‹ï¼š
         if (matches(cond, val, true)) {
            if (typeof result === &quot;function&quot;) {
               // å¦‚æœç»“æœæ˜¯ `Fn&lt;U&gt;` wrap è¿‡çš„åˆ™è¿”å›å‡½æ•°æœ¬èº«
               // ç»“æœæ˜¯æ™®é€šå‡½æ•°å°±æ‰§è¡ŒåŒ¹é…ç»“æœ
               return (result as Fn&lt;U&gt;)[FnVal]
                  ? (result as Fn&lt;U&gt;)[FnVal]
                  : (result as (val: T) =&gt; U)(val);
            } else {
               // éå‡½æ•°å°±è¿”å›æ•°å€¼
               return result;
            }
         }
      }
   }
   // éƒ½ä¸æ˜¯åˆ™æ‰§è¡Œé»˜è®¤åˆ†æ”¯
   return defaultBranch();
}
</code></pre>
<p>ä¸‹é¢ä»‹ç»ä¸‹ <code>Fn&lt;U&gt;</code> æ˜¯åšä»€ä¹ˆçš„ï¼š</p>
<pre><code class="language-ts">export const FnVal = Symbol(&quot;FnVal&quot;);
export function Fn&lt;T extends (...args: any) =&gt; any&gt;(fn: T): () =&gt; T {
   const val: any = () =&gt; throwFnCalled();
   (val as any)[FnVal] = fn;
   return val;
}
export type Fn&lt;T&gt; = { (): never; [FnVal]: T };
</code></pre>
<p>Fn æ˜¯ç±»å‹ä¹Ÿæ˜¯å‡½æ•°ï¼Œä½œä¸ºç±»å‹çš„æ—¶å€™è¡¨ç¤ºä¸€ä¸ªæ— æ³•è¢«æ‰§è¡Œï¼ˆå³è¿”å›neverï¼Œåœ¨å®ç°é‡Œï¼Œä¸€å®šä¼šthrow ä¸€ä¸ªé”™è¯¯çš„å‡½æ•°ï¼‰ï¼Œä½†æ˜¯å­˜å‚¨äº†å‡½æ•°ï¼ˆé€šè¿‡ FnVal è¿™ä¸ª Symbol ç±»å‹æ¥ç´¢å¼•ï¼‰çš„å¯¹è±¡ã€‚</p>
<p>Fn çš„ä½œç”¨æ˜¯å°†å‡½æ•°åŒ…è£…æˆä¸€ä¸ªå¯ä»¥è¢«åŒ¹é…ã€å¯ä»¥ä½œä¸ºåŒ¹é…ç»“æœçš„å¯¹è±¡ï¼Œè€Œä¸æ˜¯åœ¨åŒ¹é…æˆåŠŸæ—¶æ‰§è¡Œã€æˆ–æ˜¯ä½œä¸º filter å­˜åœ¨ï¼Œå¦‚ä¸‹ï¼š</p>
<pre><code class="language-ts">// ä½¿ç”¨ Fn ä½œä¸ºåˆ†æ”¯ï¼ŒåŒ¹é…æˆåŠŸå°†è¿”å›å‡½æ•°
match(Some(1), [
   [Some(1), Fn(()=&gt;&quot;1&quot;)],
   Fn(()=&gt;'default'),
])()
</code></pre>
<p>ä¸‹é¢ä»‹ç»è¿”å›æ˜¯å¦åŒ¹é…æ¡ä»¶çš„ matches çš„å®ç°ï¼š</p>
<p>ä¸è¿‡å…ˆçœ‹çœ‹ä»€ä¹ˆæ ·å¯ä»¥ç®—ä¸€ä¸ªåˆç†çš„æ¡ä»¶ï¼š</p>
<pre><code class="language-ts">type Branch&lt;T, U&gt; = [BranchCondition&lt;T&gt;, BranchResult&lt;T, U&gt;];

type BranchCondition&lt;T&gt; =
   | Mapped&lt;T, boolean&gt;
   | (T extends { [T]: boolean } ? MonadCondition&lt;T&gt; : Condition&lt;T&gt;);

type Condition&lt;T&gt; = T extends object
   ? { [K in keyof T]?: BranchCondition&lt;T[K]&gt; }
   : T;

type MonadCondition&lt;T&gt; = T extends Option&lt;infer U&gt;
   ? Some&lt;MonadCondition&lt;U&gt;&gt; | None
   : T extends Result&lt;infer U, infer E&gt;
   ? Ok&lt;MonadCondition&lt;U&gt;&gt; | Err&lt;MonadCondition&lt;E&gt;&gt;
   : Wide&lt;T&gt;;

type MonadMapped&lt;T, U&gt; =
   | Mapped&lt;T, U&gt;
   | ChainedBranches&lt;T, U&gt;
   | MappedBranches&lt;T, U&gt;;
 
type Mapped&lt;T, U&gt; = (val: T) =&gt; U;
type Wide&lt;T&gt; = T extends [...infer U] ? U[number][] : Partial&lt;T&gt;;
</code></pre>
<p>æˆ‘ä»¬çŸ¥é“ä¸€ä¸ªåˆ†æ”¯åˆ†æˆæ¡ä»¶å’Œç»“æœï¼Œçœ‹ BranchCondition å³åˆ†æ”¯æ¡ä»¶ï¼Œå¯ä»¥æ˜¯ä»¥ä¸‹çš„æƒ…å†µ</p>
<ul>
<li>Mappedï¼Œè¡¨ç¤ºè¢«å‡†ç¡®åŒ¹é…çš„å€¼ï¼Œæ¯”å¦‚ Some(1) è¿™æ ·çš„</li>
<li>æ ¹æ®æ˜¯å¦æœ‰ [T] æˆå‘˜æ¥åŒºåˆ†æ˜¯å¦ Option/Resultï¼Œæ³¨æ„è¿™ä¸ª T å¹¶ä¸æ˜¯ç±»å‹ï¼Œè€Œæ˜¯é‚£ä¸ª Symbol å˜é‡
<ul>
<li>æœ‰ [T] çš„è¯´æ˜æ˜¯ Option æˆ–è€… Resultï¼Œè¿›å…¥ MonadCondition
<ul>
<li>åˆ†åˆ«é€šè¿‡åŒ¹é… Option å’Œ Result æ¥ç¡®å®šç±»å‹</li>
<li>éƒ½ä¸æ˜¯åˆ™è¿›å…¥ Wide
<ul>
<li>å¦‚æœæ˜¯æ•°ç»„å°±æ˜¯å¯¹æ•°ç»„çš„åŒ¹é…</li>
<li>å¦‚æœä¸æ˜¯æ•°ç»„å°±æ˜¯å¯¹ T éƒ¨åˆ†å­—æ®µçš„åŒ¹é…</li>
</ul>
</li>
</ul>
</li>
<li>æ²¡æœ‰ [T] è¿›å…¥æ™®é€šçš„æ¡ä»¶ Conditionï¼Œé€šè¿‡å˜é‡æ˜¯å¦å¯¹è±¡æ¥åˆ†ç±»
<ul>
<li>æ˜¯å¯¹è±¡çš„è¯ï¼Œé‚£ä¹ˆç±»å‹éœ€è¦è¿›è¡Œç­›é€‰ä¸€ä¸‹ï¼Œåªé€‰å‡ºéœ€è¦çš„å­—æ®µåŠå…¶ç±»å‹ï¼Œæ¯ä¸ªå­—æ®µéƒ½æ˜¯ä¸€ä¸ªç‹¬ç«‹çš„åˆ†æ”¯æ¡ä»¶ï¼ˆBranchConditionï¼‰</li>
<li>ä¸æ˜¯å¯¹è±¡çš„è¯å°±ç›´æ¥åŒ¹é…è¯¥å€¼çš„ç±»å‹å³å¯
Monadï¼ˆå•å­ï¼‰æ˜¯å‰é¢ä»‹ç»è¿‡çš„ä¸€ä¸ªæ¦‚å¿µï¼Œç®€å•è¯´ä»£è¡¨ä¸€ä¸ªå å‘çš„å˜é‡ï¼Œå¯ä»¥æ˜¯å‡ ç§çŠ¶æ€çš„å åŠ </li>
</ul>
</li>
</ul>
</li>
</ul>
<p>ä¸‹é¢åˆ™æ˜¯è¿”å›æ˜¯å¦åŒ¹é…æ¡ä»¶çš„ matches å‡½æ•°ï¼š</p>
<pre><code class="language-ts">function matches&lt;T&gt;(
   cond: BranchCondition&lt;T&gt;,
   val: T,
   evaluate: boolean
): boolean {
   if (cond === Default || cond === val) {
      // å¦‚æœç›´æ¥åŒ¹é…ä¸Šäº†æˆ–è€…æ˜¯é»˜è®¤åˆ†æ”¯åˆ™ç›´æ¥è¿”å›true
      return true;
   }
   if (typeof cond === &quot;function&quot;) {
      // å¦‚æœæ˜¯è¢«åŒ…è£…åçš„å‡½æ•°å°±åˆ¤æ–­æ˜¯ä¸æ˜¯è¯¥å‡½æ•°ï¼Œ
      // å¦åˆ™ï¼Œåªæœ‰åœ¨ evaluate ä¸º true ï¼ˆä»£è¡¨è¦åˆ¤æ–­å…¶å€¼ï¼‰æ—¶æ‰§è¡Œæ¡ä»¶å‡½æ•°
      return (cond as Fn&lt;T&gt;)[FnVal]
         ? (cond as Fn&lt;T&gt;)[FnVal] === val
         : evaluate &amp;&amp; (cond as (val: T) =&gt; boolean)(val);
   }
   // å¦‚æœæ˜¯å¯¹è±¡
   if (isObjectLike(cond)) {
      if (T in cond) {
         // å¦‚æœ val æ˜¯æ¡ä»¶çš„ä¸€éƒ¨åˆ†ï¼Œå†æ·±å…¥åˆ¤æ–­ï¼ˆå†æ¬¡è°ƒç”¨matchesï¼Œå­—æ®µçº§åŒ¹é…ï¼‰
         return (
            (cond as any).isLike(val) &amp;&amp;
            matches((cond as any)[Val], (val as any)[Val], false)
         );
      }
      if (isObjectLike(val) &amp;&amp; Array.isArray(cond) === Array.isArray(val)) {
         // å¯¹æ•°ç»„åŒ¹é…ï¼Œå…ƒç´ çº§åŒ¹é…
         for (const key of Object.keys(cond)) {
            if (
               !(key in val) ||
               !matches((cond as any)[key], (val as any)[key], evaluate)
            ) {
               return false;
            }
         }
         return true;
      }
   }
   return false;
}
</code></pre>
<h4 id="å°ç»“">å°ç»“</h4>
<ul>
<li>é€šè¿‡æŠŠç±»å‹ä¸€å±‚ä¸€å±‚æŠ½è±¡ï¼Œå®ç°ç±»å‹å®‰å…¨çš„åŒ¹é…</li>
<li>Chained çš„åŒ¹é…æä¾›äº†æ¯” mapped æ›´çµæ´»çš„ä½¿ç”¨æ–¹å¼</li>
</ul>
<h2 id="é¢˜å¤–">é¢˜å¤–</h2>
<h3 id="ä¸ºä»€ä¹ˆåªå¹¿æ³›åœ¨å‡½æ•°å¼ç¼–ç¨‹æµè¡Œ">ä¸ºä»€ä¹ˆåªå¹¿æ³›åœ¨å‡½æ•°å¼ç¼–ç¨‹æµè¡Œ</h3>
<p>å‚è€ƒ <a href="https://www.quora.com/Why-is-pattern-matching-prevalent-only-in-functional-programming-languages">Why-is-pattern-matching-prevalent-only-in-functional-programming-languages</a></p>
<ul>
<li>æ¨¡å¼åŒ¹é…å®é™…ä¸Šå’Œä¸€ä¸ªå¼ºå¤§çš„ç±»å‹ç³»ç»Ÿæœ‰å¾ˆå¼ºçš„å…³ç³»ï¼Œé‚£å°±æ˜¯ä»£æ•°æ•°æ®ç±»å‹ï¼ˆAlgebraic Data Typeï¼‰ï¼Œåœ¨å‰é¢ç®€å•æåˆ°è¿‡ï¼Œæ¯”å¦‚ | ä¸ºä¼ ç»Ÿçš„ union ç±»å‹æä¾›äº†æ›´å¼ºå¤§çš„è¡¨è¾¾èƒ½åŠ›ï¼Œ&amp; ä¹Ÿæ¯”å¤æ‚çš„ç»§æ‰¿æ›´å¥½å†™ã€‚</li>
<li>å› ä¸º C æ²¡æœ‰</li>
<li>åœ¨ä¸€äº›æ¯”è¾ƒæ–°çš„è¯­è¨€é‡Œï¼ˆæ¯”å¦‚ TypeScript å’Œ Rustï¼‰å¼ºå¤§çš„ç±»å‹ç³»ç»Ÿå°±ä¸ºæ¨¡å¼åŒ¹é…æä¾›äº†åœŸå£¤ã€‚</li>
</ul>
<p>ç°åœ¨çš„ OO è¯­è¨€ä¹Ÿåœ¨ä¸€äº›æ¯”è¾ƒå¾®è§‚çš„å±‚é¢ä¸Šå¼•å…¥äº†ä¸€äº›å‡½æ•°å¼ç¼–ç¨‹çš„æ¦‚å¿µï¼Œæ¥æé«˜ç¨‹åºçš„è¡¨è¾¾èƒ½åŠ›ï¼Œæ¯”å¦‚ Python3.10 å°±å¼•å…¥äº† matchï¼ŒC# ä¹Ÿå¼•å…¥äº†matchã€‚</p>
<h3 id="ecmascript-é‡Œçš„è¿›å±•">ECMAScript é‡Œçš„è¿›å±•</h3>
<p><a href="https://github.com/tc39/proposal-pattern-matching">GitHub - tc39/proposal-pattern-matching: Pattern matching syntax for ECMAScript</a></p>
<p>è¿˜åœ¨ Proposal é˜¶æ®µï¼Œæäº†å¥½å¤šå¹´äº†ä¼¼ä¹æ²¡ä»€ä¹ˆè¿›å±•ï¼Œä¸è¿‡ star è¿˜æ˜¯å¾ˆå¤šçš„</p>
<p>ææ¡ˆä¸­æä¾›äº†ç±»ä¼¼ä»¥ä¸‹çš„åŒ¹é…æ–¹å¼ï¼š</p>
<pre><code class="language-js">match (res) {
  when ({ status: 200, body, ...rest }): handleData(body, rest)
  when ({ status, destination: url }) if (300 &lt;= status &amp;&amp; status &lt; 400):
    handleRedirect(url)
  when ({ status: 500 }) if (!this.hasRetried): do {
    retry(req);
    this.hasRetried = true;
  }
  default: throwSomething();
}
</code></pre>
<p>å®é™…ä¸Šæ„Ÿè§‰ä¸å¦‚å‰é¢å®ç°çš„é‚£ç§é‚£ç§å¥½çœ‹</p>
<h2 id="æ€»ç»“">æ€»ç»“</h2>
<ol>
<li>ä»‹ç»äº†æ¨¡å¼åŒ¹é…çš„å®ç°ä¸å¥½å¤„ï¼š
<ol>
<li>ç¬¦åˆæ€è€ƒæ–¹å¼</li>
<li>æ¡ä»¶ä¸èµ‹å€¼çš„å…¼å¾—</li>
<li>è¯­å¥åˆ°è¡¨è¾¾å¼çš„è½¬å˜ï¼ˆè¡¨è¾¾èƒ½åŠ›çš„å¢å¼ºï¼‰</li>
</ol>
</li>
<li>Monad å¼çš„ç±»å‹å®‰å…¨é”™è¯¯å¤„ç†</li>
<li>ç”¨ TS å®ç° matchï¼šç±»å‹çš„ä¸€å±‚å±‚æŠ½è±¡</li>
<li>æŠ•å…¥ç”Ÿäº§ï¼ŸåŸç”Ÿçš„æ”¯æŒä¸å¤Ÿå¼ºå¤§ï¼šç¼–è¯‘å™¨å¯¹åˆ†æ”¯è¦†ç›–çš„æ£€æŸ¥èƒ½åŠ›ä¸è¶³</li>
</ol>
<h2 id="å‚è€ƒ">å‚è€ƒ</h2>
<ul>
<li><a href="https://stackoverflow.com/questions/36920427/how-is-match-implemented-in-a-language-like-rust">How is match implemented in a language like Rust?</a></li>
<li><a href="https://www.quora.com/Why-is-pattern-matching-prevalent-only-in-functional-programming-languages">Why-is-pattern-matching-prevalent-only-in-functional-programming-languages</a></li>
<li><a href="https://en.wikipedia.org/wiki/Algebraic_data_type">Algebraic-data-type-wiki</a></li>
<li><a href="https://www.typescriptlang.org/docs/handbook/2/functions.html#function-overloads">functions overload</a></li>
</ul>

        </div>
        
        <div class="my-4">
    
    <a href="/tags/typescript/" class="inline-block bg-tertiary-bg text-sm rounded px-3 py-1 my-1 mr-2 hover:text-eureka">#TypeScript</a>
    
    <a href="/tags/rust/" class="inline-block bg-tertiary-bg text-sm rounded px-3 py-1 my-1 mr-2 hover:text-eureka">#Rust</a>
    
</div>
        
        
        


        
        
        
        
<div class="flex flex-col md:flex-row md:justify-between -mx-2 mt-4 px-2 pt-4 border-t">
    <div>
        
    </div>
    <div class="md:text-right mt-4 md:mt-0">
        
        <span class="block font-bold">ä¸‹ä¸€é¡µ</span>
        <a href="/posts/rcore-camp-2022-lab4/" class="block">rCore Camp 2022 Lab4 è®°å½•</a>
        
    </div>
</div>

        



    </div>
    
    <div class="col-span-2">
        
        
        <div class="sticky top-16 z-10 hidden lg:block px-6 py-4  bg-primary-bg ">
    <span class="text-lg font-semibold">æœ¬é¡µå†…å®¹</span>
</div>
<div class="sticky-toc hidden lg:block px-6 pb-6 ">
    <nav id="TableOfContents">
  <ul>
    <li><a href="#æ¨¡å¼åŒ¹é…-pattern-matching">æ¨¡å¼åŒ¹é… (Pattern Matching)</a>
      <ul>
        <li><a href="#æ˜¯ä»€ä¹ˆ">æ˜¯ä»€ä¹ˆ</a></li>
        <li><a href="#å¥½å¤„åœ¨å“ª">å¥½å¤„åœ¨å“ª</a>
          <ul>
            <li><a href="#ç¬¦åˆäººç±»æ€è€ƒæ–¹å¼çš„è®¾è®¡">ç¬¦åˆäººç±»æ€è€ƒæ–¹å¼çš„è®¾è®¡</a></li>
            <li><a href="#æ¡ä»¶æ‰§è¡Œä¸æå–çš„å…¼å¾—">ã€æ¡ä»¶æ‰§è¡Œã€‘ä¸ã€æå–ã€‘çš„å…¼å¾—</a></li>
            <li><a href="#ä»è¯­å¥åˆ°è¡¨è¾¾å¼-çš„è½¬å˜">ä»è¯­å¥åˆ°è¡¨è¾¾å¼ çš„è½¬å˜</a></li>
          </ul>
        </li>
        <li><a href="#æ€§èƒ½æœ‰æå‡å—">æ€§èƒ½æœ‰æå‡å—ï¼Ÿ</a></li>
      </ul>
    </li>
    <li><a href="#rust-çš„-optiont-resultt-e-ä¸-match">Rust çš„ Option<T>, Result&lt;T, E&gt; ä¸ match</a>
      <ul>
        <li><a href="#optiont">Option<T></a></li>
        <li><a href="#resultt-e">Result&lt;T, E&gt;</a></li>
        <li><a href="#match">match</a></li>
      </ul>
    </li>
    <li><a href="#optiont-in-ts">Option<T> in TS</a>
      <ul>
        <li><a href="#å¯¹åŸæœ‰-api-çš„å®‰å…¨å°è£…">å¯¹åŸæœ‰ API çš„å®‰å…¨å°è£…</a></li>
        <li><a href="#å…¶ä»–çš„æ–¹æ³•">å…¶ä»–çš„æ–¹æ³•</a></li>
      </ul>
    </li>
    <li><a href="#resultt-e-in-ts">Result&lt;T, E&gt; in TS</a></li>
    <li><a href="#match-in-ts">match in TS</a>
      <ul>
        <li><a href="#å®ç°">å®ç°</a>
          <ul>
            <li><a href="#mapped">mapped</a></li>
            <li><a href="#chained">chained</a></li>
            <li><a href="#å°ç»“">å°ç»“</a></li>
          </ul>
        </li>
      </ul>
    </li>
    <li><a href="#é¢˜å¤–">é¢˜å¤–</a>
      <ul>
        <li><a href="#ä¸ºä»€ä¹ˆåªå¹¿æ³›åœ¨å‡½æ•°å¼ç¼–ç¨‹æµè¡Œ">ä¸ºä»€ä¹ˆåªå¹¿æ³›åœ¨å‡½æ•°å¼ç¼–ç¨‹æµè¡Œ</a></li>
        <li><a href="#ecmascript-é‡Œçš„è¿›å±•">ECMAScript é‡Œçš„è¿›å±•</a></li>
      </ul>
    </li>
    <li><a href="#æ€»ç»“">æ€»ç»“</a></li>
    <li><a href="#å‚è€ƒ">å‚è€ƒ</a></li>
  </ul>
</nav>
</div>
<script>
    window.addEventListener('DOMContentLoaded', () => {
        enableStickyToc();
    });
</script>
        
    </div>
    

    
    
</div>
<script>
    document.addEventListener('DOMContentLoaded', ()=>{
        hljs.initHighlightingOnLoad();
    })
</script>

      </div>
    </div>
    
  </main>
  <footer class="pl-scrollbar">
    <div class="w-full max-w-screen-xl mx-auto"><div class="text-center p-6 pin-b">
    <p class="text-sm text-tertiary-text">&copy; 2020-2022 <a href="https://www.github.com/werifu/">Werifu</a>
 &middot;  Powered by the <a href="https://github.com/wangchucheng/hugo-eureka" class="hover:text-eureka">Eureka</a> theme for <a href="https://gohugo.io" class="hover:text-eureka">Hugo</a></p>
</div></div>
  </footer>
</body>

</html>