[{"content":"æƒŠè§‰å·²ç»å¿«ä¸¤å¹´æ²¡æœ‰æ›´æ–°åšå®¢ï¼Œå…¶å®å»å¹´çš„å¹´ç»ˆæ€»ç»“åœ¨æ—§å†æ–°å¹´æ‰åœ¨ç©ºé—´/æœ‹å‹åœˆå‘è¡¨ï¼Œå¦‚æœæœ‰æœºä¼šå†è¡¥åˆ°åšå®¢ä¸Šæ¥ï¼ˆå¤§æ¦‚ç‡ä¸ä¼šæœ‰äº†å§ï¼‰ã€‚\nä½†è¿˜æ˜¯ä»å»å¹´çš„æ–°å¹´æ„¿æœ›è®²èµ·ï¼\nå¤šè·‘æ—¥ç³» liveï¼šæ²¡å¤ªå¤šé—æ†¾ï¼ˆå”¯ä¸€çš„é—æ†¾æ˜¯å»å¹´å°±çŸ¥é“å»ä¸æˆçš„ä¸Šæµ·THOï¼‰ å¤šç”»ç”»ï¼šè¿™æ˜¯çœŸæ²¡ç”»ï¼Œæ„Ÿè§‰ç‡ƒå°½äº† å¹³å®‰å³æ˜¯å–œä¹ï¼šä»Šå¹´å®¶äººéƒ½å¾ˆå¥åº·ï¼ä¸ç®—è¡°è€çš„è¯ å½“ä¸Šåˆæ ¼çš„ researcherï¼šå¤±è´¥äº†ä¸€ä¸¤å›ï¼Œè¶Šåšè¶Šè§‰å¾—è‡ªå·±æ°´å¹³å¤ªå·®äº†â€¦ åœ¨å¼‚å›½ä»–ä¹¡æ‰¾åˆ°æ–°ä¹å­ï¼šå¯¹æ–™ç†çš„è®¤è¯†å’Œå®è·µæ°´å¹³éƒ½æé«˜äº†ä¸å°‘ï¼Œè€Œä¸”æœ‰æ›´å¤šå‘æŒ¥çš„æƒ³æ³•äº†ï¼›ä¹°äº†ä¸€å°ç”µé’¢ï¼Œä½†æ˜¯çƒ­æƒ…å¥½åƒæœ‰ç‚¹ä¸å¤Ÿå¼ºï¼ˆ äº”å¹´ç­¾ï¼šå¤©å…¬ä¸ä½œç¾ï¼Œä¸€å¹´ç­¾ä¹Ÿæ˜¯å¤§æ¦‚ç‡çš„æ²¡åŠæ³•äº‹ä»¶ å¯¹äºå®Œä¸æˆæ„¿æœ›è¿™ä»¶äº‹å·²ç»ä¹ ä»¥ä¸ºå¸¸äº† XDï¼Œåªä¼šåœ¨å¹´ç»ˆçš„æ—¶å€™å°å°åœ°æ‹æ‹å¤§è…¿åæ‚”ä¸€ä¸‹ã€‚ä»Šå¹´æ€»çš„æ¥è¯´éå¸¸å¼€å¿ƒï¼Œä»å„ç§åœ°æ–¹è·å¾—äº†å¾ˆå¤šæƒ…ç»ªä»·å€¼å’Œæ–°çš„è®¤çŸ¥ï¼Œåœ¨å¾ˆå¤šæ–°çš„å†’é™©ä¸­ï¼Œæˆ‘ä»æ˜¯ä¸€ä¸ªèœé¸Ÿå‹‡è€…ï¼Œè¿˜ä¼šæ—¶ä¸æ—¶è¿›å…¥å¹»æƒ³æ—¶é—´ï¼Œè„‘è¡¥é‚£ä¸å­˜åœ¨çš„ IF çº¿ã€‚\nä»Šå¹´ä»äºŒæœˆå¼€å§‹è·‘ live ç›´åˆ° 8 æœˆå‰å¾€ç¾å›½å‰ä¸€å‘¨è¿˜åœ¨è·‘ï¼š\nå¹¿å·ï¼šèŠ±ç¢³ã€Angelaã€ã‚„ãªããªãã€JOâ­ï¸STAR æ·±åœ³ï¼šReol ä¸Šæµ·ï¼šä¼Šè—¤é¦™å¥ˆå­\u0026amp;å½©éŸ³ã€TRUEã€Raise A Suilenã€Roselia åå¤å±‹ï¼šAve Mujica ä» 19 å¹´ 8 æœˆè‡ªå·±å»ä¸Šæµ· THO åï¼Œæˆ‘åº”è¯¥å°±å·²ç»æˆä¸ºä¸€ä¸ªæ—¥éŸ³ live çˆ±å¥½è€…äº†ï¼Œå¦‚æœæ²¡æœ‰ COVID çš„è¯æˆ‘æƒ³ç–¯ç‹‚çš„ live å¹´åªä¼šæå‰åˆ°æ¥ã€‚ä»Šå¹´çœŸæ­£åœ°æˆä¸ºäº†é‚¦é‚¦è…ä¹³ï¼Œæœ€å–œæ¬¢çš„ç°åœºä¸€å®šæ˜¯ RAS ä¸ Roseliaã€‚Mujica çš„è¯ï¼Œè™½ç„¶æ­Œéå¸¸å–œæ¬¢ï¼Œä½†æˆ‘å¯èƒ½è¿˜æ˜¯æ›´æƒ³çœ‹æ‘˜é¢å…·å¸¦ MC ç‰ˆæœ¬çš„ç°åœºï¼Œå¯æƒœé¸¡ç‹—å¯¹é‚¦ä¸ä¼šæœ‰æˆ‘äº†ã€‚ä»¥åŠç¡®å®çœŸçš„ GO äº†ä¸€æ•´å¹´ï¼Œå¤ªæœ‰é­…åŠ›äº† MyGOï¼Œæ›´å¹¸è¿çš„æ˜¯æœ‰äººé™ªæˆ‘ä¸€èµ· GOã€‚\nä»Šå¹´å› ä¸º live æˆ‘ä¸æ—§å‹åˆç´§å¯†è”ç³»åœ¨ä¸€èµ·ã€æœ‰äº†æ–°çš„å¸¸é©»æ°´ç¾¤ã€è®¤è¯†äº†é‡è¦çš„äººï¼Œä»¥åŠé”šå®š live çš„æ—¶é—´åˆå®‰æ’äº†åæ¥å¤©çš„æ—¥æœ¬æ—…è¡Œï¼Œé¦™æ¸¯-\u0026gt;åå¤å±‹-\u0026gt;å¤§é˜ª-\u0026gt;äº¬éƒ½-\u0026gt;å®‡æ²»-\u0026gt;å¥ˆè‰¯-\u0026gt;ä¸œäº¬-\u0026gt;é¦™æ¸¯ã€‚è¿™è¶Ÿæ—¥æœ¬ä¹‹æ—…è®©æˆ‘è§‰å¾—è¿™ä¹ˆå¤šå¹´å­¦çš„äºŒæ¬¡å…ƒæ—¥è¯­æœ‰ç‚¹ç”¨ï¼Œåœ¨è·Ÿäººäº¤æµæ–¹é¢æˆ–è®¸è¿˜æ¯”è‹±è¯­é¡ºç•…ï¼ˆå¯¹äº† 23 å¹´ 12 æœˆçš„ N1 æœ€ç»ˆä¹Ÿç²¾å‡†å‹çº¿(100/180)é£˜è¿‡äº†ï¼‰å¯ä»¥åœ¨æ—…é€”ä¸­å……å½“é˜Ÿå†…å¸¦é˜Ÿå¤§çˆ¹å½¹ï¼ˆ\næ—…ç¨‹æœ€æ ¸å¿ƒçš„ä½“éªŒï¼šMujica 2ndã€äº¬éƒ½æ¼«æ­¥ã€å®‡æ²»å·¡ç¤¼ã€ç¿»äºŒæ‰‹åƒåœ¾ã€‚æ„Ÿæ…¨å…³è¥¿æ¯”å…³ä¸œå¥½ç©ï¼Œéå¸¸äº«å—åœ¨é¸­å·è¾¹æ•£æ­¥çš„ä½“éªŒï¼Œä»¥åŠåœ¨å®‡æ²»æ„Ÿå—åŒ—å®‡æ²»ä¼—äººåœ¨æ­¤ç”Ÿæ´»çš„åœºæ™¯ã€‚\nå¯¹äº¬å¹3ç»“å±€æœ‰æ„è§ä¸å‡ï¼Œä½†å®‡æ²»ä¾ç„¶æ˜¯æˆ‘top1å·¡ç¤¼ç›®æ ‡ï¼Œä¾ç„¶æ˜¯æˆ‘å¿ƒä¸­æœ€ä¼Ÿå¤§çš„ç¾¤åƒåŠ¨ç”»ï¼Œæœ‰æœ‹å‹åŒæˆ‘ä¸€èµ·å·¡ç¤¼ï¼Œåˆ†äº«è§é—»æ›´æ˜¯ä¸€ä»¶å¹¸äº‹ã€‚æˆ‘æœ€çˆ±å¸¸èŠçš„å°å›¢ä½“ä¼¼ä¹å¤§å¤šéƒ½æœ‰ä¸ªè¿™æ ·çš„ç‰¹å¾ï¼šä¸€èµ·å‡ºå»æ—…è¡Œè¿‡ã€‚ä¸çŸ¥é“æ˜¯ä»€ä¹ˆåŸç†ï¼Œä½†ä¼¼ä¹çº¿ä¸‹çŸ­æœŸç›¸å¤„å°±æ˜¯èƒ½ä¿æŒè”ç³»çš„æ¬²æœ›ï¼Œè€Œä¸”å¯ä»¥æŒç»­æ•°å¹´ä¹‹ä¹…ï¼Œå¯èƒ½æ¯å¤©èŠå¤©å†…å®¹ä¸è¿‡ä¸€äº›æ²¡è¥å…»çš„äº’è”ç½‘ memeï¼Œä½†å°±æ²¡è…»è¿‡ã€‚\nå»æ—¥æœ¬ä¹‹å‰çš„å¦ä¸€ä¸ªé•¿æ—…é€”æ˜¯ä»é¦™æ¸¯å‡ºå‘å»ä¸Šæµ·çœ‹liveã€å»åŒ—äº¬è§åŒå­¦+é¢ç­¾ã€å»æ­¦æ±‰è§åŒå­¦çš„è¡Œç¨‹ï¼ŒåŸæœ¬æ˜¯å†™åœ¨ Arc æµè§ˆå™¨é‡Œçš„ç¬”è®°ï¼Œè¿™é‡Œå°±ç›´æ¥è´´å‡ºæ¥äº†ã€‚æˆ‘è§‰å¾— Arc Easels æ˜¯ä¸ªå¾ˆå¥½çš„ç¬”è®°è½½ä½“ï¼Œè·Ÿ telegraph æœ‰å¾—ä¸€æ‹¼ã€‚\nEp1 å»ä¸Šæµ· Ep2 çœ‹RAS Ep3 å»åŒ—äº¬ Ep4 å»æ­¦æ±‰ æ—…é€”çš„æœ«å°¾å†™äº†ä¸€æ®µè¯æˆ‘ç°åœ¨ä¾ç„¶è§‰å¾—å¾ˆå–œæ¬¢ï¼š\næ—…é€”åˆè§åˆ°äº†å¾ˆå¤šæœ‹å‹ï¼Œå³æ˜¯å†ä¼šåˆæ˜¯å‘Šåˆ«ï¼Œæ­¤æ¬¡ä¸€åˆ«ä¸çŸ¥ä½•æ—¶ç›¸è§ã€‚\nä¸€ç›´è§‰å¾—è‡ªå·±æ˜¯ä¸ªå¾ˆæ´»åœ¨è¿‡å»çš„äººï¼Œå´æ€»æ˜¯åœ¨å°è¯•å¼€å¯æ–°çš„ä½“éªŒï¼Œä¸çŸ¥ä»€ä¹ˆæ—¶å€™æ‰æœ‰è½åœ°çš„ä¸€å¤©ï¼Œåœ¨è¿™ä¹‹å‰å…ˆäº«å—æ¯ä¸€æ®µå†’é™©å§\nå…«æœˆå»ä¸Šæµ·ç‰¹ç§çœ‹ Roselia çš„æ—…é€”æ›´æ˜¯èœé¸Ÿå‹‡è€…ä»Šå¹´æœ€çè§†çš„ä¸€ç•ªã®å®ç‰©ï¼Œå±äºé¼ é¼ çš„ç§‘å¹»æ•…äº‹ã€‚\nå¯¹è¿™ä¸¤é¡µéå¸¸æœ‰è§¦åŠ¨ğŸ˜­å¯é çš„åƒå¤å­¦å§åœ¨ä¸€ä¸ªç ”ç©¶ç”Ÿçš„è§†è§’é‡Œå®é™…ä¸Šå·²ç»æ˜¯ä¸ªå°å¦¹å¦¹äº†ï¼Œç„¶è€Œå¤§äººä¹Ÿæœ‰å¦‚æ­¤çš„çƒ¦æ¼ï¼Œå´å·²ç»æ²¡æœ‰äººå¯ä»¥æ’è§£äº†ï¼Œé“ç†éƒ½æ‡‚ï¼Œå®è·µéƒ½å¯„ï¼Œè¿™å°±æ˜¯äººç”Ÿçš„ä¸åœ†æ»¡å•Šã€‚\nå½“å›ä¿³å¥ä»™äººï¼šå›å¿†å…¥å¿ƒå¤´ï¼Œå¼‚ä¹¡ç”Ÿæ ¹è™½ä¸æ„ï¼ŒIFçº¿éš¾æ±‚ã€‚\næ¥ç¾å›½å‰çš„æ•…äº‹å°±æ˜¯è¿™æ ·ï¼Œè¿™ä¸æ˜¯ä¸€ä¸ªæ‚²å‰§ï¼Œè€Œæ˜¯è¿½æ±‚çš„ä¸€æ®µæ¼«é•¿çš„æ–°å†’é™©ã€‚\nç¬¬ä¸€ä¸ªå­¦æœŸçš„èŠ‚å¥åªèƒ½ç”¨æƒ­æ„§æ¥å½¢å®¹ï¼Œä¸åƒæ˜¯ç½‘ä¸Šæ¸²æŸ“çš„è‰°è‹¦ PhD ç”Ÿæ´»ï¼Œæ­£æ˜¯å› ä¸ºè¿‡å¾—å¤ªæ»‹æ¶¦äº†æ‰å¿ƒç”Ÿæƒ­æ„§â€¦â€¦è§‰å¾—è‡ªå·± self-motivation ä¸åˆ°ä½ï¼Œè€æ¿äººä¹Ÿå¾ˆå¥½ã€‚åœ¨ PL researcher è¿™æ¡è·¯ä¸Šæ„Ÿè§‰ä»Šå¹´å¹¶æ²¡æœ‰è¿ˆå‡ºå¤šå¤§çš„æ­¥ä¼ï¼Œè¢«æ¯™äº†ä¸€ä¸ªé¡¹ç›®çš„æ—¶å€™æ‰è§‰å¾—åŸæ¥è‡ªå·±çš„æƒ³æ³•é‚£ä¹ˆç¨šå«©ä¸”å‡†å¤‡ä¸å‘¨ã€‚è€æ¿å¸¸å¸¸é¼“åŠ±æˆ‘è¯´åšä¸€è¿™æ ·ä¸è¦ç´§ï¼Œç„¶è€Œå¿ƒé‡Œè¿˜æ˜¯ä¼šæ„Ÿåˆ°å¤±è½ã€‚ä¸è¿‡è¿™äº›å¤§æ¦‚ç‡éƒ½æ˜¯ä¸€ä¸ª PhD å­¦ç”Ÿçš„å¿…ç»ä¹‹è·¯å•¦ XDã€‚ å·²ç»å­¦ä¼šè‡ªæˆ‘æ’è§£ï¼ŒçŸ­æœŸå†… mental health åº”è¯¥è¿˜ä¸æˆé—®é¢˜ã€‚\nç³»é‡ŒçœŸæ˜¯ä»™ä¹‹äººå…®åˆ—å¦‚éº»å•Šï¼Œè®¤è¯†äº†å¾ˆå¤šå¼ºå¤§çš„å‰è¾ˆï¼Œå¯ä»¥å­¦åˆ°å¾ˆå¤šã€‚\næ¥ç¾å›½å‰æ‹…å¿ƒçš„äºŒæ¬¡å…ƒé—®é¢˜æ„Ÿè§‰ç™½æ‹…å¿ƒäº†ï¼Œé™¤äº†æ²¡ liveï¼Œåœ¨ä¸­æ–‡åœˆå­å†…åˆ«çš„å¥½åƒè·Ÿå›½å†…ä¸€ç‚¹åŒºåˆ«éƒ½æ²¡æœ‰â€¦åŠ å…¥çš„ç¾¤è·Ÿä»¥å‰çš„ ACG ç›¸å…³ç¾¤èŠä¸€æ¨¡ä¸€æ ·ï¼ˆæŒ‡æ¬å±ï¼‰ï¼Œèƒ½èŠçš„äººä¹Ÿå¾ˆå¤šã€‚é¡¶ç€æ—¶å·®ä¸äººæ—¥å¤œé¢ å€’èŠå¤©ä¹Ÿæ˜¯å¾ˆæœ‰è¶£çš„ä½“éªŒï¼Œæ¯å¤©é†’æ¥ä¸€çœ‹åå‡ äºŒåæ¡æ¶ˆæ¯nä¸ªè¯é¢˜ä¼šåœ¨å¿ƒé‡Œæš—å–œï¼Œä¸€å¤©çš„æ„‰æ‚¦ç”±æ­¤å¼€å§‹ã€‚\nè¿˜æˆä¸ºäº† MyGO è½¦ä¸» XDã€‚ç¾å›½å†œæ‘çš„ç”Ÿæ´»å°±æ˜¯ä¸€åˆ‡ç›®çš„åœ°å‡å¼€è½¦ï¼Œå¼€å§‹æ…¢æ…¢äº«å—å¼€è½¦çš„è¿‡ç¨‹äº†ã€‚\nåœ¨ç¾å›½æ£é¼“æ–™ç†çš„ä½“éªŒåè€Œæ¯”åœ¨é¦™æ¸¯æ—¶æ›´åŠ å®Œå–„ï¼ˆå³ä½¿æ˜¯ä¸ªèšŠé¦™ç‚‰ï¼‰ï¼Œå¯èƒ½å› ä¸ºåœ¨ HK åªä½ä¸€å¹´ä»è€Œåœ¨å·¥å…·ä¸Šä¸æ•¢èŠ±å¤§æ‰‹ç¬”ï¼Œåœ¨è¿™é‡Œæˆ‘å¯ä»¥å°½æƒ…è´­å…¥å·¨é‡é¦™æ–™ä¸ç‚Šå…·ï¼Œå­¦ä¹ ä¸–ç•Œå„åœ°çš„èœè°±ï¼Œå°è¯•å¤åˆ»åœ¨é¤é¦†åƒè¿‡çš„ç¾é£Ÿã€‚æˆ–è®¸æ¡ä»¶æˆç†Ÿæˆ‘ä¼šåœ¨è¿™ä¸ªèµ›é“èµšç±³ï¼Ÿï¼ˆçº¯å¹»æƒ³æ—¶é—´ï¼‰\nä¹°äº†ä¸€å°ç”µé’¢ï¼Œå­¦ä¼šå¼¹çš„ç¬¬ä¸€é¦–æ›²å­æ˜¯ç®€åŒ–çš„ã€Šé‘é¼äººèˆæ›²ã€‹ï¼ˆæ±Ÿæ¹–ç§°å—ä¸­å¤„åˆ‘æ›²ï¼‰ã€‚ä¸Šäº†ä¸€å­¦æœŸçš„è¯¾ã€‚ä½†æ˜¯å‘ç°å·²ç»å¿«ä¸€ä¸ªæœˆæ²¡å¼¹äº†ï¼Œå³æ—¥èµ·æ¢å¤ï¼Œè¿™æ¬¡ä¸èƒ½å†ä¸‰åˆ†é’Ÿçƒ­åº¦äº†â€¦â€¦\næ–°å¹´è®¸æ„¿ï¼ çº¯å‘½æ•°æœ‰å®šçš„ï¼š\nè®©æˆ‘èƒ½å›å®¶çš„ç­¾è¯å½¢åŠ¿ è¿·ä¹‹è¯é¢˜çš„è¿›ä¸€æ­¥å‘å±• å¹³å®‰å³æ˜¯å–œä¹ï¼ˆä»Šå¹´å‘è§‰çˆ·çˆ·å¥¶å¥¶å·²ç»åŠ é€Ÿè¡°è€äº†ï¼Œçˆ·çˆ·æ›´æ˜¯ç›´è¨€éš¾ä»¥æ´»ç€ç­‰åˆ°æˆ‘æ¯•ä¸šï¼Œå¬åˆ°è¿™è¯çš„æ—¶å€™å†…å¿ƒå…¶å®æœ‰å·¨å¤§æ³¢æ¾œï¼‰ æˆ–è®¸å¯ä»¥äº‰å–çš„ï¼š\nå»ºç«‹è‰¯å¥½ä¸”æœ‰æ•ˆç‡çš„ work life balanceï¼ˆ=æé«˜ä¸“æ³¨å·¥ä½œæ—¶é—´ï¼‰ 0 paper çš„çªç ´ å…»æˆå¼¹ç´çš„ä¹ æƒ¯ ç”»ç‚¹åŒäººï¼ˆå¥½åƒè¿™å‡ å¹´éƒ½è®¸äº†è¿™ä¸ªæ„¿æœ›ï¼Œä½†æ˜¯éƒ½å¤±è´¥äº†ï¼Œ2025 èƒ½æœ‰ä¸ä¸€æ ·å—ï¼‰ è‡ªé©¾è¿œå¾è§ç½‘å‹ å®ä¹ çš„é¢è¯•ï¼ˆä¹Ÿå¾—ç­‰æœ‰è®ºæ–‡â€¦â€¦ï¼‰ ","date":"2024-12-31T19:49:50-05:00","image":"/p/end-of-2024/cover_huab7da664ee7c45c7e3b110044d9428c8_168714_120x120_fill_q75_box_smart1.jpeg","permalink":"/p/end-of-2024/","title":"End of 2024"},{"content":"ã€æœ¬æ–‡å†™äº2024å¹´çš„å†œå†æ–°å¹´ï¼Œåœ¨2025å¹´æ–°å†æ–°å¹´è¡¥å…¨ã€‘\nå¹´åº•å› ä¸ºä¸€äº›æœºç¼˜å·§åˆç«™åœ¨äº†ä¸–ç•Œçº¿å˜åŠ¨çš„åå­—è·¯å£ï¼Œä¸ºäº†ç¡®å®šå°†æ¥çš„æ‰“ç®—æ‰€ä»¥æŠŠæ€»ç»“æ¨è¿Ÿåˆ°äº†ç°åœ¨ã€‚\næ€»å½’æ˜¯ä¸ªæ¯”2022å¹´å¥½å¾ˆå¤šçš„ä¸€å¹´ï¼Œå»å¹´æäº†å‡ ä¸ªè®¡åˆ’ï¼Œåˆ†åˆ«æ˜¯\næœ‰è¶£çš„ä¸œè¥¿ï¼ˆæˆ‘è§‰å¾—å§‘ä¸”åšäº†ï¼‰ N1ï¼ˆè™½ç„¶æŒ‚äº†ä¸€æ¬¡ï¼Œä½†è¿˜æ˜¯åœ¨12æœˆçš„è€ƒè¯•é‡Œè¿‡äº†ï¼‰ å‡å°‘ç„¦è™‘ï¼ˆè§‰å¾—ç¡®å®å°‘äº†ï¼‰ å¤šç”»ç‚¹ç”» æœ€åè¿™ä¸ªç¡®å®å¾ˆæƒ­æ„§ï¼Œä¸€å¹´é‡Œåªç”»äº†å‡ å¼ è½¦ä¸‡å°å¡ç‰‡æ¯”è¾ƒå–œæ¬¢ã€‚\nå°±è¿™ä¹ˆæ»šå‡ºåç§‘äº†ï¼Œæœ¬ç§‘å››å¹´COVIDç‹¬å ä¸‰å¹´ï¼Œä¸€æƒ³åˆ°è¿™ä¸ªå°±è§‰å¾—å¾ˆéš¾è¿‡ï¼Œå»å¹´è·‘äº†å¾ˆå¤šæ´»åŠ¨æ‰å‘ç°åŸæ¥æ²¡æœ‰å‡ºè¡Œç®¡åˆ¶çš„ç”Ÿæ´»æ˜¯è¿™ä¹ˆçˆ½ã€‚åœ¨HUSTè®¤è¯†å¾ˆå¤šè¦å¥½çš„æœ‹å‹æ˜¯æˆ‘æœ€å¤§çš„æ”¶è·ã€‚\nå»å¹´å¨è‰ºä¹Ÿå¾€ä¸Šæ¶¨äº†è®¸å¤šï¼Œå¯¹ç†Ÿæ‚‰é£Ÿæçš„é™Œç”Ÿç»„åˆèƒ½æœ‰æ¯”è¾ƒå‡†çš„é¢„æœŸäº†ï¼Œä¹Ÿå°è¯•äº†ä¸å°‘æˆ‘å–œæ¬¢çš„æ„å¤§åˆ©èœï¼ˆå„ç§å½¢æ€çš„æ„é¢ã€åƒå±‚é¢ã€åƒå±‚é¥¼ï¼Œå¥½æƒ³è¯•è¯•åšæŠ«è¨ï¼Œå¯æƒœæ²¡æœ‰æœºä¼šï¼‰ï¼Œæ„Ÿè°¢è’éƒŠé‡å²­çš„ç½‘å®‰åŸºåœ°ä»¥åŠåƒé¥­å—¨è´µçš„é¦™æ¸¯ã€‚\nå»äº†å¾ˆå¤šæ´»åŠ¨ï¼Œè·‘äº†ä¸¤æ¬¡ä¸Šæµ·ï¼Œæœ€é‡è¦çš„å¤§æ¦‚æ˜¯CP29ã€éŸ³å¾‹è”è§‰å’Œä¸Šæµ·THOï¼ˆè§åˆ°äº†å†·çŒ«ğŸ¥°ï¼‰ è¿˜åœ¨Majikoçš„liveä¸Šè®¤è¯†äº†æ–°æœ‹å‹\næ¯•ä¸šæ—…è¡Œå»äº†å·è¥¿ï¼Œå“å¤ªç¾ä¸½äº†ï¼Œå¥½æƒ³æ¢ä¸ªå­£èŠ‚å†å»ä¸€æ¬¡ã€‚ä¸è¿‡æ›´èˆ’å¿ƒçš„å¤§æ¦‚æ˜¯é™ªæœ‹å‹å‡ºå»ç©è¿™ä»¶äº‹æœ¬èº«ã€‚\nå»å¹´æœ€é‡è¦çš„äº‹æƒ…åº”è¯¥æ˜¯å†³å®šè¯»PhDï¼Œå‡ºæ¥å·¥ä½œå’Œå»è¯»åšå¤§æ¦‚ä¼šç•™ä¸‹å¾ˆä¸ä¸€æ ·çš„äººç”Ÿè½¨è¿¹ã€‚å†³å®šæ˜¯å¶ç„¶çš„ï¼Œä½†ä¸æ˜¯è‰ç‡çš„ï¼ˆè¿«çœŸï¼‰ï¼Œä»¥å‰å°±çŸ¥é“è¿™æ¡è·¯çš„ç—›è‹¦ï¼Œæ¯ä¸ªåšå£«ç”Ÿå¤§æ¦‚ä¹Ÿéƒ½ä¼šæœ‰è¢«åŠé€€çš„ç»å†ï¼Œä¸è¿‡äººè·ŸçŒ«æˆ–è®¸ä¹Ÿæ²¡æœ‰å¾ˆå¤§åŒºåˆ«ï¼Œå°±ç®—çŸ¥é“ä¹Ÿæƒ³æ‰‹è´±è¯•ä¸€è¯•ï¼Œè¯´ä¸å®šäº”å¹´æ¯•ä¸šåå›æœ›è¯»åšçš„å…­å¹´ä¼šè§‰å¾—é‚£æ˜¯æœ€éš¾å¿˜çš„ä¸ƒå¹´ï¼Œå¯¹è‡ªå·±è¿˜å¾ˆé•¿çš„ç”Ÿå‘½è€Œè¨€ä¸è¿‡æ˜¯çŸ­çŸ­çš„å…«å¹´ (Â´-ï¹-`ï¼›)\nä¸­é—´å¾—åˆ°äº†å¾ˆå¤šè€å¸ˆåŒå­¦æœ‹å‹çš„å¸®åŠ©ï¼Œæ„Ÿæ¿€ä¹‹æƒ…æ— ä»¥è¨€è¡¨â•°(Â´ï¸¶`)â•¯\nè¯´èµ·æ¥ï¼ŒUSçš„ç”Ÿæ´»å¯¹æœ¬é˜¿å®…å¹¶æ²¡æœ‰ä»€ä¹ˆå¸å¼•åŠ›ï¼Œåè€Œä¼šä¸ºå°†è¦ç¦»å¼€ACGç”Ÿæ´»è€Œæ„Ÿåˆ°æ‹…å¿§ï¼Œç”šè‡³ä¸çŸ¥é“æ¯•ä¸šçš„æ—¶å€™è¿˜æœ‰æ²¡æœ‰è¿™å…´è¶£ã€‚å¤§æ¦‚èˆ¹åˆ°æ¡¥å¤´è‡ªç„¶ç›´äº†å§ï¼ˆæœ‰ç‚¹åœ°ç‹±ç¬‘è¯çš„é…å›¾ï¼‰\nä¸€äº›æ–°å¹´çš„æ„¿æœ› å¤šè·‘ç‚¹æ—¥ç³»liveâ€¦â€¦ä»¥åçœŸè¦è§ä¸åˆ°äº†ï¼Œæˆ–è®¸æˆ‘æœ€å–œæ¬¢çš„ä¸Šæµ·THOå·²ç»æ²¡æœºä¼šäº† ä¿æŒç»˜ç”»æ¶ˆé£ï¼ˆæ¯å¹´éƒ½æœ‰è¿™ä¸ªç›®æ ‡ï¼Œæ¯å¹´éƒ½å¾ˆå¤±è´¥ï¼Œå¸Œæœ›å¹´åº•è¿˜æ˜¯èƒ½æŒ‘å‡ºæ»¡æ„çš„ä½œå“ å¹³å®‰å³æ˜¯å–œä¹ï¼ˆæˆ‘ä¸æˆ‘çš„å®¶äººï¼‰ ç”±äºç»éªŒå¤ªå°‘ï¼Œä¸€ç›´è§‰å¾—è¿˜æ²¡æœ‰é€‚åº”ä½œä¸ºresearcherçš„ç”Ÿæ´»ï¼Œå¸Œæœ›èƒ½å½“ä¸Šåˆæ ¼çš„researcher åœ¨å¼‚å›½ä»–ä¹¡æ‰¾åˆ°æ–°ä¹å­ï¼Œåœ¨æ‘é‡Œè¯»åšå¤§æ¦‚æ›´éœ€è¦æ‰¾åˆ°é¢„é˜²Permanent head Damageçš„ç›¼å¤´ï¼ˆæˆ–è®¸å½“ä¸ªä¸šä½™å¨å­ä¸»æ’­å‘¢ï¼‰ ç»™ç‚¹äº”å¹´çš„ç­¾è¯å§ï¼ŒçœŸçš„å¾ˆæƒ³å›å®¶ ä»Šå¹´å¥½è´ªå¿ƒï¼Œè¯´äº†å¥½å¤šæ„¿æœ›ï¼Œèƒ½ä¸èƒ½éƒ½å®ç°å‘¢\n","date":"2023-12-31T01:20:01-05:00","image":"/p/end-of-2023/touhou_hu2343549c5f65690a2931a169d1c97dd0_161087_120x120_fill_q75_box_smart1.jpeg","permalink":"/p/end-of-2023/","title":"End of 2023"},{"content":"èƒŒæ™¯ æˆ‘æ­£åœ¨ç¼–å†™ complishï¼šå¸Œæœ›èƒ½é€šè¿‡ chatGPT æ¥è§£æä»»æ„ CLI çš„ help pageï¼ˆå³ cmd --help åæ‰“å°çš„å†…å®¹ï¼‰ï¼Œä¹‹åç”Ÿæˆå„ä¸ª shell çš„è¡¥å…¨æ–‡ä»¶ï¼Œä»è€Œèƒ½å¤Ÿé€šè¿‡ \u0026lt;TAB\u0026gt; é”®æ¥è·å¾—è¯¥ CLI å‚æ•°çš„å€™é€‰æç¤ºã€‚\n1 2 3 4 5 6 7 âœ— mycmd \u0026lt;TAB\u0026gt; -g -- great! -h -- Print help help -- Print help page(cmd) sub1 -- sub command 1 sub2 -- sub command 2 sub3 -- sub command 3 zsh-completion çš„æœºåˆ¶ç›¸å½“å¤æ‚ï¼Œæ¯” fish å†™èµ·æ¥å›°éš¾ç‰¹åˆ«å¤šï¼Œå› æ­¤åœ¨åšè‡ªåŠ¨ç”Ÿæˆå‰ï¼Œæœ€éš¾çš„æ˜¯æ‰‹åŠ¨å†™ä¸€ä»½æ¨¡æ¿ zsh-completion æ–‡ä»¶ã€‚\nzsh çš„å®˜æ–¹æ–‡æ¡£ä¹Ÿæ˜¯éš¾å¾—ç¦»è°±ï¼Œæ ¹æœ¬ä¸è¯´äººè¯ï¼Œç¤¾åŒºçš„é—®é¢˜ä¹Ÿæ²¡æœ‰ä»€ä¹ˆçƒ­åº¦è€Œä¸”å›ç­”å¹¶ä¸å®ç”¨ï¼Œå› æ­¤åªèƒ½è‡ªå·±ç»“åˆå…¶ä»–æ•™ç¨‹æ£é¼“äº†ã€‚ï¼ˆä»¥åŠé¡¾é—® chatGPTï¼‰\nè¿™ç¯‡æ–‡ç« åªæ¶‰åŠè¯¥æ¶‰åŠçš„å†…å®¹ï¼Œæ— æ³•å®Œå…¨è¦†ç›– zsh-completion çš„åŠŸèƒ½ã€‚\nå®Œæˆç›®æ ‡ è¿™ç¯‡æ–‡ç« çš„ç›®æ ‡æ˜¯ç»™ä¸€ä¸ª zsh ä¸‹çš„ CLI mycmd å†™ä¸€ä»½ zsh-completionï¼Œæ”¯æŒå¤šå±‚çš„ options å’Œ subcommandsï¼Œä¸‹é¢æ˜¯å„å±‚çš„ help pageã€‚ ï¼ˆä»£ç å®Œå…¨ç”± chatGPT ç”Ÿæˆï¼Œè®©å®ƒå¸®æˆ‘ç”¨ clap(Rust) å†™ä¸ª CLIï¼‰\nmycmd 1 2 3 4 5 6 7 8 9 10 11 âœ— mycmd --help Usage: mycmd \u0026lt;COMMAND\u0026gt; Commands: sub1 sub command 1 sub2 sub command 2 help Print this message or the help of the given subcommand(s) Options: -h, --help Print help -V, --version Print version mycmd sub1 1 2 3 4 5 6 7 8 9 10 11 12 âœ— mycmd sub1 -h sub command 1 Usage: mycmd sub1 [COMMAND] Commands: subsub1 this is subsub 1 subsub2 this is subsub 2 help Print this message or the help of the given subcommand(s) Options: -h, --help Print help mycmd sub2 1 2 3 4 5 6 7 8 âœ— mycmd sub2 -h sub command 2 Usage: mycmd sub2 [OPTIONS] Options: --log-level \u0026lt;LOG_LEVEL\u0026gt; log level, debug/info/error -h, --help Print help mycmd sub1 subsub1 1 2 3 4 5 6 7 8 âœ— mycmd sub1 subsub1 -h this is subsub 1 Usage: mycmd sub1 subsub1 --num \u0026lt;NUM\u0026gt; Options: -n, --num \u0026lt;NUM\u0026gt; a number -h, --help Print help mycmd sub1 subsub2 1 2 3 4 5 6 7 8 âœ— mycmd sub1 subsub2 -h this is subsub 2 Usage: mycmd sub1 subsub2 --file \u0026lt;FILE\u0026gt; Options: -f, --file \u0026lt;FILE\u0026gt; path of a file -h, --help Print help ä»åˆ«äººçš„å·¥ä½œå¼€å§‹ æŒ‰åˆ«äººçš„å†™æ³•ï¼Œå¯¹ä¸€ä¸ª mycmd çš„ CLI è¡¥å…¨åº”è¯¥è¿™ä¹ˆå†™ï¼š\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 #compdef _mycmd mycmd function _mycmd { local line _arguments -C \\ \u0026#34;-h[Show help information]\u0026#34; \\ \u0026#34;--h[Show help information]\u0026#34; \\ \u0026#34;1: :(sub1 sub2)\u0026#34; \\ \u0026#34;*::arg:-\u0026gt;args\u0026#34; case $line[1] in sub1) _mycmd_sub1 ;; sub2) _mycmd_sub2 ;; esac } function _mycmd_sub1 { _arguments \\ \u0026#34;--silent[Dont output anything]\u0026#34; } function _mycmd_sub2 { _arguments \\ \u0026#34;--repeat=[Repat the \u0026lt;message\u0026gt; any number of times]\u0026#34; } ä¿è¯åœ¨ zsh çš„ $fpath è·¯å¾„é‡Œæœ‰ä¸€ä¸ª _mycmd çš„æ–‡ä»¶ï¼Œä»¥ #compdef _mycmd mycmd ç‰¹æ®Šæ³¨é‡Šå¼€å¤´ï¼Œzsh completion è¯­æ³•ï¼ˆæ³¨æ„ä¸æ˜¯æ™®é€šçš„ .zsh çš„è¯­æ³•ï¼Œåœ¨æ™®é€šçš„ zsh è„šæœ¬é‡Œæ— æ³•è°ƒç”¨ _arguments å’Œ _values è¿™æ ·çš„å‡½æ•°ï¼‰\nè¿™æ ·åœ¨æ‰§è¡Œ mycmd å¹¶æŒ‰ä¸‹ \u0026lt;TAB\u0026gt; æ—¶å°±ä¼šæ‰§è¡Œåˆ° _mycmd å‡½æ•°ï¼Œä¹‹åæ§åˆ¶æƒå®Œå…¨äº¤ç»™ä½ å†™çš„å‡½æ•°ï¼Œå°±å¯ä»¥å¼€å‘äº†ã€‚\nåœ¨ä¸Šé¢çš„ä¾‹å­ä¸­ï¼Œ$line æ˜¯ä½ åœ¨ terminal çš„ buffer è¾“å…¥çš„å„ä¸ªå‚æ•°ï¼Œcase $line[1] åˆ¤æ–­ç¬¬ä¸€ä¸ªå‚æ•°æ˜¯ä»€ä¹ˆå­—ç¬¦ä¸²ï¼Œåœ¨ä¸Šé¢å¯ä»¥æ˜¯ sub1 æˆ–è€… sub2ï¼Œä¹‹åé€šè¿‡æ‰§è¡Œå„è‡ªçš„å‡½æ•°æ¥æä¾›æœåŠ¡ï¼Œé‡Œé¢è°ƒç”¨çš„ _arguments å³æ˜¯æä¾› options è¡¥å…¨æ”¯æŒçš„å‡½æ•°ã€‚\nåœ¨ _mycmd é‡Œè°ƒç”¨çš„ _arguments ç›¸å½“äºä¸ºå½“å‰è¾“å…¥çš„ mycmd æä¾›å‚æ•°è¡¥å…¨ï¼Œå¦‚æœ -h å’Œ \u0026ndash;help éƒ½æä¾›äº†ç›¸åŒçš„æè¿°ï¼Œåœ¨ zsh-completion é‡Œå°±ä¼šè¢«å¤„ç†æˆåŒä¸€ä¸ªå‚æ•°ã€‚\nè‡³äºä¹‹åä¸¤ä¸ªå¤æ‚çš„é¡¹ï¼š\n1 2 3 _arguments \\ \u0026#34;1: :(sub1 sub2)\u0026#34; \\ \u0026#34;*::arg:-\u0026gt;args\u0026#34; è¡¨ç¤ºç¬¬ä¸€ä¸ªå‚æ•°ä¼šæœ‰ sub1, sub2 ä¸¤ä¸ªå€™é€‰ï¼Œè€Œ * è¡¨ç¤ºåœ¨ä¹‹åçš„å‚æ•°å°†å­˜å…¥ä¸€ä¸ªä¸Šä¸‹æ–‡å˜é‡ $argï¼Œä¹‹åçš„ -\u0026gt;args è¡¨ç¤ºå½“å‰ buffer çš„çŠ¶æ€è§¦åŠåˆ°äº†ç¬¬ä¸€ä¸ªå‚æ•°åçš„å‚æ•°ï¼Œå°†ä¸€ä¸ªå†…ç½®çš„è¡¨ç¤ºçŠ¶æ€å˜é‡ $state èµ‹å€¼ä¸º args å­—ç¬¦ä¸²ã€‚\nçœ‹æ¥è‡ªå¦ä¸€ç¯‡æ–‡ç« çš„å†™æ³•ï¼š\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 _dolt() { local line state _arguments -C \\ \u0026#34;1: :-\u0026gt;cmds\u0026#34; \\ \u0026#34;*::arg:-\u0026gt;args\u0026#34; case \u0026#34;$state\u0026#34; in cmds) _values \u0026#34;dolt command\u0026#34; \\ \u0026#34;init[Create an empty Dolt data repository.]\u0026#34; \\ \u0026#34;table[Commands for copying, renaming, deleting, and exporting tables.]\u0026#34; ;; args) case $line[1] in init) _dolt_init ;; table) _dolt_table ;; esac ;; esac } é‡Œé¢åˆ¤æ–­é€»è¾‘å°±æ˜¯ï¼šå¦‚æœ$state == \u0026quot;args\u0026quot;ï¼Œé‚£ä¹ˆå·²ç»è®¤ä¸º terminal é‡Œè¾“å…¥çš„æ˜¯ mycmd ä»¥åŠå…¶ä»–ä¸€äº›ä»€ä¹ˆå‚æ•°æˆ–è€…å­å‘½ä»¤ï¼Œè€Œä¸æ˜¯å•çº¯çš„ mycmdï¼Œé‚£ä¹ˆ _arguments åœ¨è¿™é‡Œçš„ä½œç”¨å°±æ˜¯å°†å½“å‰ buffer é‡Œè¾“å…¥çš„æ–‡æœ¬å·²ç»åˆ°äº†å“ªä¸ªé˜¶æ®µç¡®å®šä¸‹æ¥ï¼ˆæ˜¯å¦é™¤äº† mycmd è¿˜æœ‰å…¶ä»–å‚æ•°ï¼‰ï¼Œå¦‚æœåªè¾“å…¥äº† mycmd ï¼Œé‚£ä¹ˆ $state == \u0026quot;cmd\u0026quot;ã€‚\nä¹‹åè°ƒç”¨çš„ _dolt_init å’Œ _dolt_table å…¶å®éƒ½æ˜¯è¿™ä¸ª _dolt çš„å¦‚æ³•ç‚®åˆ¶ï¼Œè¯¥ä½œè€…æˆåŠŸè§£å†³äº†å­å‘½ä»¤çš„è¡¥å…¨çš„é—®é¢˜ã€‚\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 _dolt_table() { local line state _arguments -C \\ \u0026#34;1: :-\u0026gt;cmds\u0026#34; \\ \u0026#34;*::arg:-\u0026gt;args\u0026#34; case \u0026#34;$state\u0026#34; in cmds) _values \u0026#34;dolt_table command\u0026#34; \\ \u0026#34;import[Creates, overwrites, replaces, or updates a table from the data in a file.]\u0026#34; ;; args) case $line[1] in import) _dolt_table_import ;; esac ;; esac } ä½†æ˜¯æˆ‘è§‰å¾—è¿™æ ·çš„è„šæœ¬å¹¶ä¸å¥½çœ‹ã€‚åœ¨æˆ‘åœ¨å†™ fish æ”¯æŒçš„æ—¶å€™ï¼Œæˆ‘ç”¨äº†æ¯”è¾ƒçº¿æ€§çš„æ–¹å¼ï¼ŒåŒ¹é…å½“å‰è¾“å…¥çš„ buffer æ˜¯å¦æ»¡è¶³æŸä¸ªâ€å‘½ä»¤é“¾â€œ(command chain)ï¼Œæ¥å¯¹è¯¥é“¾æ¡åšç‰¹å®šçš„è¡¥å…¨æ”¯æŒï¼Œåœ¨ç”Ÿæˆé˜¶æ®µä¼šæ›´åŠ å®¹æ˜“ã€‚é‚£æˆ‘å¸Œæœ› zsh ä¹Ÿèƒ½ç”¨è¿™ç§ cmd_chain çš„æ–¹å¼æ¥å®Œæˆä¸€ä¸ªè¡¥å…¨æ–‡ä»¶ã€‚\ncommand chain in zsh å› ä¸º zsh æ²¡æ³•åƒ fish ä¸€æ ·ï¼Œåœ¨ complete é‡ŒåŠ æ¡ä»¶å»é¡¶çº§åœ°åˆ¤æ–­ cmd chain æ¥å†³å®šæ˜¯å¦ä¸ºåç»­é¡¹ï¼Œå› æ­¤æ€è·¯è¿˜æ˜¯åªèƒ½ç±»ä¼¼ switch è¯­å¥å»åˆ¤æ–­ï¼š\n1 2 3 4 5 6 7 8 9 10 11 case (get_cmd_chain $MY_INPUT) in \u0026#34;cmd\u0026#34;) # do ;; \u0026#34;cmd sub1\u0026#34;) # do ;; \u0026#34;cmd sub1 subsub1\u0026#34;) # do ;; esac get_cmd_chain å…¶å®å°±æ˜¯æŠŠå½“å‰è¾“å…¥çš„å­—ç¬¦ä¸²ï¼Œè½¬æˆå½“å‰å·²ç»ç¡®å®šçš„å‘½ä»¤è°ƒç”¨é“¾ï¼Œä¸å†éœ€è¦æä¾›å…¶ä¹‹å‰çš„å€™é€‰æç¤ºï¼Œå®ç°ï¼š\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 function __get_cmd_chain() { local cmd_chain=() local chain_str=${1} local args=(${(s: :)chain_str}) for arg in $args; do if [[ $arg[1] == \u0026#34;-\u0026#34; ]]; then echo $cmd_chain return fi cmd_chain+=($arg) done # \u0026#34;cmd sub1\u0026#34; should be parsed \u0026#34;cmd\u0026#34; because the command chain may not finish # eg. \u0026#34;cmd su\u0026#34; would not work if it\u0026#39;s parsed to (\u0026#34;cmd\u0026#34; \u0026#34;su\u0026#34;) if [[ $chain_str[-1] == \u0026#34; \u0026#34; ]]; then echo $cmd_chain else echo $cmd_chain[1,-2] fi } ä¸»æ—¨æ˜¯åªä¿ç•™ -o \u0026ndash;options å‰çš„æ‰€æœ‰å‘½ä»¤ï¼Œå¦‚ cmd sub1 --option =\u0026gt; cmd subã€‚\nlocal args=(${(s: :)chain_str}) è¡¨ç¤ºæŠŠå‚æ•°å­—ç¬¦ä¸²åˆ†å‰²ï¼Œå³ JS é‡Œçš„ chain_str.split(' ')ã€‚ æœ€åå‡ è¡Œçš„åˆ¤æ–­ï¼Œå¦‚æœä»¥ç©ºæ ¼ç»“å°¾ï¼Œè¯´æ˜å½“å‰å·²ç»ç»“æŸäº†å‰é¢è¿™ä¸ªå‘½ä»¤çš„è¾“å…¥ï¼Œåˆ™å°†å…¶è§†ä¸º cmd chain çš„ä¸€ç¯ï¼Œå› ä¸ºæœ‰å¯èƒ½è¿™ä¸ªå‘½ä»¤è¾“ä¸€åŠï¼Œæ¯”å¦‚ cmd su å¦‚æœè¢«è§£ææˆ cmd su çš„ cmd chainï¼Œé‚£ä¹ˆæ­¤æ—¶æŒ‰ \u0026lt;TAB\u0026gt; æ— æ³•æä¾›æ­£å¸¸çš„å€™é€‰ã€‚ $cmd_chain[1, -2] è¡¨ç¤ºå»æ‰æœ€åä¸€ä¸ªå…ƒç´  ä¸ºäº†ä¿è¯æœ‰æ•ˆï¼Œè¿™é‡Œå¾ˆé€‚åˆå†™å•å…ƒæµ‹è¯•ï¼š\n1 2 3 4 5 6 7 8 9 10 11 12 13 function should_succ() { local parsed=$(__get_cmd_chain ${1}) if [[ ! $parsed = ${2} ]]; then print -P \u0026#34;%F{red}Fail(should equal):\\n ${1} =\u0026gt; $parsed\\n ${2} %F{reset}\u0026#34; return 1 fi return 0 } should_succ \u0026#34;cmd sub1 subsub1 -f file\u0026#34; \u0026#34;cmd sub1 subsub1\u0026#34; should_succ \u0026#34;cmd sub1 subsub1 -f file\u0026#34; \u0026#34;cmd sub1 subsub1\u0026#34; should_succ \u0026#34;cmd -log \u0026#34; \u0026#34;cmd\u0026#34; should_succ \u0026#34;cmd sub1 sub2 -f\u0026#34; \u0026#34;cmd sub1 sub2\u0026#34; è§£æå®Œä¹‹åå…¶å®å°±å¯ä»¥ switch äº†ï¼Œç›´æ¥å†™ _mycmd å‡½æ•°æœ¬ä½“\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 function _mycmd() { local parsed=$(__get_cmd_chain $BUFFER) case $parsed in \u0026#34;mycmd\u0026#34;) complete_mycmd ;; \u0026#34;mycmd sub1\u0026#34;) complete_mycmd_sub1 ;; \u0026#34;mycmd sub1 subsub1\u0026#34;) complete_mycmd_sub1_subsub1 ;; \u0026#34;mycmd sub1 subsub2\u0026#34;) complete_mycmd_sub1_subsub2 ;; \u0026#34;mycmd sub2\u0026#34;) complete_mycmd_sub2 ;; *) ;; esac } å…¶ä¸­å„ä¸ªå‡½æ•°éƒ½å¾ˆç®€æ˜ï¼Œæ¯ä¸ªçš„å†…å®¹æ— é _arguments æˆ–è€… _valuesï¼Œæ¥è¡¨è¾¾å¯¹å½“å‰ cmd chain çš„è¡¥å…¨æ”¯æŒã€‚ï¼ˆ_arguments -sï¼‰è¡¨ç¤ºå¯ä»¥è¿ç€è¡¥å…¨ï¼Œæ¯”å¦‚ -h å†æŒ‰ \u0026lt;TAB\u0026gt; ä¼šå˜æˆ -hg\n1 2 3 4 5 6 7 8 9 10 11 function complete_mycmd() { _values \\ \u0026#34;cmd command\u0026#34; \\ \u0026#34;sub2[sub command 2]\u0026#34; \\ \u0026#34;sub3[sub command 3]\u0026#34; \\ \u0026#34;sub1[sub command 1]\u0026#34; \\ \u0026#34;help[Print help page(cmd)]\u0026#34; _arguments -s \\ \u0026#34;-h[Print help]\u0026#34; \\ \u0026#34;-g[great!]\u0026#34; \\ } ç„¶åå°±å¼€å§‹è·‘ï¼Œç»“æœå°±å‡ºé”…äº†ï¼šåœ¨ cmd åæŒ‰ä¸‹ \u0026lt;TAB\u0026gt; èƒ½æ­£å¸¸æä¾›æç¤ºï¼Œä½†æ˜¯ cmd sub1 åå´ä¸èƒ½æä¾› options çš„å€™é€‰ï¼Œè€Œåªæœ‰ values ã€‚stackoverflowä¸Šä¹Ÿæœ‰è¿™ä¸ªé—®é¢˜çš„æè¿°ï¼Œç„¶è€Œå¹¶ä¸å¤ªå®ç”¨ã€‚\næ§åˆ¶å˜é‡å‘ç°å…¶å®æ˜¯ _arguments çš„é—®é¢˜ï¼Œ_arguments çš„æ”¯æŒå…¶å®åªèƒ½åœ¨å‡ºç° non-option å‚æ•°ï¼ˆæ¯”å¦‚å­å‘½ä»¤ã€å…¶ä»–å‚æ•°ï¼‰ä¹‹å‰æä¾›ï¼Œå°±æ˜¯è¯´æ— æ³•ä¸ºå­å‘½ä»¤æä¾›å‚æ•°ï¼Œä¸Šé¢ bolt çš„ä½œè€…è§£å†³è¿™ä¸ªé—®é¢˜å…¶å®é çš„å°±æ˜¯\n1 2 3 _arguments -C \\ \u0026#34;1: :-\u0026gt;cmds\u0026#34; \\ \u0026#34;*::arg:-\u0026gt;args\u0026#34; åœ¨è¿™ä¸²è°ƒç”¨é‡Œï¼Œè¾“å…¥çš„ä¸Šä¸‹æ–‡å…¶å®ä¼šè¢«â€åƒæ‰â€œï¼Œè°ƒç”¨ä¹‹åï¼Œç¬¬ä¸€ä¸ªé non-option å‚æ•°ä¼šæ¶ˆå¤±ï¼Œåé¢çš„ä¼šå¾€å‰è¡¥ï¼Œå› æ­¤åˆæˆäº†ç¬¬ä¸€ä¸ªå‚æ•°ï¼Œèƒ½å¤Ÿæä¾› options çš„è¡¥å…¨æ”¯æŒã€‚è¿™ä¸ªå…·ä½“åŸç†ç¡®å®æ²¡ææ˜ç™½ï¼Œä½†æ˜¯çŸ¥é“æ€ä¹ˆè§£å†³é—®é¢˜äº†â€¦â€¦ä»–çš„è§£å†³ä¹Ÿæ˜¯å› ä¸ºæ¯å±‚å‡½æ•°é‡Œéƒ½ä¼šè°ƒç”¨ä¸€éè¿™ä¸²ä»£ç ã€‚\nç„¶è€Œ cmd chain æ˜¯å•å±‚çš„ç»“æ„ï¼Œå› æ­¤éœ€è¦æ‰‹åŠ¨å»ä¸€æ¬¡æ€§æ‰§è¡Œ x æ¬¡è°ƒç”¨ã€‚ï¼ˆæˆ‘å°è¯•è¿‡ä½¿ç”¨ \u0026ldquo;2: :-\u0026gt;cmds2\u0026rdquo; ä¹‹ç±»çš„ï¼Œä½†æ˜¯å¹¶æ²¡æœ‰æ•ˆæœï¼Œä¸å¤ªèƒ½ç†è§£ï¼Œæ‰€ä»¥è¿˜æ˜¯é€‰æ‹©å¤šæ¬¡è°ƒç”¨ç›¸åŒçš„å‚æ•°ï¼‰ã€‚åœ¨ _mycmd() ä¸­ï¼Œè§£æå®Œ $BUFFER ååŠ å…¥æ‰§è¡Œ count - 1 æ¬¡ _arguments çš„ä»£ç ï¼Œæ¥å°† cmd chain æœ€åä¸€ä¸ªå­å‘½ä»¤æ¨åˆ°æœ€å‰é¢ï¼Œä»è€Œèƒ½æ”¯æŒ options çš„è¡¥å…¨ã€‚\n1 2 3 4 5 6 7 8 9 10 local parsed=$(__get_cmd_chain $BUFFER) # \u0026#34;eat\u0026#34; the previous arguments and options so that _arguments can work normally # while there is non-option args before the cursor local count=${#${(z)parsed}} # $count - 1 times for ((i=1; i\u0026lt;$count; i++)); do _arguments -C \\ \u0026#34;1: :-\u0026gt;cmds\u0026#34; \\ \u0026#34;*::arg:-\u0026gt;args\u0026#34; done è¿™æ ·å°±èƒ½æ­£å¸¸å·¥ä½œäº†ï¼\nåªè¦çŸ¥é“äº†æ•´ä¸ª help page çš„ treeï¼Œé‚£ä¹ˆç”Ÿæˆè¿™æ ·çš„æ–‡ä»¶å°±æ˜¯ä¸€ä¸ªçº¿æ€§çš„å·¥ä½œï¼Œç”Ÿæˆå‡ºæ¥å¯è¯»æ€§ä¹Ÿé«˜ã€‚\nç»“è®º zsh completion é€šè¿‡ _arguments å’Œ _values å‡½æ•°æä¾›å€™é€‰æ”¯æŒ _arguments åªèƒ½åœ¨æ²¡æœ‰ non-option å‚æ•°çš„ç¯å¢ƒä¸‹å·¥ä½œï¼Œéœ€è¦é€šè¿‡ç‰¹æ®Šå¤„ç†æ¥â€åƒæ‰â€œä¹‹å‰çš„å‚æ•°ä½¿å¾—æ”¯æŒå­å‘½ä»¤ zsh çš„æ–‡æ¡£ä¸æ˜¯äººè¯»çš„ï¼Œå¸Œæœ›èƒ½è¢« fish å–ä»£ XDï¼Œæ²¡æœ‰ç”¨è¿‡çš„å»ºè®®è¯•è¯• fish shell complish çš„æœ¬æ„åªæ˜¯æ”¯æŒ fishï¼Œä½†åæ¥è§‰å¾—æˆ‘ç¡®å®æŒºå–œæ¬¢è¿™ä¸ªå·¥å…·ï¼Œå¸Œæœ›èƒ½æ¨å¹¿åˆ° bash å’Œ zshï¼Œbash çš„ completion è¿˜éœ€è¦å†ç ”ç©¶ï¼Œä¸è¿‡å’Œ zsh æ˜¯åŒä¸€å¥—è¯­æ³•æˆ‘çŒœåº”è¯¥ä¸ä¼šæ›´éš¾äº†ã€‚ æœ€åçš„ _mycmd æ–‡ä»¶ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 #compdef _mycmd mycmd function __get_cmd_chain() { local cmd_chain=() local chain_str=${1} local args=(${(s: :)chain_str}) for arg in $args; do if [[ $arg[1] == \u0026#34;-\u0026#34; ]]; then echo $cmd_chain return fi cmd_chain+=($arg) done # \u0026#34;cmd sub1\u0026#34; should be parsed \u0026#34;cmd\u0026#34; because the command chain may not finish # eg. \u0026#34;cmd su\u0026#34; would not work if it\u0026#39;s parsed to (\u0026#34;cmd\u0026#34; \u0026#34;su\u0026#34;) if [[ $chain_str[-1] == \u0026#34; \u0026#34; ]]; then echo $cmd_chain else echo $cmd_chain[1,-2] fi } function _mycmd() { local parsed=$(__get_cmd_chain $BUFFER) # print -P \u0026#34;%F{red} \\n $parsed \\n%F{reset}\u0026#34; # \u0026#34;eat\u0026#34; the previous arguments and options so that _arguments can work normally # while there is non-option args before the cursor local count=${#${(z)parsed}} # $count - 1 times for ((i=1; i\u0026lt;$count; i++)); do _arguments -C \\ \u0026#34;1: :-\u0026gt;cmds\u0026#34; \\ \u0026#34;*::arg:-\u0026gt;args\u0026#34; done case $parsed in \u0026#34;mycmd\u0026#34;) complete_mycmd ;; \u0026#34;mycmd sub1\u0026#34;) complete_mycmd_sub1 ;; \u0026#34;mycmd sub1 subsub1\u0026#34;) complete_mycmd_sub1_subsub1 ;; \u0026#34;mycmd sub1 subsub2\u0026#34;) complete_mycmd_sub1_subsub2 ;; \u0026#34;mycmd sub2\u0026#34;) complete_mycmd_sub2 ;; *) ;; esac } function complete_mycmd() { _values \\ \u0026#34;cmd command\u0026#34; \\ \u0026#34;sub2[sub command 2]\u0026#34; \\ \u0026#34;sub3[sub command 3]\u0026#34; \\ \u0026#34;sub1[sub command 1]\u0026#34; \\ \u0026#34;help[Print help page(cmd)]\u0026#34; _arguments -s \\ \u0026#34;-h[Print help]\u0026#34; \\ \u0026#34;-g[great!]\u0026#34; \\ } function complete_mycmd_sub1() { _values \\ \u0026#34;sub1 subcommand\u0026#34; \\ \u0026#34;subsub1[subsub command 1]\u0026#34; \\ \u0026#34;subsub2[subsub command 2]\u0026#34; \\ \u0026#34;help[Print help page(cmd)]\u0026#34; _arguments -s \\ \u0026#34;-h[Print help]\u0026#34; \\ \u0026#34;-g[great!!!]\u0026#34; \\ } function complete_mycmd_sub2() { _arguments -s \\ \u0026#34;--log-level[log level, debug/info/error]\u0026#34; \\ \u0026#34;-h[Print help for sub2]\u0026#34; \\ \u0026#34;--help[Print help for sub2]\u0026#34; } function complete_mycmd_sub1_subsub1() { _arguments -s \\ \u0026#34;-n[a number]\u0026#34; \\ \u0026#34;--num[a number]\u0026#34; \\ \u0026#34;-h[Print help]\u0026#34; } function complete_mycmd_sub1_subsub2() { _arguments -s \\ \u0026#34;-f[path of a file]\u0026#34; \\ \u0026#34;--file[path of a file]\u0026#34; \\ \u0026#34;-h[Print help]\u0026#34; } å‚è€ƒ https://www.dolthub.com/blog/2021-11-15-zsh-completions-with-subcommands/ ç»™æˆ‘å¸®åŠ©æœ€å¤šçš„æ•™ç¨‹ï¼Œæ ‘çŠ¶åœ°è§£å†³äº†è¿™ä¸ªé—®é¢˜ï¼Œä½†æ˜¯æˆ‘è§‰å¾—ä¸å¥½ç”Ÿæˆï¼Œå› æ­¤åšäº†æ”¹è¿› https://blog.mads-hartmann.com/2017/08/06/writing-zsh-completion-scripts.html https://tylerthrailkill.com/2019-01-13/writing-zsh-completion-scripts/ https://github.com/zsh-users/zsh-completions/blob/master/zsh-completions-howto.org#intro ","date":"2023-03-21T14:21:18+08:00","image":"/p/write-zsh-completions-for-cli/cover_hu910981dd125385da1f7c837c3da6b847_228397_120x120_fill_box_smart1_3.png","permalink":"/p/write-zsh-completions-for-cli/","title":"Write zsh completions for CLI"},{"content":"åº”è¯¥æ˜¯æˆ‘è‡³ä»Šäº²çœ¼æ‰€è§çš„å®è§‚ç¯å¢ƒæœ€ç³Ÿç³•çš„ä¸€å¹´ï¼Œäº’è”ç½‘çš„ç»ˆç‚¹ã€å±‚å‡ºä¸ç©·çš„å€’è½¦ã€æ— æ•Œçš„ COVID-19ã€‚\nå…³äºå†…å·ç„¦è™‘ è™½ç„¶å»å¹´å¹´åº•å°±å·²ç»è‡ªç§°è®¤æ¸…è‡ªå·±éå¸¸å¹³åº¸çš„ç°å®ï¼Œä½†ä»Šå¹´ä¾ç„¶é™·å…¥äº†æŒç»­çš„å†…å·ç„¦è™‘å½“ä¸­ï¼Œæ›¾ç»ç”¨â€œåªæ˜¯æ²¡æ‰¾åˆ°å–œæ¬¢çš„æ–¹å‘è€Œä¸æ˜¯è‡ªå·±èœâ€æ¥å¿½æ‚ è‡ªå·±ï¼Œå‡å°‘å¤§å­¦è¿‡å¾—ç¢Œç¢Œæ— ä¸ºã€æ²¡æœ‰å»ºæ ‘çš„è´Ÿç½ªæ„Ÿï¼Œä½†æ„ˆå‘å¯Ÿè§‰å…¶å®å°±æ˜¯å› ä¸ºè‡ªå·±æ°´å¹³å·®ï¼Œæœ‰ä¸€ç§åˆ›é€ åŠ›å’Œæ³¨æ„åŠ›éƒ½åœ¨é€æ¸æ¶ˆæ•£çš„æ— åŠ›æ„Ÿã€‚\nåº”è¯¥è¯´å¤§ä¸‰æ˜¯å¾ˆå¤šæœ‹å‹ä»è¾“å…¥è½¬å˜ä¸ºè¾“å‡ºçš„é˜¶æ®µï¼Œæˆ‘çœ‹åˆ°å¾ˆå¤šä¼˜ç§€çš„äººå³ä½¿ä¸æ‰“ç®—ä»äº‹è‡ªå·±å¤§å­¦ä¸“ä¸šçš„å·¥ä½œï¼Œåœ¨è‡ªå·±ä¸“ä¸šä¸Šä¾ç„¶èƒ½è¡¨ç°å¾—éå¸¸ä¼˜ç§€ï¼Œå¯¹æˆ‘æ¥è¯´è¿™å°±åƒæ˜¯ä¸€ç§å­¦ä¹ åŠ›çš„ç¢¾å‹ï¼Œè¦è¯´ä¸ç¾¡æ…•é‚£1000%æ˜¯éª—äººçš„ï¼Œæˆ‘ç¥ç¦ä»–ä»¬å‰é€”é¡ºåˆ©ï¼Œå´æ— è®ºå¦‚ä½•éƒ½éš¾ä»¥ç¥ç¦è‡ªå·±ï¼Œå› ä¸ºå‘ç°è‡ªå·±å°±æ˜¯æ²¡æœ‰é‚£ä¹ˆå‰å®³ï¼Œè€Œä¸”æ´»åœ¨â€œæˆ‘å¾ˆå‰å®³â€çš„é¢„æƒ³ä¸­ã€‚\næˆ‘çŸ¥é“æ´»åœ¨è¿™ä¸ªä¸–ç•Œä¸Šä¸éœ€è¦é‚£ä¹ˆä¼˜ç§€ä¹Ÿå¯ä»¥æ´»å¾—å¾ˆå¿«ä¹ï¼Œä¸ç”¨å½“å„ç§æ¯”èµ›ã€å¥–ç‰Œæ”¶å‰²æœºä¹Ÿèƒ½æ‰¾åˆ°ä½“é¢çš„å·¥ä½œï¼Œç„¶è€Œéš¾ä»¥è¯´æœæˆ‘å»æ”¾å¼ƒæ¯”åˆ«äººå‰å®³çš„å¹»æƒ³ã€‚\næ˜å¹´çš„æˆ‘èƒ½ä¸èƒ½çœŸæ­£åœ°æ”¾ä¸‹èº«æ®µï¼Œèµ°è·Ÿè‡ªå·±æ¯”è¾ƒçš„é“è·¯å‘¢ï¼Ÿ\nå…³äºæ¶¦ æˆ‘å¤§æ¦‚å°±æ˜¯åˆšå¥½ä¸€å¹´å‰å¼€å§‹å‡†å¤‡é›…æ€ï¼Œå½“åˆçš„è®¾æƒ³å°±æ˜¯å» HK è¯»ä¸ªæ°´ç¡•ï¼Œé€Ÿé€šä¸€ä¸ª master å­¦ä½ï¼Œæœ€åä¹Ÿå‡ ä¹ä¸ä¼šå¤±è´¥åœ°æ‹¿åˆ°äº† offerï¼Œå¯æ˜¯æ— è®ºå¦‚ä½•å´é«˜å…´ä¸èµ·æ¥ï¼Œå¯èƒ½å› ä¸ºå¾—åˆ°æ²¡æœ‰éš¾åº¦çš„ä¸œè¥¿å¹¶ä¸ä¼šå¸¦æ¥å¿«æ„Ÿå§ã€‚\nç”³è¯·å­£èŠ±äº†å‡ å‘¨æ—¶é—´è®¤çœŸæ€è€ƒäº†æ¶¦è¿™ä¸€ä»¶äº‹ï¼Œå¯¹ç”³è¯·æ¬§é™†å­¦æ ¡ä¹Ÿåšäº†ä¸€äº›è°ƒç ”ï¼Œåœ¨ç–¯ç‹‚æ‘‡æ‘†ä¹‹é—´é€‰æ‹©äº†ä¸ç”³ï¼Œè§‰å¾—è‡ªå·±ç»ˆç©¶ä¸æ˜¯å½“æ¬§æ´²äººçš„æ–™ï¼Œå¯¹æ¬§æ´²çš„å°è±¡çº¯ç²¹åªæœ‰äº‘è§‚å…‰å®¢æ°´å¹³ï¼Œæ²¡æœ‰çˆ±å¥½äº¤é›†æˆ‘æƒ³åº”è¯¥ä¸å¯èƒ½èå…¥ä»–ä»¬çš„ç¤¾ä¼šï¼ˆäººè¯ï¼šå½“ç°å……ï¼‰ï¼Œæˆ–è®¸å»æ—¥æœ¬è¿˜èƒ½æ´»å¾—æ›´è‡ªåœ¨ï¼Œç„¶è€Œè‡ªå·±åˆå«Œå¼ƒæ—¥æœ¬çš„è€åŒ–ã€‚å…¶æ¬¡å°±æ˜¯ä»–ä»¬ IT å‘å±•æ°´å¹³å±å®ä¸€èˆ¬ï¼Œèµšä¸äº†é’±ã€‚\næˆ‘è§‰å¾—ä¸€ä¸ªç¾¤å‹è¯´å¾—å¾ˆæœ‰é“ç†ï¼Œä½ è¿˜åœ¨æ‘‡æ‘†æ¶¦ä¸æ¶¦æ˜¯å› ä¸ºä½ å°±æ˜¯å½“å‰ä½“åˆ¶çš„å—ç›Šè€…ã€‚\næ²¡æœ‰è¶³å¤Ÿå¤§çš„å‹è¿«åŠ›ç¡®å®éš¾ä»¥è®©æˆ‘æœ‰é€ƒå‡ºå›½é—¨çš„æƒ³æ³•ï¼Œæ ¹æ·±è’‚å›ºçš„ä¸œäºšæ–‡åŒ–åœˆå·²ç»åˆ»å…¥ DNA äº†ã€‚åœ¨ä¸€äº©ä¸‰åˆ†åœ°çœ‹ä¸–ç•Œå…¬æ°‘çš„æ—¶å€™ï¼Œæ³¨æ„åˆ°äº†å…¶å®å¤§å®¶å¹¶ä¸æ€ä¹ˆå…³å¿ƒæ”¿æ²»ï¼Œä¸ç®¡æ˜¯ç§»æ°‘è¿˜æ˜¯å›å›½ï¼Œè€ƒè™‘çš„å¤§å¤šæ˜¯è‡ªå·±çš„å‘å±•ï¼Œå‡ ä¹å°±æ²¡æœ‰è§åˆ°å› ä¸ºè®¨åŒé˜¿ç†Š/å‘å¾€è‡ªç”±è€Œå†³å®šè·‘è·¯çš„ï¼ˆè§åˆ°çš„éƒ½æ˜¯è¿˜æ²¡è·‘çš„ï¼ˆç¬‘ï¼‰ï¼‰ï¼Œæ„Ÿè§‰è¿™æ˜¯ä¸ªéœ€è¦æ¯•ä¸šåå½“äº†ç¤¾ç•œæ‰èƒ½ç†è§£çš„ä¸»é¢˜ï¼Œçš‡å¸æ˜¯è°ä¸é‡è¦ã€‚\nä¸çŸ¥é“æ„ˆæ¼”æ„ˆçƒˆçš„å€’è½¦ä»€ä¹ˆæ—¶å€™ä¼šæœ‰è¶³å¤Ÿå¤§çš„å‹åŠ›è®©äººçœŸçš„ä¸è·‘ä¸è¡Œå‘¢\nå…³äºå·¥ä½œ ä»Šå¹´èŠ±äº†åŠå¹´å¤šçš„æ—¶é—´åœ¨å®ä¹ ä¸Šï¼Œæˆ‘åœ¨æ­£æœˆåˆä¸ƒå°±å»äº†æ·±åœ³ï¼Œä½†æ˜¯å› ä¸ºæµç¨‹å¡ä½äº†çš„åŸå› ç›´åˆ°å¾…äº†ä¸€ä¸ªæœˆæ‰æˆåŠŸå…¥èŒï¼Œä¸åˆ°ä¸¤ä¸ªæœˆå†…åˆæ¥åˆ°äº† HR è¯´å¾®ä¿¡å†»ç»“æ ¡æ‹›çš„ç”µè¯ï¼Œæˆäº†ç»„é‡Œç¬¬ä¸€ä¸ªæ¯•ä¸šçš„äººã€‚åœ¨æ·±åœ³å•ç¨‹é€šå‹¤ 1h çš„æ—¥å­æ˜¯ä¸å¥½å—çš„ï¼Œæ„Ÿè§‰æ¯å¤©çš„ç”Ÿæ´»å¾ˆå•è°ƒï¼Œå¥½å¤„æ˜¯æˆ¿å­ç¡®å®ä¸è´µï¼Œ2k4 ä»¥å†…åŒ…æ°´ç”µè§£å†³ï¼Œå¯æƒœæ˜¯å…¬å¯“å•é—´ï¼Œå’ŒåŒå­¦æ²¡æœ‰æ‰¾åˆ°ç†æƒ³çš„çŸ­ç§Ÿæˆ¿ã€‚\nä¹‹åä¸ƒæœˆå»äº†ä¸Šæµ·å®ä¹ ï¼Œæˆ‘åŸæœ¬æœŸå¾…çš„äºŒæ¬¡å…ƒç››å…¸ï¼ˆCPã€æ–¹èˆŸéŸ³ä¹ä¼šï¼‰ä¸€ä¸ªéƒ½æ²¡æœ‰ï¼ŒæŒºä»¤äººå¤±è½çš„ï¼Œä½†æ˜¯å±…ä½ä½“éªŒå´æ˜¯ç›¸å½“ä¸é”™ï¼Œæœ‰ç”Ÿæ´»çˆ±å¥½äº¤é›†å¾ˆå¤§çš„å®¤å‹ï¼Œè¿˜æœ‰æ¥¼ä¸‹ç¹åçš„ç”Ÿæ´»ä¾›åº”ï¼Œè®©æˆ‘è§‰å¾—â€œç¤¾ä¼šæ€§çš„äººç±»å°±åº”è¯¥è¿™æ ·ç”Ÿæ´»â€çš„æ„Ÿè§‰ã€‚è¿™ç§å…¬å¯“å¼å»ºç­‘å¯¹å¹´è½»äººæ¥è¯´ï¼ŒçœŸçš„æ¯”å®‰å…¨ç³»æ•°é«˜çš„å°åŒºç”Ÿæ´»è´¨é‡é«˜ä¸å°‘ï¼Œä¸»è¦æ˜¯æœ‰å¤Ÿå¤šå¤Ÿå¯†é›†çš„å±…æ°‘æ¥æ’‘èµ·å•†ä¸šï¼Œå¦‚æœæ¯•ä¸šåæœ‰æœºä¼šï¼Œè¿˜æ˜¯å¸Œæœ›èƒ½æœ‰ç†Ÿäººæœ‹å‹åˆç§Ÿ+ä½å•†ä¸šç¹åçš„å±…æ°‘æ¥¼ã€‚\nä»Šå¹´ä¹Ÿåœ¨ä¸æ–­åœ°åŒå¼€ä¸­è¿›è¡Œï¼Œåœ¨æ·±åœ³å®ä¹ çš„åŒæ—¶åº”ä»˜å­¦æ ¡ï¼Œåœ¨ä¸Šæµ·å®ä¹ çš„åŒæ—¶å‚åŠ  rCore å¤ä»¤è¥ï¼Œæˆ‘å¥½åƒå¾ˆçƒ­è¡·äºè®©è‡ªå·±å˜å¾—å¾ˆå¿™ï¼Œä»£ä»·æ˜¯æˆ‘å¤±å»äº†å¾ˆå¤šè‡ªç”±æ—¶é—´ã€‚\nè¯´ç‚¹å¥½çš„ ä»Šå¹´ç”±ä¸€æ¬¡å¾ˆéš¾å¿˜çš„æ—…è¡Œå¼€ç¯‡ï¼Œç¬¬ä¸€æ¬¡åœ¨å†¬å¤©å‰å¾€åŒ—æ–¹ï¼Œè€Œä¸”è¿˜æ˜¯è¥¿åŒ—å¤§è’æ¼ ã€‚\nè·Ÿè¿œå¾çš„æœ‹å‹æ¨ªç©¿äº†è…¾æ ¼é‡Œæ²™æ¼ ï¼Œç¬¬ä¸€æ¬¡è§åˆ°é‚£ä¹ˆæ¼‚äº®çš„è‡ªç„¶æ™¯è§‚ï¼Œç»™è¿™ä¸ªå¹¿ä¸œäººå¤§å¼€çœ¼ç•Œäº†ã€‚\nå¯æƒœè¿™ä¸ªå†¬å¤©å› ä¸ºæ”¾å¼€äº†è€Œæå‰å›å®¶æ²¡æœ‰åŠæ³•å†å‚åŠ ä¸€æ¬¡æ´»åŠ¨ã€‚\nè¯´ç‚¹æœªæ¥ æˆ‘åœ¨å¤§å­¦å¾ˆå°‘æç¬”ç”»ç”»ï¼Œä½†è„‘å­é‡Œå´ä»æ¥æ²¡æœ‰æ”¾ä¸‹è¿‡è¿™ä¸ªæŠ€èƒ½ï¼Œå¹»æƒ³ç€å“ªå¤©èƒ½é‡æ‹¾ï¼Œæ¯å¤©ç–²äºåŒå¼€çš„æˆ‘è‡ªç„¶å¾ˆå°‘æœ‰è¿™ç§ç²¾åŠ›äº†ï¼Œå¸Œæœ›ä¼‘é—²çš„å¤§å››èƒ½ç»™æˆ‘è¿™ä¸ªæœºä¼šï¼Œç›®æ ‡æ˜¯ 23 å¹´åº•èƒ½å‘ #2022å¹´è‡ªåˆ†ãŒé¸ã¶ä»Šå¹´ã®4æš çš„ tagã€‚\nå¸Œæœ› 23 å¹´èƒ½è¿‡ N1ï¼Œä»å¤§ä¸€å¼€å§‹æŠ¥ N2ï¼Œç›´åˆ°å¤§å››éƒ½æ²¡èƒ½å¤Ÿè¿›å…¥è€ƒåœºï¼Œä»¤äººæ„Ÿæ…¨ã€‚\nå¸Œæœ› 23 å¹´èƒ½åšå‡ºå¥½ç©åˆæœ‰å®é™…ç”¨å¤„çš„äº§å“ã€‚\nå¸Œæœ› 23 å¹´ä¸ä¼šé‚£ä¹ˆç„¦è™‘äº†ï¼Œå¤šè·Ÿè‡ªå·±æ¯”è¾ƒã€‚\n","date":"2022-12-31T20:29:34+08:00","image":"/p/%E5%86%99%E5%9C%A82022%E5%B9%B4%E6%9C%AB/20221231225829_hu42dac3001980353f2005382bccb3c8c2_1201779_120x120_fill_box_smart1_3.png","permalink":"/p/%E5%86%99%E5%9C%A82022%E5%B9%B4%E6%9C%AB/","title":"å†™åœ¨2022å¹´æœ«"},{"content":"Iterative Algorithm ä»æ›´æŠ½è±¡çš„è§’åº¦æ¥å®¡è§†æˆ‘ä»¬çš„è¿­ä»£ç®—æ³•ï¼Œæ¯ä¸ªå—ï¼ˆCFG é‡Œçš„èŠ‚ç‚¹ï¼‰éƒ½ä¼šæœ‰çŠ¶æ€ï¼Œé‚£ä¹ˆæ•´ä¸ªç¨‹åºé‡Œæ‰€æœ‰å—èƒ½ç»„æˆä¸€ä¸ª k ç»´å‘é‡ã€‚\nè¿­ä»£æ¯ä¸ªèŠ‚ç‚¹çš„æ—¶å€™å…¶å®å°±æ˜¯å¯¹ Block ä½œå‡½æ•°è½¬æ¢ã€‚\næˆ‘ä»¬è¿­ä»£çš„åœæ­¢æ¡ä»¶æ˜¯ã€ä¸€æ¬¡è¿­ä»£å tuple æ²¡å˜ã€‘ï¼Œå…¶å®å°±åˆ°è¾¾äº†ä¸åŠ¨ç‚¹\nä¸åŠ¨ç‚¹ï¼š\næ•°å­¦ä¸Šä¸åŠ¨ç‚¹çš„å®šä¹‰ï¼š $$ X = F(X) $$\nä¸ºä»€ä¹ˆæ ‡é¢˜å« foundationï¼šdomain å¹¶ä¸æ­¢ä¹‹å‰å­¦çš„ä¸‰ç§ï¼Œæˆ‘ä»¬å¯ä»¥åˆ†ææ›´å¤šçš„ä»£ç æ€§è´¨\nä¸‰ä¸ªé—®é¢˜ï¼Œåé¢ä¼šå¾—åˆ°è§£å†³ï¼š\niter algo ä¸€å®šèƒ½æ‰¾åˆ°ä¸åŠ¨ç‚¹å—ï¼Ÿï¼ˆç®—æ³•ä¸€å®šä¼šåœä¸‹å—ï¼Ÿï¼‰\næˆ‘ä»¬é’ˆå¯¹å‰é¢ä¸‰ç§ domain åˆ†æè¿‡ï¼Œä¼šåœ ä½†æ˜¯è¿™æ˜¯ä¸€ä¸ªæ™®éçš„ç»“è®ºå—ï¼Ÿå¯¹å…¶ä»–çš„ domain å‘¢ å¦‚æœä¸€å®šèƒ½åœï¼Œä¸€å®šæœ‰å”¯ä¸€çš„ä¸åŠ¨ç‚¹å—ï¼Ÿ\nä»€ä¹ˆæ—¶å€™èƒ½åˆ°è¾¾ä¸åŠ¨ç‚¹ï¼Ÿ\nPartial Order (ååº) poset ååºé›†\næ»¡è¶³ä¸‹é¢ä¸‰ä¸ªè¦æ±‚çš„å°±æ˜¯åˆæ³•çš„ååºå…³ç³»\nè‡ªå reflexivity\nåå¯¹ç§° antisymmetry\nä¼ é€’ transitivity\nä¾‹å­1ï¼š\n( integer, \u0026lt;= ) æ˜¯ä¸æ˜¯ååºé›†ï¼Ÿ\næ€§è´¨éƒ½æ»¡è¶³ï¼Œæ˜¯ ä¾‹å­2ï¼š\n( integer, \u0026lt; ) æ˜¯ä¸æ˜¯ååºé›†ï¼Ÿ\nä¸æ»¡è¶³è‡ªåï¼Œä¸æ˜¯ ä¸ºä»€ä¹ˆå«ååºï¼Ÿä¸æ˜¯å…¨éƒ¨å…ƒç´ éƒ½èƒ½æ¯”è¾ƒ\nï¼ˆéœ€è¦è®°ä½è¿™ä¸ªå›¾ï¼Œ\u0026lt;abc, åŒ…å«å…³ç³»\u0026gt; ç»„æˆçš„å…¨æ ¼ï¼‰\nUpper \u0026amp; Lower Bounds ï¼ˆä¸Šä¸‹ç•Œï¼‰ x ä¸ä¸€å®šåœ¨ S é‡Œ æœ€å°ä¸Šç•Œ lub =\u0026gt; join æœ€å¤§ä¸‹ç•Œ glb =\u0026gt; meet ä¸æ˜¯æ‰€æœ‰ååºé›†éƒ½æœ‰ lub æˆ–è€… glb å¦‚æœ poset æœ‰ lub æˆ–è€… glbï¼Œé‚£ä¹ˆ lub å’Œ glb ä¸€å®šæ˜¯å”¯ä¸€çš„ï¼ˆç”¨åå¯¹ç§°æ€§å¾ˆå®¹æ˜“è¯æ˜ï¼šäº’ç›¸å¯¹åŒä¸€ä¸ªå…³ç³»æˆç«‹å°±ä¸€å®šæ˜¯åŒä¸€ä¸ªï¼‰ Latticeï¼ˆæ ¼ï¼‰ poset ä¸­æ¯ä¸€å¯¹å…ƒç´ éƒ½å­˜åœ¨æœ€å¤§ä¸‹ç•Œå’Œæœ€å°ä¸Šç•Œï¼ˆå¤§ç™½è¯ï¼šä¸¤ä¸ªå…ƒç´ éƒ½ä¼š meet (âˆ©) å’Œ join (âˆª) ï¼‰\n(integer, \u0026lt;=) æ˜¯ä¸æ˜¯ latticeï¼Ÿ æ˜¯ï¼Œä»»æ„ä¸¤ä¸ªæ•°å¯ä»¥ meet å’Œ join Semilatticeï¼ˆåŠæ ¼ï¼‰ P é‡Œä»»æ„ä¸¤ä¸ªå…ƒç´ éƒ½æœ‰ lub å’Œ glbï¼Œå°±æ˜¯åŠæ ¼ Complete Latticeï¼ˆå…¨æ ¼ï¼‰ ä»»æ„ P çš„å­é›†éƒ½ä¼šæœ‰ lub å’Œ glb å°±æ˜¯å…¨æ ¼ (integer, \u0026lt;=) æ˜¯ä¸æ˜¯ compete latticeï¼Ÿ å¦ï¼Œæ•´æ•°é›†ä¸ç¬¦åˆï¼ˆæ‰¾ä¸åˆ°æœ€å°çš„ä¸Šç•Œ/æœ€å¤§çš„ä¸‹ç•Œï¼‰ æ¯ä¸ªæœ‰ç©·çš„æ ¼ä¸€å®šæ˜¯å®Œå…¨æ ¼ åå‘½é¢˜ä¸ºä¼ªï¼š{ [0,1]å°æ•°é›†, \u0026lt; } å®Œå…¨ä¸”æ— ç©·ï¼šä»»æ„å­é›†éƒ½èƒ½æ‰¾åˆ°ä¸€ä¸ªä¸Šä¸‹é™ Product Lattice æ¯ä¸ª L éƒ½æ˜¯ completeï¼Œé‚£ä¹ˆç»„æˆçš„ product lattice $L^n$ ä¹Ÿæ˜¯ complete çš„ Data Flow Analysis Framework via Lattice å…¶å®æ˜¯ semiï¼Œä½†æ˜¯ç”¨ lattice æ¥è¡¨ç¤ºæ›´åŠ æ–¹ä¾¿\nå®šä¹‰ä¸€ä¸ª Data flow analysis çš„æ¡†æ¶ï¼šç”± \u0026lt;æ–¹å‘ã€æ ¼ã€è½¬æ¢å‡½æ•°\u0026gt; ç»„æˆ\nä¾‹å­ï¼š\né¡ºåºæ˜¯åè¿‡æ¥çš„ï¼ˆ Block çš„æ‰§è¡Œæµè·Ÿæ ¼çš„æ–¹å‘ï¼‰ {a, b, c} ç”¨ bit vector è¡¨ç¤ºå°±æ˜¯ 111, {} å°±æ˜¯ 000 Data flow analysis çš„æœ¬è´¨ï¼šåœ¨ä¸€ä¸ªæ ¼ä¸Šè¿­ä»£ä¸€ä¸ª transferã€å¹¶ä¸æ–­ meet å’Œ join\nå›ç­”å‰é¢çš„é—®é¢˜ï¼š\nè¿­ä»£ç®—æ³•ä¸€å®šèƒ½è¾¾åˆ°ä¸åŠ¨ç‚¹å— OUT never shrinks (monotonicity) å¦‚æœèƒ½ï¼Œå¯èƒ½æœ‰å¤šä¸ªä¸åŠ¨ç‚¹å— å¯ä»¥ å¦‚æœæœ‰å¤šä¸ªä¸åŠ¨ç‚¹ï¼Œèƒ½ä¸èƒ½æ‰¾åˆ°æœ€å¥½çš„ï¼ˆè¿­ä»£æ¬¡æ•°æœ€å°‘ï¼‰ å¯ä»¥ Monotonicity ä¸åŠ¨ç‚¹å®šç†\nå…¨æ ¼ã€å•è°ƒã€æœ‰é™ =\u0026gt; å°±èƒ½è¿­ä»£å‡ºæœ€ä¼˜çš„ä¸åŠ¨ç‚¹ complete ä¸ä¸€å®š finite æ±‚è¯:\nå­˜åœ¨ä¸åŠ¨ç‚¹ è¿­ä»£å¾—åˆ°çš„ä¸åŠ¨ç‚¹æœ€å° è¯æ˜ï¼š\nfixed point exists least fixed point æ•°å­¦å½’çº³æ³•: å‡è®¾ k æˆç«‹ + è¯æ˜åˆå§‹æˆç«‹ =\u0026gt; è¯æ˜ k + 1 æˆç«‹ =\u0026gt; å®šç†æˆç«‹\nè¯å‡ºæ¥æ˜¯ unique fixed point\nRelative between Iter Algo \u0026amp; Fixed Point Theorem è¿­ä»£ç®—æ³•èƒ½ä¸èƒ½å…³è”ä¸Šä¸åŠ¨ç‚¹å®šç†ï¼Ÿèƒ½å…³è”ä¸Šæ‰èƒ½è¯´è¿™ä¸ªè¿­ä»£ç®—æ³•èƒ½æ‰¾åˆ°æœ€ä¼˜çš„ä¸åŠ¨ç‚¹ã€‚\nç›´è§‰ä¸Šçš„è¯æ˜ï¼š\nå•è°ƒï¼šOUT ä¸ä¼š shrink (gen - kill å•è°ƒ) æœ‰é™ï¼šå¾ˆæ˜¾ç„¶ï¼Œé›†åˆæ˜¯æœ‰é™çš„ï¼Œé›†åˆçš„æœ‰é™æ¬¡å¹‚ä¹Ÿæ˜¯ å¤šå°‘æ¬¡è¿­ä»£èƒ½åˆ°è¾¾ä¸åŠ¨ç‚¹ï¼Ÿ\næœ€åæƒ…å†µ k ä¸ªå— (nodes in CFGï¼Œåœ¨ example çš„è§†è§’å°±æ˜¯ä¸€ä¸ªæ¯”ç‰¹)ã€é«˜åº¦ hï¼Œæœ€åæƒ…å†µæ˜¯ i = h * k æ¬¡è¿­ä»£ May and Must Analysis, a Lattice View May åœ¨ Reaching Definition Analysis é‡Œï¼Œ1 æ˜¯èƒ½ reachï¼Œ0 æ˜¯ä¸èƒ½ reachï¼Œå³åœ¨ç¨‹åºç»ˆç‚¹è¿™ä¸ªåœ°æ–¹ï¼Œæœ‰å“ªäº›å®šä¹‰æ˜¯å¯èƒ½è¢«ç”¨åˆ°çš„ã€‚\næˆ‘ä»¬ä»ç©ºé›†å»æ‰¾ï¼Œå°±æ˜¯æˆ‘ä»¬ä»æ•¢è¯´ç¨‹åºé‡Œæ‰€æœ‰çš„å®šä¹‰éƒ½ä¸ä¼šè¢«æ¶ˆè´¹åˆ°ï¼Œæ˜¾ç„¶æ˜¯ä¸å¯¹çš„ï¼Œæˆ‘ä»¬ä»ä¸å®‰å…¨çš„ä¸€ä¸ªçŠ¶æ€å»æ‰¾åˆ°å®‰å…¨çš„ä¸€ä¸ªç‚¹ã€‚\næ³¨æ„ bottom æ˜¯ Basic Blocks çš„é¡¶ç‚¹ï¼Œä¹Ÿå°±æ˜¯ç¨‹åºçš„å¼€å§‹\nä¸€å®šä¼šæ‰¾åˆ°æœ€å°ä¸åŠ¨ç‚¹ï¼Œå‰é¢è¯æ˜è¿‡äº†\ntop æ˜¯æœ€æ²¡ç”¨çš„ï¼ˆç›¸å½“äºæ•´ä¸ªç¨‹åºé‡Œçš„å®šä¹‰å…¨éƒ¨éƒ½å¯èƒ½åˆ°è¾¾æœ«å°¾ï¼Œèƒ½åˆ°ç»“æŸçš„å®šä¹‰éƒ½åœ¨é‡Œé¢ï¼Œä½†æ˜¯æœ‰éƒ¨åˆ†å¹¶ä¸ä¼šåˆ°ï¼Œæ‰€ä»¥æ˜¯å®‰å…¨çš„ï¼Œåšäº†ä¸€äº›å¤šä½™çš„é˜²èŒƒï¼‰\nMust May Analysis æ˜¯ä»é”™é‡Œé¢å»æ”¹æ­£ï¼ŒMust æ˜¯ä»å¯¹çš„é‡Œå»æ‰¾é”™ï¼Œå‰è€…æ˜¯ sound çš„ï¼Œåè€…æ˜¯ complete çš„ã€‚\nHow Precise is Our Solution æœ‰äº›åˆ†æ”¯æ°¸è¿œä¸ä¼šæ‰§è¡Œå¦‚ if (false) ï¼Œæˆ‘ä»¬ä¾ç„¶è®¤ä¸ºè¿™æ¡åˆ†æ”¯é‡Œçš„æ•°æ®æ˜¯æœ‰ç”¨çš„ï¼Œè¿™æ ·å°±é€ æˆäº†å¤±çœŸ\nMeet-Over-All-Paths Solution (MOP) å‡è®¾æœ‰ä¸ªç¨‹åº P = Entry -\u0026gt; S1 -\u0026gt; S2 -\u0026gt; \u0026hellip; -\u0026gt; Si\n$$ MOP[S_i] = âˆª/âˆ© F_p(OUT[Entry]) $$\nMOP ä¼šè®¡ç®— data-flow çš„å€¼ï¼Œç„¶åæŠŠä»–ä»¬ meet / join\nä¹‹å‰çš„è¿­ä»£ç®—æ³•æ˜¯ bfsï¼Œä¸€è¾¹ meet/join ä¸€è¾¹èµ°ï¼ŒMOP æ˜¯ dfsï¼ŒæŠŠ path èµ°å®Œå† meet/join Iter Algo VS MOP è°æ›´å‡†ï¼šMOP ä»€ä¹ˆæ—¶å€™ç­‰äºï¼Ÿ\nF æœ‰å¯åˆ†é…æ€§ ä¹‹å‰çš„ä¸‰ä¸ªåˆ†æéƒ½æ˜¯å¯åˆ†é…çš„ Constant Propagation ä½œä¸šï¼š\nV é›†åˆæœ‰ä¸‰ç§ç±»å‹çš„å€¼ï¼š\næœªå®šä¹‰ï¼ˆUndefinedï¼‰ æŸä¸ªå…·ä½“å€¼ éå¸¸é‡ï¼ˆNot A Constantï¼‰ åœ¨ä¸Šé¢çš„ä¾‹å­é‡Œï¼Œæ˜¾ç„¶ MOP æ›´å‡†ã€‚è‚‰çœ¼å¯è§ c æ˜¯ä¸ªå¸¸é‡ï¼Œåªçœ‹ç»“æœ\nWorklist Algorithm æ˜¯å¯¹ Iterative Algorithm çš„ä¼˜åŒ–\nIter Algo çš„ç¼ºç‚¹ï¼šåªè¦æœ‰ä¸€ä¸ª Block å‘ç”Ÿå˜åŒ–ï¼Œå°±è¦æŠŠå…¨éƒ¨éƒ½é‡æ–°ç®—ä¸€é\næŠŠå‘ç”Ÿå˜åŒ–çš„ä¸¢é˜Ÿåˆ—é‡Œï¼Œç„¶ååªè®¡ç®—éœ€è¦æ›´æ–°çš„ ","date":"2022-11-08T22:26:17+08:00","permalink":"/p/note-data-flow-analysis-foundations/","title":"Note: Data Flow Analysis - Foundations"},{"content":"Preliminary ä»€ä¹ˆæ˜¯ Input å’Œ Output States ç¨‹åºæ˜¯ä¸ªçŠ¶æ€æœºï¼Œåœ¨ä¸€ä¸ªè¯­å¥æ‰§è¡Œå‰åéƒ½åº”å½“æœ‰ä¸€ä¸ªçŠ¶æ€ï¼Œä¿å­˜ç€æ¯”å¦‚å˜é‡ä¿¡æ¯ã€ä¸Šä¸‹æ–‡ç­‰ç­‰çš„å†…å®¹ï¼Œç„¶åè¯­å¥çš„æ‰§è¡Œå…¶å®å°±æ˜¯çŠ¶æ€æœºçš„ä¸€æ¡è¾¹ï¼Œæ”¹å˜äº†ç¨‹åºçš„çŠ¶æ€\nå¯¹äºä¸€ä¸ª Basic Block è€Œè¨€ï¼Œæ‰§è¡Œæµä¸è¿‡ä»¥ä¸‹ä¸‰ç§ï¼š1 to 1, 1 to n, n to 1\nReaching Definition Analysis rda èƒ½ç¡®å®šä¸€ä¸ªåœ¨ program point p æ—¶çš„å®šä¹‰ D åœ¨ program point q æ˜¯å¦æœ‰æ•ˆçš„ï¼Œå³è¿™ä¸ª D é‡Œå®šä¹‰çš„å˜é‡ v èƒ½ä¸èƒ½åœ¨ q æ—¶è¢«å®‰å…¨åœ°ä½¿ç”¨ã€‚å¦‚æœæœ‰ä¸€æ¡ path èƒ½è®© D èƒ½å¤Ÿ reach åˆ° qï¼Œé‚£ä¹ˆåœ¨ q ç‚¹ä½¿ç”¨ v æ˜¯å®‰å…¨çš„ï¼ˆå³èƒ½å¤Ÿç”¨åˆ°åœ¨ p ç‚¹å®šä¹‰çš„ vï¼‰\nä¸Šå›¾é‡Œï¼Œv åœ¨ p -\u0026gt; q çš„è·¯å¾„ä¸Šè¢«é‡æ–°å®šä¹‰äº†ï¼Œè¯´æ˜æˆ‘ä»¬æ— æ³•åœ¨ q ç‚¹ä¹‹åæ¶ˆè´¹åˆ° p ç‚¹å®šä¹‰çš„ vï¼Œæˆ‘ä»¬è¯´ definition d åœ¨ q ç‚¹æ˜¯æ— æ•ˆçš„\nåº”ç”¨ï¼šå¯ä»¥åˆ¤æ–­ç”¨äºå˜é‡æ˜¯å¦è¢«åˆå§‹åŒ– Algorithm ä½¿ç”¨ forward analysisï¼Œä»å¤´å¼€å§‹åˆ†æ\nå…¬å¼ï¼š\n$$ OUT[B] = gen[B] âˆª (IN[B] - kill[B])$$ $$ IN[B] = âˆª OUT[P] $$\nå…¶ä¸­ P æ˜¯ B çš„æ‰€æœ‰å‰é©±å—\ngen[B] æ˜¯åœ¨ B ä¸­çš„å®šä¹‰ï¼Œæ¯”å¦‚:\nB: D1: m = a; D2: n = b; åˆ™ gen[B] == {D1, D2} kill[B] æ˜¯åœ¨å…¶ä»–å—ä¸­ä¼šè¢« B é‡Œå®šä¹‰æ‰€è¦†ç›–çš„å®šä¹‰ï¼Œæ¯”å¦‚ï¼š\nB1: D1: m = a B2: D2: m = b é‚£ä¹ˆ kill[B1] == {D2} ç®—æ³•ä¼ªä»£ç å¦‚ä¸‹ï¼š\nç®—æ³•è„‘è·‘ï¼Œè¦ç‚¹ï¼š\nç»“æŸæ¡ä»¶æ˜¯æ‰€æœ‰ OUT åœ¨ä¸Šæ¬¡è¿­ä»£é‡Œä¸å˜ May Analysisï¼Œå³ sound çš„ï¼Œå¯èƒ½è¯¯æŠ¥ä½†ä¸ä¼šæ¼æŠ¥ï¼Œæœ‰å¯èƒ½è¢«è¦†ç›–ï¼Œä½†å¯èƒ½åœ¨æŸäº› path é‡Œå¹¶ä¸ä¼šè¢«è¦†ç›– ç®—æ³•ä¸€å®šä¼šåœä¸‹ï¼šå› ä¸º OUT çš„å¤§å°éå‡ï¼Œè€Œæœ‰æ˜ç¡®çš„ä¸Šç•Œï¼ˆå³å®šä¹‰çš„å…¨é›†ï¼Œåœ¨ bit vector é‡Œå°±æ˜¯å…¨ 1ï¼‰ï¼Œå› æ­¤ä¸€å®šä¼šæ”¶æ•›ï¼Œåœä¸‹çš„ç‚¹å«ä¸åŠ¨ç‚¹ (fixed point) Live Variables Analysis LVA èƒ½åˆ¤æ–­ å˜é‡ v èƒ½ä¸èƒ½ä»ç¨‹åºç‚¹ p å¼€å§‹æ²¿ç€ CFG è·¯å¾„è¢«ä½¿ç”¨ï¼Œå¦‚æœèƒ½ï¼Œè¯´æ˜ v åœ¨ p ç‚¹æ˜¯æ´»ç€çš„ï¼Œå¦åˆ™æ˜¯æ­»çš„ã€‚\nå¯¹äºä¸€ä¸ªæ­»å˜é‡ï¼Œè¯´æ˜ä»¥åä¸ä¼šè¢« use åˆ°ï¼Œç”¨äºèµ„æºåˆ†é…çš„ä¼˜åŒ–ï¼šå¯„å­˜å™¨åˆ†é…ç­–ç•¥ =\u0026gt; ä¼˜å…ˆå¹²æ­» dead value\nåˆ†æçš„æ˜¯å˜é‡ è¦æ±‚ v åœ¨è¢«ä½¿ç”¨å‰ä¸èƒ½è¢«å†æ¬¡å®šä¹‰ Algorithm ä½¿ç”¨ backward analysis æ›´æ–¹ä¾¿ï¼Œæˆ‘ä»¬ä»ç¨‹åºç»“æŸçš„åœ°æ–¹å¼€å§‹å¾€å‰åˆ†æï¼Œå¾—åˆ°å˜é‡åœ¨å„ä¸ª program point æ—¶çš„å­˜æ´»çŠ¶æ€ï¼ˆå³æ˜¯å¦åœ¨ p ç‚¹åé¢ä¼šè¢«ä½¿ç”¨ï¼‰\nå¦‚ä¸Šå›¾ï¼ŒS æ˜¯ B çš„åç»§å—ï¼Œå³æœ‰ B -\u0026gt; S1, B -\u0026gt; S2 ç­‰ç­‰\nIN[B], OUT[B] è¡¨ç¤ºå­˜æ´»å˜é‡çš„é›†åˆï¼Œåˆ™æœ‰ä»¥ä¸‹å…¬å¼\n$$ OUT[B] = âˆª IN[S] $$ $$ IN[B] = use[B] âˆª (OUT[B] - def[B]) $$\nå…¶ä¸­ use[B] çš„å…ƒç´ æ˜¯åœ¨ B ä¸­ï¼ˆåœ¨å®šä¹‰å‰ï¼‰è¢«ä½¿ç”¨çš„å˜é‡ï¼Œæ¯”å¦‚:\nB: m = k; n = j ï¼Œuse[B] == {k, j} B: m = k; n = m - 1 ï¼Œuse[B] == {k}ï¼Œm ä¸ç®—åœ¨é‡Œé¢ï¼Œå› ä¸ºå…¶æ˜¯åœ¨ B é‡Œå®šä¹‰åè¢«ä½¿ç”¨çš„ def[B] çš„å…ƒç´ æ˜¯åœ¨ B ä¸­è¢«å®šä¹‰çš„å˜é‡ï¼Œæ¯”å¦‚ï¼š\nB: m = k; n = jï¼Œdef[B] == {m, n} å…¬å¼é‡Œçš„ OUT[B] å¾ˆå¥½ç†è§£ï¼Œåœ¨å³å°†è¿›å…¥ S å—æ—¶è¿˜æ´»ç€çš„ï¼Œä¸€å®šåœ¨ç¦»å¼€ B æ—¶ä¹Ÿæ´»ç€ï¼Œæ‰€ä»¥å–å¹¶ã€‚\nè€Œ IN[B] é¦–å…ˆè€ƒè™‘çš„æ˜¯åœ¨ B é‡Œè¢«ä½¿ç”¨çš„å˜é‡ï¼ˆä¸èƒ½æ˜¯ B é‡Œå®šä¹‰å¹¶ä½¿ç”¨ï¼‰åœ¨è¿›å…¥ B æ—¶ä¸€å®šæ´»ç€ï¼›ç„¶åå¦‚æœæœ‰ä¸€ä¸ªå˜é‡åœ¨ç¦»å¼€ B æ—¶è¿˜æ´»ç€ï¼Œä½†æ˜¯è¿™ä¸ªå˜é‡åˆä¸æ˜¯åœ¨ B é‡Œè¢«å®šä¹‰çš„ï¼Œé‚£ä¹ˆä¸€å®šæ˜¯ä»ä¸Šä¸€ä¸ªå—ä¼ è¿›æ¥çš„ï¼Œæ‰€ä»¥æˆ‘ä»¬è¿˜è¦åŠ ä¸Š OUT[B] - def[B]ã€‚\nç®—æ³•è‡ªå·±è„‘è·‘ä¸€éï¼Œä¸€äº›è¦ç‚¹ï¼š\né›†åˆçš„è¡¨ç¤ºæ–¹å¼ä½¿ç”¨ bit vector çš„æ–¹å¼ï¼Œç»™æ¯ä¸ªå˜é‡èµ‹äºˆä¸€ä½çš„å¤§å°ï¼Œ1 è¡¨ç¤ºå­˜æ´»ï¼Œ0 è¡¨ç¤ºæ­»äº¡ã€‚ LVA æ˜¯ May Analysisï¼Œå³ sound çš„ï¼Œå¯èƒ½è¯¯æŠ¥ä½†ä¸ä¼šæ¼æŠ¥ï¼ˆå¯¹æŸæ¡ path Aï¼Œå¯èƒ½æŸä¸ªå˜é‡ a ä¸€ç›´ä¸ä¼šç”¨åˆ°ï¼Œä½†æ˜¯åœ¨ path B é‡Œ a è¢«ç”¨åˆ°äº†ï¼Œé‚£ä¹ˆæˆ‘ä»¬è®¤ä¸ºåˆ†å‰åˆ° A å’Œ B å‰çš„äº¤ç‚¹ a åº”è¯¥æ˜¯æ´»ç€çš„ï¼Œå°½ç®¡ä»£ç å¯èƒ½ä¸è·‘ Bï¼‰ ç»“æŸæ¡ä»¶æ˜¯åœ¨ä¸Šä¸€æ¬¡è¿­ä»£é‡Œå¯¹æ‰€æœ‰ Basic Block Bï¼ŒIN[B] éƒ½æ²¡å˜ Available Expression Analysis AEA èƒ½åˆ¤æ–­ä¸€ä¸ªè¡¨è¾¾å¼åœ¨ program point p æ˜¯ä¸æ˜¯æœ‰æ•ˆçš„\nx op y åœ¨ p ç‚¹æœ‰æ•ˆçš„æˆç«‹æ¡ä»¶ï¼š\nä»èµ·ç‚¹å¼€å§‹æ‰€æœ‰åˆ° p çš„ path éƒ½è¦ç»è¿‡ x op y çš„å€¼ æ²¡æœ‰é‡æ–°å®šä¹‰ x op y é‡Œçš„å˜é‡ï¼ˆx æˆ–è€… yï¼‰ AEA å…³æ³¨çš„æ˜¯ expressionï¼Œå¯ä»¥ç”¨äºä¼˜åŒ–ï¼šå¯¹æ‰€æœ‰ pathï¼Œå¦‚æœæŸä¸ªè¡¨è¾¾å¼ä¸€ç›´å‡ºç°è€Œä¸”æ²¡å˜ï¼Œå°±å¯ä»¥ç›´æ¥å¤ç”¨ä¹‹å‰çš„ç»“æœï¼ŒèŠ‚çœè®¡ç®—\nAEA ä½¿ç”¨çš„æ˜¯ forward analysisï¼Œå…¬å¼ï¼š\n$$ OUT[B] = gen[B] âˆª (IN[B] - kill[B]) $$ $$ IN[B] = âˆ© OUT[P] $$\nP æ˜¯ B çš„å‰é©±ï¼Œå…¶ä¸­å¯¹ gen[B] ä¸ kill[B] çš„è®¡ç®—æ–¹æ³•å¦‚ä¸‹ï¼š gen[B] å°±æ˜¯ B é‡Œå‡ºç°çš„ x op y è¡¨è¾¾å¼çš„é›†åˆ kill[B] æ˜¯å¯¹ IN[B] é‡Œè¡¨è¾¾å¼å˜é‡æˆå‘˜æœ‰åšé‡å®šä¹‰çš„è¡¨è¾¾å¼çš„é›†åˆ æ³¨æ„ IN[B] æ˜¯å¯¹å‰é©±å— OUT çš„äº¤é›†ï¼Œå› ä¸ºè¦æ±‚æ‰€æœ‰ path éƒ½ç»è¿‡ï¼ˆè¿™æ ·æ‰èƒ½è¾¾åˆ° safe çš„è¦æ±‚ï¼‰ å†æ¯”å¦‚ä¸‹å›¾ï¼š\na è¢«é‡å®šä¹‰äº†ï¼Œå› æ­¤ kill[B] å°±æ˜¯ IN ä¸­æœ‰å˜é‡è¢«é‡å®šä¹‰çš„è¡¨è¾¾å¼ï¼Œå³ kill[B] == {a+b}ï¼Œè€Œ IN[B] - kill[B] == {}\nAlgorithm ä¸‹é¢çš„ä¾‹å­è„‘è·‘ï¼Œè¦ç‚¹ï¼š\nmust: éœ€è¦ safetyï¼Œæ‰€ä»¥å¿…é¡» under-approximationï¼Œä¸èƒ½è¯¯æŠ¥ ç»“æŸæ¡ä»¶æ˜¯ OUT ä¸å˜ entry åˆå§‹åŒ–ä¸ºç©ºï¼Œè€Œå…¶ä½™çš„éƒ½åˆå§‹åŒ– Allï¼Œå› ä¸ºè¦å–äº¤é›†ï¼Œå¦‚æœä»¥ç©ºå¼€å±€å°±å…¨0äº† Comparison ä¸‰ç§åˆ†æé’ˆå¯¹ä¸‰ç§ä¸åŒçš„é›†åˆï¼ˆå®šä¹‰é›†åˆã€å˜é‡é›†åˆã€è¡¨è¾¾å¼é›†åˆï¼‰ Transfer æ ¸å¿ƒå…¶å®éƒ½æ˜¯ä¸€æ ·çš„ï¼Œåªæ˜¯ LVA æ˜¯ backward analysisï¼Œæ‰€ä»¥æŠŠ IN åè¿‡æ¥è®¡ç®— ","date":"2022-11-07T22:41:10+08:00","permalink":"/p/note-data-flow-analysis-applications/","title":"Note: Data Flow Analysis - Applications"},{"content":"https://dtolnay.github.io/rust-quiz\nQuiz #1: Quiz #2: () and 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 struct S(i32); impl std::ops::BitAnd\u0026lt;S\u0026gt; for () { type Output = (); fn bitand(self, rhs: S) { print!(\u0026#34;{}\u0026#34;, rhs.0); } } fn main() { let f = || ( () \u0026amp; S(1) ); let g = || { () \u0026amp; S(2) }; let h = || ( {} \u0026amp; S(3) ); let i = || { {} \u0026amp; S(4) }; f(); g(); h(); i(); } Answer Output: 123\nThe closures f, g, and h are all of type impl Fn(). The closure bodies are parsed as an invocation of the user-defined bitwise-AND operator defined above by the BitAnd trait impl. When the closures are invoked, the bitwise-AND implementation prints the content of the S from the right-hand side and evaluates to ().\nThe closure i is different. Formatting the code with rustfmt makes it clearer how i is parsed.\n1 2 3 4 let i = || { {} \u0026amp;S(4) }; The closure body consists of an empty block-statement {} followed by a reference to S(4), not a bitwise-AND. The type of i is impl Fn() -\u0026gt; \u0026amp;'static S.\nThe parsing of this case is governed by this code in libsyntax.\nQuiz #3: semantics of const 1 2 3 4 5 6 7 8 9 10 11 12 struct S { x: i32, } const S: S = S { x: 2 }; fn main() { let v = \u0026amp;mut S; v.x += 1; S.x += 1; print!(\u0026#34;{}{}\u0026#34;, v.x, S.x); } Answer The semantics of const is that any mention of the const by name in expression position is substituted with the value of the const initializer. In this quiz code the behavior is equivalent to:\n1 2 3 4 5 6 7 8 9 10 11 struct S { x: i32, } fn main() { let mut _tmp0 = S { x: 2 }; let v = \u0026amp;mut _tmp0; v.x += 1; S { x: 2 }.x += 1; print!(\u0026#34;{}{}\u0026#34;, v.x, S { x: 2 }.x); } Quiz #5 https://dtolnay.github.io/rust-quiz/5\nWhat is the output of this Rust program?\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 trait Trait { fn p(self); } impl\u0026lt;T\u0026gt; Trait for fn(T) { fn p(self) { print!(\u0026#34;1\u0026#34;); } } impl\u0026lt;T\u0026gt; Trait for fn(\u0026amp;T) { fn p(self) { print!(\u0026#34;2\u0026#34;); } } fn f(_: u8) {} fn g(_: \u0026amp;u8) {} fn main() { let a: fn(_) = f; let b: fn(_) = g; let c: fn(\u0026amp;_) = g; a.p(); b.p(); c.p(); } è§£ç­” è¾“å‡º 112\nå…¶å®éš¾ç‚¹å°±æ˜¯ b åˆ°åº•å±äºå“ªç§ç±»å‹ï¼Œéœ€è¦æŠŠç¬¬äºŒä¸ªå®ç°å±•å¼€ï¼Œimpl\u0026lt;'a T\u0026gt; Trait for fn(\u0026amp;'a T)ï¼Œb æˆ‘ä»¬ä¼šæ¨æ–­ _ = \u0026amp;'x u8ï¼Œb çš„ç±»å‹åº”è¯¥æ˜¯ fn(\u0026amp;'x u8)ï¼Œç­¾åæŒ‰ç…§ fn(T) æ¥ã€‚\nQuiz #10: æ–¹æ³•çš„è¦†ç›– https://dtolnay.github.io/rust-quiz/10\nWhat is the output of this Rust program?\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 trait Trait { fn f(\u0026amp;self); } impl\u0026lt;\u0026#39;a\u0026gt; dyn Trait + \u0026#39;a { fn f(\u0026amp;self) { print!(\u0026#34;1\u0026#34;); } } impl Trait for bool { fn f(\u0026amp;self) { print!(\u0026#34;2\u0026#34;); } } fn main() { Trait::f(\u0026amp;true); Trait::f(\u0026amp;true as \u0026amp;dyn Trait); \u0026lt;_ as Trait\u0026gt;::f(\u0026amp;true); \u0026lt;_ as Trait\u0026gt;::f(\u0026amp;true as \u0026amp;dyn Trait); \u0026lt;bool as Trait\u0026gt;::f(\u0026amp;true); \u0026lt;dyn Trait as Trait\u0026gt;::f(\u0026amp;true as \u0026amp;dyn Trait); } è§£ç­” è¾“å‡º 222222\nä¸º bool å®ç°çš„æ–¹æ³•ä¼šè¦†ç›–ï¼ˆshadowï¼‰æ‰å†…åœ¨çš„æ–¹æ³•ï¼ˆinherent methodï¼‰ï¼Œä¹Ÿå°±æ˜¯ dyn Trait é‚£ä¸ªã€‚\nè€Œç°åœ¨ Rust è¿˜æ²¡æœ‰æ–¹æ³•å»è°ƒç”¨é‚£ä¸ª dyn Traitï¼Œå¦‚æœæŒ‰ä¸‹é¢çš„æ–¹å¼è°ƒç”¨ä¼šæŠ¥é”™\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 error[E0034]: multiple applicable items in scope --\u0026gt; questions/010.rs:18:5 | 18 | \u0026lt;dyn Trait\u0026gt;::f(\u0026amp;true); | ^^^^^^^^^^^^^^ multiple `f` found | note: candidate #1 is defined in an impl for the type `dyn Trait` --\u0026gt; questions/010.rs:6:5 | 6 | fn f(\u0026amp;self) { | ^^^^^^^^^^^ note: candidate #2 is defined in the trait `Trait` --\u0026gt; questions/010.rs:2:5 | 2 | fn f(\u0026amp;self); | ^^^^^^^^^^^^ = help: to disambiguate the method call, write `Trait::f(...)` instead Quiz #11: static lifetime function 1 2 3 4 5 6 7 8 fn f\u0026lt;\u0026#39;a\u0026gt;() {} fn g\u0026lt;\u0026#39;a: \u0026#39;a\u0026gt;() {} fn main() { let pf = f::\u0026lt;\u0026#39;static\u0026gt; as fn(); let pg = g::\u0026lt;\u0026#39;static\u0026gt; as fn(); print!(\u0026#34;{}\u0026#34;, (pf == pg) as u8); } Answer Cannot compile.\nReason too complicated so I just copy the content: https://dtolnay.github.io/rust-quiz/11\nFunction pointer comparison is generally a Bad Idea. It is easily possible to get nonsensical behavior in optimized builds. For a jaw-dropping example of such behavior, check out rust-lang/rust#54685 in which x == y is both true and not true at the same time.\nThat said, the quiz code in this question fails to compile. Here is the compiler output:\nerror: cannot specify lifetime arguments explicitly if late bound lifetime parameters are present\n1 2 3 4 5 --\u0026gt; questions/011.rs:5:18 | 5 | let pf = f::\u0026lt;\u0026#39;static\u0026gt; as fn(); | ^^^^^^^ | note: the late bound lifetime parameter is introduced here\n1 2 3 4 --\u0026gt; questions/011.rs:1:18 | 1 | fn f\u0026lt;\u0026#39;a\u0026gt;() {} | ^^ Generic parameters can be either early bound or late bound. Currently (and for the foreseeable future) type parameters are always early bound, but lifetime parameters can be either early or late bound.\nEarly bound parameters are determined by the compiler during monomorphization. Since type parameters are always early bound, you cannot have a value whose type has an unresolved type parameter. For example:\n1 2 3 4 5 6 7 8 9 10 11 12 13 fn m\u0026lt;T\u0026gt;() {} fn main() { let m1 = m::\u0026lt;u8\u0026gt;; // ok let m2 = m; // error: cannot infer type for `T` } However, this is often allowed for lifetime parameters: fn m\u0026lt;\u0026#39;a\u0026gt;(_: \u0026amp;\u0026#39;a ()) {} fn main() { let m1 = m; // ok even though \u0026#39;a isn\u0026#39;t provided } Since the actual choice of lifetime \u0026lsquo;a depends on how it is called, we are allowed to omit the lifetime parameter and it will be determined at the call site. The lifetime can even be different for each time it gets called.\nFor this reason, we cannot specify the lifetime on this function until it is called:\n1 2 // error: cannot specify lifetime arguments explicitly if late bound lifetime parameters are present let m2 = m::\u0026lt;\u0026#39;static\u0026gt;; We may not even ask the borrow checker to infer it too soon:\n1 2 // error: cannot specify lifetime arguments explicitly if late bound lifetime parameters are present let m3 = m::\u0026lt;\u0026#39;_\u0026gt;; The idea of late bound parameters overlaps considerably with a feature of Rust called \u0026ldquo;higher ranked trait bounds\u0026rdquo; (HRTB). This is a mechanism for expressing that bounds on a trait\u0026rsquo;s parameters are late bound. Currently this is limited to lifetime parameters, but the same idea exists in other languages (such as Haskell) for type parameters, which is where the term \u0026ldquo;higher ranked\u0026rdquo; comes from.\nThe syntax to express a HRTB for lifetimes uses the for keyword. To express the type of m1 above, we could have written:\n1 let m1: impl for\u0026lt;\u0026#39;r\u0026gt; Fn(\u0026amp;\u0026#39;r ()) = m; You can think of this as meaning: \u0026ldquo;There is a lifetime but we don\u0026rsquo;t need to know what it is just yet\u0026rdquo;.\nLate bound lifetimes are always unbounded; there is no syntax for expressing a late bound lifetime that must outlive some other lifetime.\n1 2 3 4 5 error: lifetime bounds cannot be used in this context --\u0026gt; src/main.rs:5:20 | 5 | let _: for\u0026lt;\u0026#39;b: \u0026#39;a\u0026gt; fn(\u0026amp;\u0026#39;b ()); | ^^ Lifetimes on data types are always early bound except when the developer has explicitly used the HRTB for syntax. On functions, lifetimes are late bound by default but can be early bound if:\nThe lifetime is declared outside the function signature, e.g. in an associated method of a struct it could be from the struct itself; or\nThe lifetime parameter is bounded below by some other lifetime that it must outlive. As we\u0026rsquo;ve seen, this constraint is not expressible in the HRTB that would be involved in late binding the lifetime.\nBy these rules, the signature fn f\u0026lt;\u0026lsquo;a\u0026gt;() has a late bound lifetime parameter while the signature fn g\u0026lt;'a: 'a\u0026gt;() has an early bound lifetime parameter â€” even though the constraint here is ineffectual.\nOrdinarily these distinctions are compiler-internal terminology that Rust programmers are not intended to know about or think about in everyday code. There are only a few edge cases where this aspect of the type system becomes observable in the surface language, such as in the original quiz code.\nQuiz #12: deconstruct and drop 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 struct D(u8); impl Drop for D { fn drop(\u0026amp;mut self) { print!(\u0026#34;{}\u0026#34;, self.0); } } struct S { d: D, x: u8, } fn main() { let S { x, .. } = S { d: D(1), x: 2, }; print!(\u0026#34;{}\u0026#34;, x); let S { ref x, .. } = S { d: D(3), x: 4, }; print!(\u0026#34;{}\u0026#34;, x); } Answer Output: 1243\nCore question: Where does D get dropped?\nThe first S is dropped immediately since there is no any owner.\nThe second S remains in scope since its field is borrowed and is dropped after the scope of main.\nQuiz #16: \u0026ndash;x 1 2 3 4 5 fn main() { let mut x = 4; --x; print!(\u0026#34;{}{}\u0026#34;, --x, --x); } Answer Output: 44\nThere is no unary increment or decrement operator in Rust.\nWhy doesn\u0026rsquo;t Rust have increment and decrement operators?\nPreincrement and postincrement (and the decrement equivalents), while convenient, are also fairly complex. They require knowledge of evaluation order, and often lead to subtle bugs and undefined behavior in C and C++. x = x + 1 or x += 1 is only slightly longer, but unambiguous.\n--x is parsed as -(-x), so it\u0026rsquo;s just an expression statement.\nQuiz #19: drop https://dtolnay.github.io/rust-quiz/19\nWhat is the output of this Rust program?\n1 2 3 4 5 6 7 8 9 10 11 12 13 struct S; impl Drop for S { fn drop(\u0026amp;mut self) { print!(\u0026#34;1\u0026#34;); } } fn main() { let s = S; let _ = s; print!(\u0026#34;2\u0026#34;); } è§£ç­” è¾“å‡º 21\næ¯”è¾ƒç®€å•ï¼Œä¸¤ä¸ª let åªæœ‰ä¸€ä¸ª S è¢«åˆ›å»ºäº†ï¼Œç¬¬äºŒä¸ªåªæ˜¯è½¬ç§»äº†æ‰€æœ‰æƒï¼Œåœ¨ç”Ÿå‘½å‘¨æœŸç»“æŸæ—¶è°ƒç”¨ dropã€‚\nQuiz #22: å®çš„å‚æ•° https://dtolnay.github.io/rust-quiz/22\nWhat is the output of this Rust program?\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 macro_rules! m { ($a:tt) =\u0026gt; { print!(\u0026#34;1\u0026#34;) }; ($a:tt $b:tt) =\u0026gt; { print!(\u0026#34;2\u0026#34;) }; ($a:tt $b:tt $c:tt) =\u0026gt; { print!(\u0026#34;3\u0026#34;) }; ($a:tt $b:tt $c:tt $d:tt) =\u0026gt; { print!(\u0026#34;4\u0026#34;) }; ($a:tt $b:tt $c:tt $d:tt $e:tt) =\u0026gt; { print!(\u0026#34;5\u0026#34;) }; ($a:tt $b:tt $c:tt $d:tt $e:tt $f:tt) =\u0026gt; { print!(\u0026#34;6\u0026#34;) }; ($a:tt $b:tt $c:tt $d:tt $e:tt $f:tt $g:tt) =\u0026gt; { print!(\u0026#34;7\u0026#34;) }; } fn main() { m!(-1); m!(-1.); m!(-1.0); m!(-1.0e1); m!(-1.0e-1); } è§£ç­” è¾“å‡º 22222\ntt è¡¨ç¤º tokenï¼Œè¿™ä¸ªå®çš„åŠŸèƒ½æ˜¯æŒ‰ä¼ å…¥çš„ token æ•°åˆ†ç±»ã€‚\nRust çš„ç¼–è¯‘å™¨ä¼šæŠŠ - å•ç‹¬çœ‹æˆä¸€ä¸ªè´Ÿå·ï¼Œäº”ä¸ªè°ƒç”¨éƒ½æ˜¯ä¸€ä¸ªè´Ÿå·åŠ ä¸€ä¸ªæ•°å­—ã€‚\nlet x = -2.pow(2) ä¼šè¢«è§£ææˆ -(2.pow(2)) è€Œä¸æ˜¯ (-2).pow(2)\nQuiz #24: å…³äºå®çš„ \u0026lsquo;hygiene\u0026rsquo; https://dtolnay.github.io/rust-quiz/24\nWhat is the output of this Rust program?\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 fn main() { let x: u8 = 1; const K: u8 = 2; macro_rules! m { () =\u0026gt; { print!(\u0026#34;{}{}\u0026#34;, x, K); }; } { let x: u8 = 3; const K: u8 = 4; m!(); } } è§£ç­” è¾“å‡º 14\nå¯¹äºå®è€Œè¨€æœ‰ä¸€ä¸ªæ¦‚å¿µå« hygieneï¼Œä¸­æ–‡æ˜¯ã€å«ç”Ÿã€‘çš„æ„æ€ï¼Œç”±ã€å®å¦‚ä½•å¤„ç†å¤–éƒ¨å˜é‡ã€‘æ¥åŒºåˆ†æ˜¯å¦ hygiene\næœ‰ä¸€ä¸ª reddit ä¸Šå¯¹æ­¤çš„è®¨è®ºï¼Œæ‘˜æŠ„ä¸€ä¸ªå›ç­”ï¼š\nFor example, if you declare a variable named x inside a macro and you happen to call that macro on an x from somewhere else, it won\u0026rsquo;t suddenly and magically cause things to break because the compiler will know that they\u0026rsquo;re two different things.\n(The gist is that macros in languages like C have some very surprising misbehaviours and \u0026ldquo;hygienic\u0026rdquo; macros will behave more like functions when it comes to things like variable scopes and order of operations.)\nå¦‚æœç¼–è¯‘å™¨ä¸å¤„ç†å‡ºç°åœ¨å®é‡Œçš„å˜é‡åï¼Œè€Œæ˜¯ç­‰ç€ç›´æ¥å±•å¼€ï¼ˆå¦‚ C è¯­è¨€ï¼‰ï¼Œé‚£ä¹ˆè¿™ä¸ªåº”è¯¥ç®—ä½œä¸å«ç”Ÿï¼Œå› ä¸ºå¯èƒ½ä¼šå‡ºç°å¤–éƒ¨å˜é‡å‘½åä¸º aï¼Œè€Œå®å†…ä½¿ç”¨äº† a å˜é‡ï¼Œä½¿ç”¨ç»“æœä¼šå› ä¸ºå¤–éƒ¨å˜é‡å‘½åä¸åŒè€Œæœ‰å˜åŒ–ã€‚\nRust æ˜¯é—¨â€œéƒ¨åˆ†å«ç”Ÿâ€çš„è¯­è¨€ï¼Œä¼šå¯¹ä¸€éƒ¨åˆ†çš„å¤–éƒ¨å˜é‡è¿›è¡Œå¤„ç†ã€‚ä½†æ˜¯ä»…é™æœ¬åœ°å˜é‡ï¼Œå¯¹ const ä¸ä¼šåšå¤„ç†ï¼ˆconst å˜é‡ä¼šè¢«è®¤ä¸ºæ˜¯ä¸ªæ™®é€šçš„å•è¯è€Œä¸æ˜¯å˜é‡ï¼‰ã€‚å› æ­¤åœ¨è¿™é¢˜é‡Œï¼ŒRust ä¼šå…ˆæŠŠå¤–è¾¹çš„ x ç¼–è¿›å®å†…ï¼Œä¹‹åå†è¿›è¡Œå±•å¼€ï¼Œæœ€ç»ˆæ‰“å° 14ã€‚\nhygiene ç›¸å…³çš„ç¬”è®°\nQuiz #25: name resolution 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 use std::fmt::{self, Display}; struct S; impl Display for S { fn fmt(\u0026amp;self, formatter: \u0026amp;mut fmt::Formatter) -\u0026gt; fmt::Result { formatter.write_str(\u0026#34;1\u0026#34;) } } impl Drop for S { fn drop(\u0026amp;mut self) { print!(\u0026#34;2\u0026#34;); } } fn f() -\u0026gt; S { S } fn main() { let S = f(); // \u0026lt;- this is destructuring instead of assignment print!(\u0026#34;{}\u0026#34;, S); } Answer Output: 212\nOn the first line of main, we call f() and perform an infallible match that binds no new variables. As no variables are declared on this line, there is no variable that could be the owner of the S returned by f() so that S is dropped at that point, printing 2. The S in let S = f() is a unit struct pattern (not a variable name) that matches a value of type S via destructuring but does not bind the value to any variable.\nThe second line of main conjures a new S, prints it, and drops it at the semicolon.\nQuiz #26: Lazy iter::map 1 2 3 4 5 6 7 8 9 10 11 12 13 14 fn main() { let input = vec![1, 2, 3]; let parity = input .iter() .map(|x| { print!(\u0026#34;{}\u0026#34;, x); x % 2 }); for p in parity { print!(\u0026#34;{}\u0026#34;, p); } } Answer Output: 112031\nIterator::map is executed lazily.\nQuiz #28: empty struct drop 1 2 3 4 5 6 7 8 9 10 11 12 13 14 struct Guard; impl Drop for Guard { fn drop(\u0026amp;mut self) { print!(\u0026#34;1\u0026#34;); } } fn main() { let _guard = Guard; print!(\u0026#34;3\u0026#34;); let _ = Guard; print!(\u0026#34;2\u0026#34;); } Answer Output: 3121\nthe Drop impl for let _guard = Guard runs at the end of main but the Drop impl for let _ = Guard runs right away.\nIn general, a value is dropped when it no longer has an owner.\nSomething beyond itself This distinction between the underscore pattern vs variables with a leading underscore is incredibly important to remember when working with lock guards in unsafe code.\n1 2 3 4 5 6 7 8 9 10 11 12 13 use std::sync::Mutex; static MUTEX: Mutex\u0026lt;()\u0026gt; = Mutex::new(()); /// MUTEX must be held when accessing this value. static mut VALUE: usize = 0; fn main() { let _guard = MUTEX.lock().unwrap(); unsafe { VALUE += 1; } } If this code were to use let _ = MUTEX.lock().unwrap() then the mutex guard would be dropped immediately, releasing the mutex and failing to guard the access of VALUE.\nQuiz #30: zero-sized types for () and empty struct 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 use std::rc::Rc; struct A; fn p\u0026lt;X\u0026gt;(x: X) { match std::mem::size_of::\u0026lt;X\u0026gt;() { 0 =\u0026gt; print!(\u0026#34;0\u0026#34;), _ =\u0026gt; print!(\u0026#34;1\u0026#34;), } } fn main() { let a = \u0026amp;A; p(a); p(a.clone()); let b = \u0026amp;(); p(b); p(b.clone()); let c = Rc::new(()); p(Rc::clone(\u0026amp;c)); p(c.clone()); } Answer Output: 111011\nThe function p\u0026lt;X\u0026gt; will print 0 if it is passed a value of type X = () or X = A, and it will print 1 if passed a reference X = \u0026amp;() or X = \u0026amp;A regardless of exactly how big pointers happen to be.\nIf A implemented Clone then a.clone() would be a call to that impl. But since it doesn\u0026rsquo;t, the compiler finds another applicable impl which is the implementation of Clone for references \u0026amp;T \u0026ndash; so concretely the clone call is calling the impl of Clone for \u0026amp;A which turns a \u0026amp;\u0026amp;A into a \u0026amp;A by simply duplicating the reference. We get another call to p with X = \u0026amp;A printing 1. The impl of Clone for references is useful in practice when a struct containing a reference wants to derive Clone, but as seen here it can sometimes kick in unexpectedly.\nThe type () does implement Clone so b.clone() invokes that impl and produces (). The implementation of Clone for \u0026amp;() would also be applicable as happened in the case of A, but the compiler prefers calling the trait impl for () which converts \u0026amp;() to () over the trait impl for \u0026amp;() which converts \u0026amp;\u0026amp;() to \u0026amp;() because the former is the one that requires fewer implicit references or dereferences inserted by the trait solver. In the call to b.clone(), b is of type \u0026amp;() which exactly matches the argument of the impl Clone for (), while in order to obtain a \u0026amp;\u0026amp;() to pass as argument to the impl Clone for \u0026amp;() the trait solver would need to insert an additional layer of referencing implicitly \u0026ndash; effectively computing (\u0026amp;b).clone().\nQuiz #33: RangeFull https://dtolnay.github.io/rust-quiz/33\nWhat is the output of this Rust program?\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 use std::ops::RangeFull; trait Trait { fn method(\u0026amp;self) -\u0026gt; fn(); } impl Trait for RangeFull { fn method(\u0026amp;self) -\u0026gt; fn() { print!(\u0026#34;1\u0026#34;); || print!(\u0026#34;3\u0026#34;) } } impl\u0026lt;F: FnOnce() -\u0026gt; T, T\u0026gt; Trait for F { fn method(\u0026amp;self) -\u0026gt; fn() { print!(\u0026#34;2\u0026#34;); || print!(\u0026#34;4\u0026#34;) } } fn main() { (|| .. .method())(); } è§£ç­” è¾“å‡º24\nRangeFull å…¶å®å°±æ˜¯ ..ï¼Œæ˜¯å¯ä»¥å•ç‹¬ä½¿ç”¨çš„ï¼Œå¦‚ä¸‹ï¼š\n1 2 3 4 5 6 7 let arr = [0, 1, 2, 3, 4]; assert_eq!(arr[ .. ], [0, 1, 2, 3, 4]); // This is the `RangeFull` assert_eq!(arr[ .. 3], [0, 1, 2 ]); assert_eq!(arr[ ..=3], [0, 1, 2, 3 ]); assert_eq!(arr[1.. ], [ 1, 2, 3, 4]); assert_eq!(arr[1.. 3], [ 1, 2 ]); assert_eq!(arr[1..=3], [ 1, 2, 3 ]); ä½†ä¸èƒ½ç›´æ¥ç”¨äºå¾ªç¯ for i in ..\nè¿™é¢˜åªå¯èƒ½ä¸¤ç§ç­”æ¡ˆï¼Œ1 æˆ–è€… 24ï¼Œè§£ææˆ || ((..).method()) å°±æ˜¯ 1ï¼Œè§£ææˆ (|| ..).method() å°±æ˜¯ 24\nQuiz #34: zero-sized type 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 fn d\u0026lt;T\u0026gt;(_f: T) { match std::mem::size_of::\u0026lt;T\u0026gt;() { 0 =\u0026gt; print!(\u0026#34;0\u0026#34;), 1 =\u0026gt; print!(\u0026#34;1\u0026#34;), _ =\u0026gt; print!(\u0026#34;2\u0026#34;), } } fn a\u0026lt;T\u0026gt;(f: fn(T)) { d(f); } fn main() { a(a::\u0026lt;u8\u0026gt;); d(a::\u0026lt;u8\u0026gt;); } Answer Output: 20\na::\u0026lt;u8\u0026gt;\u0026rsquo;s type is zero-sized.\nIn Rust, every distinct instantiation of a generic function has its own unique type. (two function with the same signature would have different types)\niter::map is one example: iter::map(f) and iter::map(g) would call f(element) and g(element) in compiled binary file instead of pass a function pointer as the argument like C or Go.\nCurrently in Rust there is no syntax to express the type of a specific function, so they are always passed as a generic type parameter with a FnOnce, Fn or FnMut bound. In error messages you might see function types appear in the form fn(T) -\u0026gt; U {fn_name}, but you can\u0026rsquo;t use this syntax in code.\nOn the other hand, a function pointer, fn(T) -\u0026gt; U, is pointer-sized at runtime. Function types can be coerced into function pointers, which can be useful in case you need to defer the choice of function to call until runtime.\nIn the quiz code, the first call in main coerces a::\u0026lt;u8\u0026gt; from a function to a function pointer (fn(fn(u8)) {a::\u0026lt;u8\u0026gt;} to fn(fn(u8))) prior to calling d, so its size would be 8 on a system with 64-bit function pointers. The second call in main does not involve function pointers; d is directly called with T being the inexpressible type of a::\u0026lt;u8\u0026gt;, which is zero-sized.\nAs for Rc, it\u0026rsquo;s obvious.\n","date":"2022-10-19T23:30:23+08:00","permalink":"/p/rust-quiz-%E8%AE%B0%E5%BD%95/","title":"Rust Quiz è®°å½•"},{"content":"æœ¬æ–‡ç« å†…å®¹ï¼šä½¿ç”¨ TypeScript å®ç° Rust çš„éƒ¨åˆ†æ¨¡å¼åŒ¹é…ç‰¹æ€§ï¼ˆmatchã€Optionã€Resultï¼‰\næ ‡é¢˜å¯ä»¥ç†è§£ä¸ºã€Š Rust å‘³çš„ TypeScript ã€‹\né˜…è¯»é¡»çŸ¥ï¼š\næ— éœ€ Rust åŸºç¡€çŸ¥è¯†ï¼Œä¹Ÿä¸ Rust æœ€éš¾çš„å†…å­˜å®‰å…¨æ¨¡å‹æ— å…³ åŒ…å«å¯¹æ¨¡å¼åŒ¹é…çš„ç†è§£ åŒ…å«ä¸€ç§å®ç°çš„å¼€æºä»£ç è®²è§£ å°‘é‡ç±»å‹ä½“æ“ æ¨¡å¼åŒ¹é… (Pattern Matching) æ˜¯ä»€ä¹ˆ å‡½æ•°å¼ç¼–ç¨‹é‡Œçš„æ¦‚å¿µ æ¨¡å¼åŒ¹é…æ˜¯æ£€æŸ¥ç»™å®šè®°å·åºåˆ—ä¸­ï¼Œæ˜¯å¦å­˜åœ¨æŸç§æ¨¡å¼çš„ç»„æˆéƒ¨åˆ†çš„è¡Œä¸ºã€‚â€”â€”ç»´åŸº\npattern matching is the act of checking a given sequence of tokens for the presence of the constituents of some pattern. â€”â€” Wikipedia\næ¨¡å¼å¯ä»¥ç†è§£ä¸ºã€è§„å¾‹ã€‘ã€‚å®šä¹‰å¬èµ·æ¥å¾ˆæŠ½è±¡ï¼Œä¸¾ä¸€ç‚¹ä¾‹å­ä¹‹åæ˜¯å¾ˆå®¹æ˜“ç†è§£è¿™ä¸ªåå­—çš„ã€‚\nswitchã€RegExp æ˜¯ä¸€ç§æ¨¡å¼åŒ¹é… 1 2 3 4 5 6 7 8 fn main() { let x = 1; match x { 1 =\u0026gt; println!(\u0026#34;one\u0026#34;), 2 =\u0026gt; println!(\u0026#34;two\u0026#34;), _ =\u0026gt; println!(\u0026#34;anything\u0026#34;), } } æœ€ç®€å•çš„ä½¿ç”¨å°±åƒä¸€ä¸ª switchï¼Œä½†æ˜¯é™¤äº†èƒ½åŒ¹é…å‡ºå€¼ï¼Œä¹Ÿèƒ½åŒ¹é…å‡ºä½ç½®ã€ç”šè‡³åå­—ã€‚\nå¯¹åé¢è¿™å¥æ˜¯ä¸æ˜¯æœ‰ç‚¹æƒ³æ³•ï¼Ÿ\n1 2 3 4 5 const { a, b } = { a: 1, b: 2 }; // a should be 1; b should be 2. const [ a, _, ...c ] = [ 1, 2, 3, 4, 5 ]; // a should be 1; c should be [3,4,5]. å…¶å®jsé‡Œçš„è§£æ„èµ‹å€¼å°±æ˜¯ä¸€ç§æ¨¡å¼åŒ¹é…ï¼Œé™¤äº†ã€æ¡ä»¶æ‰§è¡Œã€‘ä»¥å¤–ï¼Œè¿˜æœ‰ã€æå–ã€‘å‡ºæƒ³è¦çš„æ•°æ®çš„åŠŸèƒ½ã€‚å›è¿‡å¤´çœ‹æ­£åˆ™è¡¨è¾¾å¼ï¼Œå°±èƒ½å¾ˆå®¹æ˜“ç†è§£è¿™ä¸ªæ¦‚å¿µï¼Œæ—¢å¯ä»¥testå»æµ‹è¯•æ˜¯å¦åŒ¹é…ï¼Œåˆå¯ä»¥execå»æ•è·åŒ¹é…åˆ°çš„æ•°æ®ã€‚\nIn contrast to pattern recognition, the match usually has to be exact: \u0026ldquo;either it will or will not be a match.\u0026quot;â€”â€” Wikipedia\nåœ¨ç»´åŸºé‡Œè¿˜æŒ‡å‡ºäº†æ¨¡å¼åŒ¹é…ä¸æ¨¡å¼è¯†åˆ«ï¼ˆPattern Recognitionï¼‰çš„ä¸€ä¸ªåŒºåˆ«ï¼Œå°±æ˜¯å‰è€…ä¸€èˆ¬æ¥è¯´æ˜¯ç²¾ç¡® çš„ï¼Œè¦ä¹ˆä¼šè¢«åŒ¹é…ï¼Œè¦ä¹ˆä¸ä¼šè¢«åŒ¹é…ï¼ˆå¯¹äºä¸€ä¸ªåˆ†æ”¯æ¥è¯´ï¼‰ï¼Œä¸ä¼šæœ‰ç½®ä¿¡åº¦å¤šå°‘çš„åŒ¹é…æƒ…å†µã€‚\nå¥½å¤„åœ¨å“ª ç¬¦åˆäººç±»æ€è€ƒæ–¹å¼çš„è®¾è®¡ ä½¿ç”¨ if å¹¶ä¸æ˜¯æˆ‘ä»¬çš„ç¬¬ä¸€æ€è€ƒæ–¹å¼ æ¯”å¦‚æˆ‘ä»¬ç°åœ¨æƒ³è¦è®¡ç®—æŸä¸€ä¸ªè§„åˆ™äºŒç»´å›¾å½¢çš„å‘¨é•¿ï¼Œè¿™ä¸ªå›¾å½¢å¯èƒ½æ˜¯çŸ©å½¢ã€åœ†å½¢æˆ–è€…ä¸‰è§’å½¢ï¼Œé‚£ä¹ˆæˆ‘ä»¬å†™ä»£ç çš„æ—¶å€™å¯èƒ½ä¼šè¿™æ ·å†™ï¼š\n1 2 3 4 5 6 7 8 9 10 11 let c; if (shape == Rectangle) { let len, wide = shape.len, shape.wide; c = (len + wide) * 2; } else if (shape == Circle) { let r = shape.r; c = pi * r * 2; } else if (shape == Triangle) { let {side1, side2, side3} = shape; c = side1 + side2 + side3; } è¿™ç§ä»£ç ä¸æˆ‘ä»¬çš„æ€è€ƒæ–¹å¼æœ‰ç›¸æ‚–çš„åœ°æ–¹ï¼š\næˆ‘ä»¬è¾¨è¯†ä¸€ä¸ªäºŒç»´å›¾å½¢çš„æ—¶å€™å¹¶ä¸æ˜¯ç”¨æ’é™¤æ³•çš„ï¼Œæˆ‘ä»¬å¯ä»¥ä¸€çœ¼çœ‹å‡ºæ¥è¿™æ˜¯ä»€ä¹ˆå›¾å½¢ï¼Œä¸éœ€è¦ä¸€æ­¥æ­¥æ’é™¤ è¿™ç§ä»£ç éœ€è¦å…ˆå‡è®¾ä¸€ä¸ªå‘¨é•¿æœªçŸ¥ï¼ˆå³å˜é‡cï¼‰çš„å›¾å½¢ï¼Œä¹‹åå†è¿›è¡Œå¡«å……ï¼Œé£é™©å°±æ˜¯å¯èƒ½ç›´åˆ°æœ€åçš„ else if éƒ½æ²¡åŒ¹é…ä¸Šï¼Œè¿™æ · c å°±æˆäº†ä¸€ä¸ªæœªåˆå§‹åŒ–çš„å€¼ï¼ˆUninitialized variableï¼‰ï¼Œä¼—æ‰€å‘¨çŸ¥è¿™ç§æƒ…å†µå¸¸å¸¸å¯¼è‡´ bug / undefined behavior å› æ­¤ï¼Œæˆ‘ä»¬å¸Œæœ›æœ‰ä¸€ç§æ›´åŠ é˜³é—´çš„å†™æ³•ï¼š\n1 2 3 4 5 let c = match shape { Rectangle {len, wide} =\u0026gt; (len+wide)*2, Circle {r} =\u0026gt; pi * r * 2, Triangle {side1, side2, side3} =\u0026gt; side1 + side2 + side3, }; å³ä½¿æ˜¯æ²¡å­¦è¿‡matchè¯­æ³•çš„äººåº”è¯¥ä¹Ÿèƒ½çœ‹æ‡‚è¿™æ ·çš„å†™æ³•ï¼Œè¯­ä¹‰ä¸Šå¯ä»¥ç†è§£ä¸ºï¼š\næˆ‘ä»¬æƒ³è®¡ç®—cï¼Œéœ€è¦å¯¹å®ƒçš„ç±»å‹è¿›è¡Œä¸€æ¬¡åŒ¹é…ï¼Œè€Œä¸”æˆ‘ä»¬å¯ä»¥çœ‹å‡ºæ˜¯ä¸‰ç§ç±»å‹ä¸­çš„ä¸€ç§ï¼Œç„¶åæˆ‘ä»¬å°†ä»å¯¹åº”çš„ç±»å‹é‡Œæå–å‡ºéœ€è¦çš„å‚æ•°å¹¶è¿›è¡Œè®¡ç®—ï¼ˆçœ‹æˆä¸€ä¸ªè§£æ„èµ‹å€¼ï¼‰ã€‚\nè¿™é‡Œæ˜¯å¦è§£å†³äº†ä¸Šè¿°å¯èƒ½å¯¼è‡´ubçš„é—®é¢˜ï¼Ÿç­”æ¡ˆæ˜¯åœ¨ç¼–è¯‘å™¨çš„å¸®åŠ©ä¸‹ï¼Œæ˜¯å¯ä»¥çš„ã€‚åœ¨ç±»å‹å®‰å…¨çš„è§„åˆ™ä¸‹ï¼Œæˆ‘ä»¬åº”å½“çŸ¥é“shapeçš„å–å€¼èŒƒå›´ï¼Œå¦‚æœæœ‰ç¬¬å››ç§å›¾å½¢ï¼Œé‚£ä¹ˆåº”å½“åœ¨æŸä¸ªåœ°æ–¹ï¼ˆæ¯”å¦‚ç±»å‹å£°æ˜ï¼‰ä¸Šæœ‰æ‰€ä½“ç°ï¼Œå¦‚æœä¸èƒ½åŒ¹é…å‡ºç»“æœï¼Œé‚£ä¹ˆè¿™æ¡matchè¡¨è¾¾å¼å°†ä¸çŸ¥é“è¿”å›ä»€ä¹ˆæ•°æ®ï¼Œåº”è¯¥æŠ›å‡ºé”™è¯¯ã€‚\nè™½ç„¶æ„Ÿè§‰ä¾‹å­æœ‰ç‚¹å°åˆ»æ„ï¼Œä½†æˆ‘è§‰å¾—å¯¹ç†è§£æ¨¡å¼åŒ¹é…çš„å¥½å¤„å¾ˆæœ‰å¸®åŠ©ã€‚\nã€æ¡ä»¶æ‰§è¡Œã€‘ä¸ã€æå–ã€‘çš„å…¼å¾— If åªèƒ½åšåˆ°æ¡ä»¶ç­›é€‰ï¼Œå´ä¸å¥½åšèµ‹å€¼ å½“ç„¶ä¹Ÿå¯ä»¥ç”¨ if (a = 114514) è¿™æ ·çš„æ··æ²Œå†™æ³•ï¼Œä½†æ˜¯åœ¨å®è·µä¸Šä¸€èˆ¬æ˜¯æ‹’ç»è¿™ç§å†™æ³•çš„ï¼Œå› ä¸ºè¿™å¹¶ä¸æ˜¯â€œæœ‰æ¡ä»¶â€åœ°èµ‹å€¼ï¼Œæ—©å·²ä¸è¢«æå€¡\nåœ¨ä¸Šé¢çš„ä¾‹å­ä¸­ï¼Œæˆ‘ä»¬åœ¨æ¯ä¸ªåˆ¤æ–­ååŠ ä¸Šä¸€è¡Œèµ‹å€¼ï¼ˆä¸åŠ ä¹Ÿè¡Œï¼Œä½†æ˜¯ä½ çš„æˆå‘˜è°ƒç”¨å°†ä¼šå¾ˆå•°å—¦ï¼‰ï¼Œå®é™…ä¸Šæ˜¯ä¸å¤ªæœ‰é¢å¤–ä¿¡æ¯é‡çš„è¯­å¥ï¼Œæˆ‘ç›¸ä¿¡ä¼˜é›…æµç•…çš„ä»£ç åº”å¦‚è‡ªç„¶è¯­è¨€ä¸€æ ·å¥½è¯»\nåœ¨ Rust é‡Œç¡®å®æœ‰å¸¦æ¡ä»¶çš„èµ‹å€¼ï¼Œè¯·è‡ªè¡Œå­¦ä¹  if let è¯­æ³•\nä»è¯­å¥åˆ°è¡¨è¾¾å¼ çš„è½¬å˜ è¡¨è¾¾å¼æä¾›äº†æ›´çµæ´»çš„å†™æ³• æ³¨æ„ç”„åˆ«è¯­å¥å’Œè¡¨è¾¾å¼ï¼ˆstatement vs expressionï¼‰\næ¥è§¦è¿‡ç¼–è¯‘åŸç†çš„è¯åº”è¯¥èƒ½è®°ä½åŒºåˆ«ï¼Œå¿˜è®°äº†ä¹Ÿä¸è¦ç´§ï¼Œç®€å•æ¦‚æ‹¬å°±æ˜¯ï¼š\nè¯­å¥æ˜¯ä¸€ä¸ªè¿‡ç¨‹ è¡¨è¾¾å¼æ˜¯ä¸€ä¸ªå€¼ æ¯”å¦‚ç®­å¤´å‡½æ•°() =\u0026gt; 1ï¼Œæˆ‘ä»¬å¶å°”æ‰“é¡ºæ‰‹åœ¨1åå¤šäº†ä¸ªåˆ†å·çš„æ—¶å€™ï¼Œç¼–è¯‘å™¨å¾€å¾€ä¼šå°è¯•çº æ­£ä½ ï¼Œå› ä¸º1;æ˜¯è¯­å¥ï¼Œè€Œä¸æ˜¯è¡¨è¾¾å¼ã€‚ å†æ¯”å¦‚æˆ‘ä»¬å†™ jsxï¼š\n1 2 3 4 // valid \u0026lt;div\u0026gt;{ condition ? \u0026#39;true\u0026#39;: \u0026#39;false\u0026#39; }\u0026lt;/div\u0026gt; // invalid \u0026lt;div\u0026gt; { if (condition) {\u0026#39;true\u0026#39;;} else { \u0026#39;false\u0026#39;; } } \u0026lt;/div\u0026gt; æˆ‘æƒ³ä¸Šé¢ä¸¤æ®µæƒ³è¡¨è¾¾çš„æ˜¯åŒä¸€ä¸ªè¯­ä¹‰ï¼šå¦‚æœæ¡ä»¶æˆç«‹ï¼Œé‚£ä¹ˆæ¸²æŸ“ \u0026lt;div\u0026gt;true\u0026lt;/div\u0026gt; ï¼Œå¦åˆ™æ¸²æŸ“ \u0026lt;div\u0026gt;false\u0026lt;/div\u0026gt;\nä½†æ˜¯æ˜¾ç„¶ä¸‹é¢çš„æ˜¯éæ³•çš„ï¼Œå› ä¸ºå®ƒæ˜¯ä¸€ä¸ª if è¯­å¥ï¼Œè€Œä¸æ˜¯è¡¨è¾¾å¼ï¼Œä¸å…·æœ‰å€¼ã€‚\nä»ä¸Šé¢ä¸¾è¿‡çš„å›¾å½¢å‘¨é•¿çš„ä¾‹å­é‡Œï¼Œæˆ‘ä»¬åœ¨matchåå¯ä»¥ç›´æ¥èµ‹å€¼ç»™cï¼Œå› æ­¤matchæ˜¯ä¸€ä¸ªè¡¨è¾¾å¼è€Œä¸æ˜¯å€¼\nè¿™ä¹Ÿæ˜¯è·Ÿswitchçš„ä¸€ä¸ªåŒºåˆ«ï¼Œå› ä¸ºswitchä¹Ÿæ˜¯ä¸€ä¸ªè¯­å¥è€Œä¸æ˜¯è¡¨è¾¾å¼ã€‚\nè¡¨è¾¾å¼æœ‰æ¯”è¯­å¥æ›´çµæ´»çš„ç‰¹ç‚¹ï¼Œå› ä¸ºexpressionæ˜¯statementçš„ç»„æˆï¼Œå½“è¡¨è¾¾å¼ä¸èµ‹å€¼ç»™å˜é‡çš„æ—¶å€™æˆ‘ä»¬ä¹Ÿå¯ä»¥å½“åšä¸€ä¸ªåªåŒ…å«ä¸€ä¸ªexpressionçš„statementï¼Œè¿™ç§è®¾è®¡æœ‰åŠ©äºæ›´ä¼˜é›…åœ°ç¼–ç¨‹ã€‚\næ€§èƒ½æœ‰æå‡å—ï¼Ÿ å®é™…ä¸Šæ¨¡å¼åŒ¹é…å¸¦æ¥çš„æ˜¯æŠ½è±¡å±‚é¢çš„å‡åï¼Œè®¡ç®—æœºæ€»å½’æ— æ³•åƒäººç±»ä¸€æ ·æ€è€ƒï¼Œå› æ­¤åœ¨æ€§èƒ½æ–¹é¢å¹¶ä¸æ˜¯å…¶ä¼˜åŠ¿ï¼Œåº•å±‚å®ç°å°±æ˜¯ä¸€å † if elseã€‚\nå¯ä»¥å‚è€ƒè¿™ä¸ªå›ç­”ï¼šHow is match implemented in a language like Rust?\nå…¶ä¸­çš„å›ç­”ç»™äº†è¿™ä¸ªä¾‹å­ï¼š\n1 2 3 4 5 6 7 8 9 10 11 enum Result { SingleResult(i32), TwoResults(i32, i32), Error } match someResult { Result::SingleResult(res) =\u0026gt; f(res), Result::TwoResults(res1, res2) =\u0026gt; g(res1, res2), Result::Error =\u0026gt; error() } ä¸Šé¢çš„ enum æ˜¯ Rust é‡Œçš„æšä¸¾å€¼ï¼Œä¸å¤§å¤šè¯­è¨€ä¸ä¸€æ ·çš„æ˜¯ï¼ŒRust çš„æšä¸¾å€¼é‡Œæ˜¯å¯ä»¥æºå¸¦é¢å¤–çš„ä¿¡æ¯çš„ï¼ˆå¯ä»¥æ˜¯ç»“æ„ã€æ•°ç»„ã€å…ƒç»„ã€åŸºæœ¬ç±»å‹ç­‰ç­‰ï¼‰\nå…¶å®ç°åçš„Cä»£ç å¤§æ¦‚å¦‚ä¸‹\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 struct Result { enum { SingleResult, TwoResults, Error } tag; union { struct { int arg1; } singleResult; struct { int arg1; int arg2; } twoResults; } value; }; switch(someResult.tag) { case SingleResult: { int res = someResult.value.singleResult.arg1; f(res); break; } case TwoResults: { int res1 = someResult.value.twoResults.arg1; int res2 = someResult.value.twoResults.arg2; g(res1, res2); break; } case Error: { error(); break; } } ä¸Šé¢çš„unionåœ¨TypeScripté‡Œæœ‰æ›´ä¸ºä¼˜é›…çš„è¡¨è¾¾ï¼ˆç¼ºç‚¹æ˜¯æ²¡æŠŠSingleResultä¸{arg1: number}ç»‘å®šèµ·æ¥ï¼‰ï¼š\n1 2 3 4 interface Result { tag: enum ResultTag { SingleResult, TwoResults, Error }, value: {arg1: number} | {arg1: number, arg2: number}, } è¿™ä¸ªæ¶‰åŠä»£æ•°æ•°æ®ç±»å‹ï¼ˆAlgebraic Data Typeï¼‰ï¼ŒæŒ‡å¯ä»¥è¿›è¡Œä»£æ•°è¿ç®—çš„ç±»å‹ï¼ˆæ¯”å¦‚ |ï¼Œ\u0026amp; ç­‰ï¼‰ï¼Œä¸æ˜¯è®²è¿°é‡ç‚¹ï¼Œè¯·è‡ªå·±æŸ¥é˜…èµ„æ–™ Algebraic_data_typeâ€”â€”wiki\nRust çš„ Option, Result\u0026lt;T, E\u0026gt; ä¸ match Option 1 2 3 4 enum Option\u0026lt;T\u0026gt; { None, Some(T), } å°–æ‹¬å·å¾ˆå®¹æ˜“çœ‹å‡ºæ¥æ˜¯æ³›å‹çš„æ„æ€ï¼Œè€Œ Some(T) ä»£è¡¨ä¸€ä¸ª Some ä¸­å¯ä»¥æºå¸¦ä¸€ä¸ªTç±»å‹çš„å€¼ï¼Œæ¯”å¦‚ Option è¿™ä¸ªæšä¸¾ç±»å‹åŒ…æ‹¬äº† None æˆ–è€… Some(i32) ä¸¤ç§æšä¸¾å€¼ï¼Œè€Œ Some(114514) å°±æ˜¯ä¸€ä¸ªOptionç±»å‹ã€‚\né‡æ–°æ€è€ƒä¸€ä¸‹ä¸Šé¢è¯´çš„æºå¸¦ä¸åŒç±»å‹å€¼çš„ enum çš„åº•å±‚å®ç°ï¼Œå°±æ˜¯é‚£ä¸ª unionï¼Œå°±èƒ½ç†è§£â€œæºå¸¦å€¼çš„æšä¸¾å€¼â€è¿™ä»¶äº‹ã€‚\nä¸€ä¸ª Option ç±»å‹çš„å€¼ä»£è¡¨å…¶å¤„äºæœ‰å€¼ï¼ˆSomeï¼‰è·Ÿæ²¡å€¼ï¼ˆNoneï¼‰çš„å åŠ æ€ï¼Œå¯¹å…¶è¿›è¡Œè§‚å¯Ÿï¼ˆåŒ¹é…ï¼‰å°†åå¡Œåˆ°å…¶ä¸­ä¸€ä¸ªçŠ¶æ€ XD\nå¦‚æœè§£æå‡ºæ¥è¿™ä¸ªå€¼æ˜¯Someï¼Œé‚£ä¹ˆæˆ‘ä»¬å°†å¯ä»¥ç±»å‹å®‰å…¨åœ° è®¿é—®åˆ°å…¶é‡Œé¢çš„å€¼ã€‚ï¼ˆæ„å‘³ç€ç¼–è¯‘å™¨å¯ä»¥å¸®åŠ©ä½ è§„èŒƒè¡Œä¸ºï¼Œä¹Ÿå¯ä»¥å¸®ä½ åšå¥½è¯­æ³•æç¤ºï¼Œè®¿é—®é‡Œé¢çš„å€¼ä¸€å®šæ˜¯ç±»å‹å®‰å…¨çš„ï¼Œå³ä¸ä¼šåœ¨ç±»å‹ä¸Šç¿»è½¦ï¼‰\nResult\u0026lt;T, E\u0026gt; 1 2 3 4 enum Result\u0026lt;T, E\u0026gt; { Ok(T), Err(E), } æˆ‘è®¤ä¸ºä¸Šé¢è®²è¿‡ Option åï¼Œç†è§£ Result åº”è¯¥ä¹Ÿå¾ˆç®€å•ï¼Œä¸€ä¸ª Result ç±»å‹çš„å€¼å¤„äºæˆåŠŸä¸å¤±è´¥çš„å åŠ æ€ï¼Œå¦‚æœæˆåŠŸï¼Œå°±èƒ½ç±»å‹å®‰å…¨åœ°è®¿é—®å…¶ä¸­çš„ T ç±»å‹ä½†æ— æ³•è®¿é—® E ç±»å‹çš„å€¼ï¼ˆunion åªèƒ½åŒæ—¶å­˜åœ¨ä¸€ä¸ªå¯¹å§ï¼‰ï¼Œå¦‚æœå¤±è´¥ï¼Œæˆ‘ä»¬èƒ½å®‰å…¨åœ°è®¿é—®é”™è¯¯é‡Œçš„ E ç±»å‹ï¼Œæ­¤æ—¶åˆæ— æ³•è®¿é—® T ç±»å‹çš„å€¼ã€‚\nå¾ˆæ˜æ˜¾è¿™ä¸ªå¯ä»¥ç”¨åœ¨é”™è¯¯å¤„ç†çš„é¢†åŸŸï¼Œæˆ‘è§‰å¾—ä¼šå¾ˆå®¹æ˜“è”æƒ³åˆ°å¤§é“è‡³ç®€çš„ go\n1 2 3 4 5 res, err := function() if err != nil { // handle the error } use(res) å¶å°”èƒ½è§åˆ° gopher ç®¡è‡ªå·±å« if err != nil å·¥ç¨‹å¸ˆï¼Œå› ä¸ºä¸€ä¸ªå¯èƒ½å‘ç”Ÿé”™è¯¯çš„å‡½æ•°å¾€å¾€æ˜¯è¿™ä¹ˆè¿”å›æ•°æ®çš„ï¼Œé€šè¿‡æ ¡éªŒæ˜¯å¦æœ‰ err æ¥åˆ¤æ–­æˆåŠŸä¸å¦ï¼Œè¿™ç§å¤„ç†æ–¹å¼çš„ç¼ºé™·é™¤äº†å†™èµ·æ¥å¾ˆå•°å—¦å¤–ï¼Œè¿˜æœ‰ä¸€ä¸ªç¼ºé™·ï¼Œå°±æ˜¯å¤„ç†å¯èƒ½ä¸åˆ°ä½ã€‚\n1 2 3 4 5 6 7 res, err := function() if err != nil { fmt.println(\u0026#34;some error|\u0026#34;, err) // forget to return! } // use an invalid res! use(res) å®é™…ä¸Šï¼Œè¿™ç§é”™è¯¯å¤„ç†å…¨å‡­è‡ªè§‰ï¼Œæˆ‘ä»¬å°†æ­£ç¡®å¤„ç†çš„ç»“æœä¸é”™è¯¯å¤„ç†çš„å¤±è´¥åŸå› ä¸€èµ·è¿”å›ï¼Œåªèƒ½é€šè¿‡ç¨‹åºå‘˜è‡ªè§‰å»å¤„ç†è¿™ç§å…³ç³»ï¼Œä½†å¶å°”å¯èƒ½åœ¨å¤„ç† err åï¼Œå¿˜è®° return äº†ï¼Œè€Œä¸”ä¹Ÿæ²¡å¯¹ res è¿›è¡Œå†å¤„ç†ï¼Œå¯¼è‡´æ‰§è¡Œæµç»§ç»­è¿›è¡Œä¸‹å»ï¼Œè®¿é—®äº†ä¸è¯¥è®¿é—®çš„resï¼ˆæ­¤æ—¶æ— æ³•çŸ¥é“æ˜¯ä»€ä¹ˆå€¼ï¼‰ï¼Œå°†ä¼šäº§ç”Ÿ ubã€‚\nè€Œ Result æ˜¯è§£å†³è¿™ä¸ªé—®é¢˜çš„åˆ©å™¨ï¼Œå› ä¸ºå¤„äºæˆåŠŸçŠ¶æ€çš„ç»“æœæ— æ³•è®¿é—®å¤±è´¥çŠ¶æ€çš„ç±»å‹ï¼Œè€Œå¤±è´¥çš„ç»“æœæ— æ³•è®¿é—®æˆåŠŸæ—¶çš„æ•°æ®ï¼Œå³ä½¿ä»£ç è¿˜æ²¡å¼€å§‹è·‘ï¼Œä½ ä¹ŸçŸ¥é“è‚¯å®šä¸ä¼šå‡ºé”™ã€‚\nå¸¸ç”¨çš„é”™è¯¯å¤„ç†è¿˜æœ‰try catchç³»åˆ—ï¼Œä¾ç„¶éœ€è¦é è‡ªè§‰ï¼Œå¸¸æœ‰å¿˜è®°åœ¨throwableçš„å‡½æ•°å¤–åŠ tryï¼Œå¯¼è‡´æ— æ³•æ­£å¸¸æ•è·åˆ°é”™è¯¯ï¼ˆUncaught errorï¼‰çš„äº‹å‘ç”Ÿï¼ˆæ¯”å¦‚å¯¹å†…å±‚å‡½æ•°ä¸äº†è§£çš„è¯å°±æ— æ³•çŸ¥é“æ˜¯å¦throwableï¼Œè™½ç„¶å¸¸æœ‰å…œåº•çš„æœ€å¤–å±‚tryï¼Œä½†æ˜¯åœ¨æŠ›å‡ºé”™è¯¯åå´ä¼šä¸­æ–­æ‰§è¡Œæµï¼Œæ— æ³•è¿”å›åˆ°æŸä¸ªæƒ³å›å»çš„åœ°æ–¹ï¼Œçµæ´»æ€§æ¯”è¾ƒä½ï¼Œè€Œä¸”å†™èµ·æ¥ç¼©è¿›ç¡®å®ä¸æ€ä¹ˆå¥½çœ‹ã€‚\nğŸ¤”Promiseå¯¹è±¡ä¸ä¸Šé¢æåˆ°çš„ Optionã€Result æºè‡ªåŒæ ·çš„è®¾è®¡æ€æƒ³ï¼Œå…ˆå å‘ï¼Œåœ¨è¿è¡Œæ—¶å†ç¡®å®šè¿™ä¸ªå‘é‡Œåº”å½“å¡«å…¥å•¥ï¼Œä¸åŒçš„ç»“æœçŠ¶æ€ä¹‹é—´æ˜¯éš”ç¦»çš„ï¼Œä»è€Œåšåˆ°ã€ç¼–è¯‘æœŸç¡®å®šçš„ã€‘ç±»å‹å®‰å…¨ï¼ŒåŒæ—¶ä¹Ÿæ–¹ä¾¿æ›´ç›´è§‚çš„é“¾å¼è°ƒç”¨ï¼Œåœ¨å‡½æ•°å¼ç¼–ç¨‹ä¸­ï¼Œè¿™ç§æ¦‚å¿µå« Monadï¼ˆå•å­ï¼‰ã€‚ wiki-Monad\nmatch æ¨¡å¼æ˜¯ Rust ä¸­ç‰¹æ®Šçš„è¯­æ³•ï¼Œå®ƒç”¨æ¥åŒ¹é…ç±»å‹ä¸­çš„ç»“æ„ï¼Œæ— è®ºç±»å‹æ˜¯ç®€å•è¿˜æ˜¯å¤æ‚ã€‚ç»“åˆä½¿ç”¨æ¨¡å¼å’Œ match è¡¨è¾¾å¼ä»¥åŠå…¶ä»–ç»“æ„å¯ä»¥æä¾›æ›´å¤šå¯¹ç¨‹åºæ§åˆ¶æµçš„æ”¯é…æƒã€‚æ¨¡å¼ç”±å¦‚ä¸‹ä¸€äº›å†…å®¹ç»„åˆè€Œæˆï¼š\nå­—é¢å€¼ è§£æ„çš„æ•°ç»„ã€æšä¸¾ã€ç»“æ„ä½“æˆ–è€…å…ƒç»„ å˜é‡ é€šé…ç¬¦ å ä½ç¬¦ é€šè¿‡ä»¥ä¸‹ä»£ç æ¥ç†è§£ï¼š 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 enum Message { Quit, Move { x: i32, y: i32 }, Write(String), ChangeColor(i32, i32, i32), } fn main() { let msg = Message::ChangeColor(0, 160, 255); match msg { Message::Quit =\u0026gt; { println!(\u0026#34;The Quit variant has no data to destructure.\u0026#34;) } Message::Move =\u0026gt; { println!( \u0026#34;Move in the x direction {} and in the y direction {}\u0026#34;, x, y ); } Message::Write(text) =\u0026gt; println!(\u0026#34;Text message: {}\u0026#34;, text), Message::ChangeColor(r, g, b) =\u0026gt; println!( \u0026#34;Change the color to red {}, green {}, and blue {}\u0026#34;, r, g, b ), } } ä»£ç æ¥è‡ª æ¨¡å¼ä¸æ¨¡å¼åŒ¹é… - Rust ç¨‹åºè®¾è®¡è¯­è¨€ ç®€ä½“ä¸­æ–‡ç‰ˆ\nå…¶å®å°±æ˜¯åŒ¹é…æˆåŠŸåè¿˜èƒ½æ•è·å…¶ä¸­çš„å€¼ã€‚\nOption in TS å‰é¢è®²äº†éå¸¸éå¸¸å¤šçš„é“ºå«ï¼Œç»ˆäºåˆ°æ­£é¢˜äº†ï¼Œå¦‚ä½•åœ¨ TS é‡Œå®ç°ä¸Šé¢è®²äº†ä¸€å¤§é€šçš„è¿™äº›ç‰¹å¾ï¼Ÿ ä¸‹é¢çš„å†…å®¹æ˜¯å¯¹ä¸€ä¸ªå¼€æºå®ç° oxide.ts çš„æºç è§£è¯» ä»“åº“åœ°å€ï¼Œæºç æµ‹è¯•ã€æ–‡æ¡£å…¨è¦†ç›–ï¼Œå ªç§°ä¼˜é›…çš„ä»“åº“ï¼Œä¹Ÿå¾ˆæ¨èé˜…è¯»ã€‚\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 // src/common.ts export const SymbolT = Symbol(\u0026#39;T\u0026#39;); export const SymbolVal = Symbol(\u0026#39;Val\u0026#39;); // src/option.ts export type Some\u0026lt;T\u0026gt; = OptionType\u0026lt;T\u0026gt; \u0026amp; { [SymbolT]: true }; export type None = OptionType\u0026lt;never\u0026gt; \u0026amp; { [SymbolT]: false }; class OptionType\u0026lt;T\u0026gt; { readonly [SymbolT]: boolean; readonly [SymbolVal]: T; constructor(val: T, some: boolean) { this[SymbolT] = some; this[SymbolVal] = val; } } Option çš„æ ¸å¿ƒæ˜¯å®ç°ä¸€ä¸ª OptionTypeï¼Œè€Œ Some ä¸ None å‡æºè‡ª OptionTypeã€‚\nSymbolT å’Œ SymbolVal æ˜¯ä¸¤ä¸ª Symbol ç±»å‹çš„å€¼ï¼Œæ„å‘³ç€ OptionType é‡Œå…¶ä»–çš„é”®ä¸ä¼šä¸è¿™ä¿©å‘ç”Ÿå†²çªï¼ˆjsçš„ç±»å‹å› ä¸ºä½¿ç”¨å­—ç¬¦ä¸²ä½œæˆå‘˜åçš„ç¼˜æ•…å¸¸æœ‰å†²çªå‘ç”Ÿçš„æƒ…å†µï¼Œæ¯”å¦‚ obj[\u0026rsquo;toString\u0026rsquo;] å°±ä¸æŸä¸ªå†…ç½®æ–¹æ³•å†²çªäº†ï¼‰\næœ‰äº† Some å’Œ None ç±»å‹ï¼Œå¦‚ä½•åˆ›å»ºä¸€ä¸ªè¿™ä¸ªç±»å‹çš„å€¼ï¼Ÿé€šè¿‡æ„é€ å‡½æ•°å°±è¡Œäº†\n1 2 3 4 5 6 7 8 export const None = Object.freeze( new OptionType\u0026lt;never\u0026gt;(undefined as never, false) ) as None; /// ä½¿ç”¨ Some() export function Some\u0026lt;T\u0026gt;(val: T): Some\u0026lt;T\u0026gt; { return new OptionType(val, true) as Some\u0026lt;T\u0026gt;; } Tips: å˜é‡åè·Ÿç±»å‹åæ˜¯ä¸å†²çªçš„ï¼Œæ„å‘³ç€ä¸‹é¢çš„ä»£ç æˆç«‹ã€‚\n1 2 3 4 type a = number; function a(): a { return 1; } Object.freeze çš„ä½œç”¨æ˜¯åˆ›å»ºä¸€ä¸ªæ— æ³•å¢åˆ æ”¹å­—æ®µçš„å¯¹è±¡\næˆ‘ä»¬é€šè¿‡ä¸‹é¢çš„æ–¹å¼åˆ†åˆ«åˆ›å»ºå˜é‡\nåˆ†åˆ«æ‰“å°a, bï¼Œå¯ä»¥å¾—åˆ°ä»¥ä¸‹ç»“æœ\nåŸºäºSymbol(Val)å’ŒSymbol(T)è¿™ä¸¤ä¸ªå­—æ®µï¼Œæˆ‘ä»¬å¯ä»¥æ„é€ å‡ºè®¸å¤šæœ‰ç”¨çš„æ–¹æ³•ï¼Œä¸ºäº†æ‰¾ä¸€ä¸ªæ— æ³•é™æ€ç¼–è¯‘æœŸç¡®å®šçš„ä¾‹å­ï¼ˆå³è¿è¡Œåæ‰çŸ¥é“æˆä¸æˆåŠŸï¼‰ï¼Œæˆ‘å…ˆæ„é€ ä¸€ä¸ª Rusty ï¼ˆæœ‰ Rust é£æ ¼çš„ï¼‰çš„å¤„ç†å‡½æ•°åœ¨è¿™ã€‚\n1 2 3 4 5 6 7 function rustyParseInt(str: string): Option\u0026lt;number\u0026gt; { const res = parseInt(str); if (isNaN(res)) { return None; } return Some(res); } ä¸Šè¿°å‡½æ•°æ˜¯å¯¹ parseIntçš„åŒ…è£…ï¼ŒåŸç”Ÿ parseInt åœ¨è§£æå¤±è´¥æ—¶ä¼šè¿”å›ä¸€ä¸ª NaNï¼Œæˆ‘ä»¬å°†NaNæ”¹æˆNoneï¼Œè§£ææˆåŠŸåˆ™è¿”å›Some\nçœ‹ä¸‹é¢çš„æ–¹æ³•ï¼š\n1 2 3 4 5 6 7 8 9 10 11 /// Optionå¿…é¡»æ˜¯ä¸€ä¸ªSomeï¼Œå¦åˆ™æŠ›å‡ºé”™è¯¯ï¼ˆåœ¨rusté‡Œæ˜¯panicï¼‰ expect(this: Option\u0026lt;T\u0026gt;, msg: string): T { if (this[SymbolT]) { return this[SymbolVal]; } else { throw new Error(msg); } } // example.ts const a: number = rustyParseInt(\u0026#39;would_fail\u0026#39;).expect(\u0026#39;fail_reason\u0026#39;); expectå¯ä»¥è§†ä¸ºå¯¹ã€æŸä¸ªOptionçš„å®ä¾‹åº”æ˜¯Someã€‘çš„æ–­è¨€ï¼Œå¹¶è¿”å›å…¶ä¸­çš„ç±»å‹ï¼Œå¦‚æœä¸æ˜¯Someå°†æŠ›å‡ºé”™è¯¯ã€‚\nè¿è¡Œexample.tsåå°†ä¼šæŠ›å‡ºç†ç”±ä¸ºfail_reasonçš„é”™è¯¯\nç”±expectï¼Œåˆå¯ä»¥åŒ…è£…å‡ºå¤šç§æ–¹æ³•\n1 2 3 unwrap(this: Option\u0026lt;T\u0026gt;): T; unwrapOr(this: Option\u0026lt;T\u0026gt;, def: T): T; unwrapOrElse(this: Option\u0026lt;T\u0026gt;, f: () =\u0026gt; T): T; å¯¹åŸæœ‰ API çš„å®‰å…¨å°è£… è¯¥åº“æä¾›äº† safe å‡½æ•°ï¼Œç”¨äºå®‰å…¨åœ° æ•è·ä¸€ä¸ªåŒæ­¥/å¼‚æ­¥å‡½æ•°çš„ç»“æœä¸ºOptionï¼Œè€Œä¸ä¼šæŠ›å‡ºé”™è¯¯æˆ–è€…å¼•å‘rejectã€‚\nä¸‹é¢æˆªå›¾å³safeçš„å®ç°ä»£ç ï¼Œvscodeèƒ½åœ¨thené‡Œåšå‡ºæ­£ç¡®çš„ç±»å‹æ¨æ–­ã€‚\nä¹ä¸€çœ‹ä¸Šé¢æœ‰ä¸‰ä¸ªsafeï¼ŒJS/TS å¹¶ä¸æ”¯æŒå‡½æ•°é‡è½½ï¼ˆFunction Overrideï¼‰ï¼Œè¿™æ˜¯ TS çš„ Function Overload çš„ç‰¹æ€§ï¼Œè¯¦è§æ–‡æ¡£ functions overloadã€‚\næ„æ€æ˜¯ï¼Œä¸Šé¢ä¸¤ä¸ªsafeæ˜¯å®é™…ä½¿ç”¨æ—¶çš„åº”å½“çº¦æŸçš„å‡½æ•°ç±»å‹ï¼Œæœ€ä¸‹é¢çš„safeæ˜¯å¯¹ä¸Šé¢ä¸¤ç§ç­¾åçš„å…¼å®¹æ€§å®ç°ã€‚\n1 2 3 4 5 6 7 8 9 10 11 12 13 function makeDate(timestamp: number): Date; function makeDate(m: number, d: number, y: number): Date; function makeDate(mOrTimestamp: number, d?: number, y?: number): Date { if (d !== undefined \u0026amp;\u0026amp; y !== undefined) { return new Date(y, mOrTimestamp, d); } else { return new Date(mOrTimestamp); } } const d1 = makeDate(12345678); const d2 = makeDate(5, 5, 5); const d3 = makeDate(1, 3); // No overload expects 2 arguments, but overloads do exist that expect either 1 or 3 arguments. ä¸Šé¢æ˜¯å®˜æ–¹çš„ä¾‹å­ï¼Œçœ‹ä¸€ä¸‹å°±æ‡‚äº†ï¼Œd1, d2 éƒ½å¯ä»¥è¢«æ­£å¸¸ç¼–è¯‘ï¼Œd3 åˆ™é€šè¿‡ä¸äº†ç±»å‹æ£€æŸ¥ï¼Œå°½ç®¡ç¬¦åˆç¬¬ä¸‰ä¸ªmakeDateçš„å‡½æ•°ç­¾åã€‚\nå›åˆ°ä¸Šé¢ safe çš„å®ç°ï¼ˆä¸å‰é¢æ˜¯åŒä¸€å¼ å›¾ï¼Œæ–¹ä¾¿è§‚çœ‹ï¼‰ï¼Œç¬¬ä¸€ä¸ªç­¾åæ¥å—çš„æ˜¯ä¸€ä¸ªåŒæ­¥å‡½æ•°åŠè¯¥å‡½æ•°çš„å‚æ•°ï¼Œé€šè¿‡ PromiseLike æ¥çº¦æŸæ˜¯å¦å¼‚æ­¥å‡½æ•°ï¼Œæ˜¯åˆ™è¦æ±‚è¿”å›å€¼ä¸ºneverç±»å‹ï¼Œä»£è¡¨ä¸€ä¸ªä¸ä¼šè¿”å›çš„å‡½æ•°ï¼ˆä¸€å®šä¼šthrowï¼Œæˆ–æ˜¯æ— é™å¾ªç¯ï¼‰ï¼Œæ—¢ç„¶æ— æ³•è¿”å›ä¹Ÿå°±ä¸ä¼šéœ€è¦safeåŒ…è£…è¿”å›å€¼ã€‚\nä¸€ä¸ª PromiseLike æ¥å£è¦æ±‚å®ç° then(onfulfilled, onerjected)ï¼Œå…·ä½“çœ‹TSçš„å®˜æ–¹æ–‡æ¡£ PromiseLike æ¥å£æ–‡æ¡£\nç¬¬äºŒä¸ªç­¾åæ¥å—ä¸€ä¸ª Promise å¯¹è±¡ä½œä¸ºå‚æ•°ï¼Œå…¶å®å°±æ˜¯å¼‚æ­¥å‡½æ•°æ‰§è¡Œåçš„è¿”å›å€¼ã€‚è¿”å›ä¸€ä¸ª Promise\u0026lt;Option\u0026gt;çš„ç»“æœï¼Œæ³¨æ„ä¸€ä¸ªOption\u0026lt;Promise\u0026gt;çš„ç±»å‹æ˜¯æ²¡æœ‰å®ç”¨æ„ä¹‰çš„ï¼Œå› ä¸ºä¸ç®¡resolveè¿˜æ˜¯rejectï¼Œéƒ½ä¼šå¾—åˆ°ä¸€ä¸ªSomeç»“æœï¼Œæ‰€ä»¥ä¸€ä¸ªå®ç”¨çš„åŒ…è£…åº”å½“æ˜¯ Promise\u0026lt;Some\u0026gt;ä¸Promiseï¼Œå¯¹åº”äº†resolveä¸rejectçš„ç»“æœã€‚\nå®ç°ä¸Šå¾ˆç®€å•ï¼ŒæŠŠ throwã€reject åŒ…è£…æˆ None, æŠŠ resolve å’Œæ­£å¸¸æ‰§è¡ŒåŒ…è£…ä¸º Some å³å¯ã€‚\nå…¶ä»–çš„æ–¹æ³• Option æä¾›äº†ä¸€äº›å…¶ä»–çš„æ–¹æ³•ï¼Œå®ç°éƒ½å¾ˆç®€å•ï¼Œæ„ä¹‰ä¹Ÿæ¸…æ¥šæ‰€ä»¥ä¸è¯¦ç»†ä»‹ç»ã€‚\n1 2 3 isNone() isSome() map\u0026lt;U\u0026gt;(this: Option\u0026lt;T\u0026gt;, f: (val: T) =\u0026gt; U): Option\u0026lt;U\u0026gt; Result\u0026lt;T, E\u0026gt; in TS Result è·Ÿ Option çš„å®ç°å°±æ²¡æœ‰å¤ªå¤§å·®åˆ«äº†ï¼Œé™¤äº† Result åœ¨å¤±è´¥æ—¶å¯ä»¥æºå¸¦é”™è¯¯ä¿¡æ¯\n1 2 3 4 5 6 7 8 9 10 11 export type Ok\u0026lt;T\u0026gt; = ResultType\u0026lt;T, never\u0026gt;; export type Err\u0026lt;E\u0026gt; = ResultType\u0026lt;never, E\u0026gt;; export class ResultType\u0026lt;T, E\u0026gt; { readonly [SymbolT]: boolean; readonly [SymbolVal]: T | E; constructor(val: T | E, ok: boolean) { this[SymbolVal] = val; this[SymbolT] = ok; } } Ok ä¸ Err çš„æ„é€ æ–¹å¼ä¹Ÿå¾ˆç®€å•\n1 2 3 4 5 6 export function Ok\u0026lt;T\u0026gt;(val: T): Ok\u0026lt;T\u0026gt; { return new ResultType\u0026lt;T, never\u0026gt;(val, true); } export function Err\u0026lt;E\u0026gt;(val: E): Err\u0026lt;E\u0026gt; { return new ResultType\u0026lt;never, E\u0026gt;(val, false); } match in TS oxide.ts å¯¹ match çš„å®ç°åº”è¯¥æ˜¯æœ€å¥½ç©çš„åœ°æ–¹ï¼Œåœ¨çœ‹å¦‚ä½•å®ç°ä¹‹å‰ï¼Œå…ˆçœ‹å®ç°äº†æ€æ ·çš„åŠŸèƒ½\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 // mapped matching const num = Option(10); const res = match(num, { Some: (n) =\u0026gt; n + 1, _: () =\u0026gt; 0, }); assert.equal(res, 11); // chained matching function matchArr(arr: number[]): string { return match(arr, [ [[1], \u0026#34;1\u0026#34;], [[2, (x) =\u0026gt; x \u0026gt; 10], \u0026#34;2, \u0026gt; 10\u0026#34;], [[_, 6, 9, _], (a) =\u0026gt; a.join(\u0026#34;, \u0026#34;)], () =\u0026gt; \u0026#34;other\u0026#34;, ]); } assert.equal(matchArr([1, 2, 3]), \u0026#34;1\u0026#34;); assert.equal(matchArr([2, 12, 6]), \u0026#34;2, \u0026gt; 10\u0026#34;); assert.equal(matchArr([2, 4, 6]), \u0026#34;other\u0026#34;); assert.equal(matchArr([3, 6, 9]), \u0026#34;other\u0026#34;); assert.equal(matchArr([3, 6, 9, 12]), \u0026#34;3, 6, 9, 12\u0026#34;); Mapped matching å®ç°äº†å¯¹ Option / Result çš„åŒ¹é…ï¼Œ Chained matching å®ç°äº†æ›´åŠ çµæ´»ã€å®šåˆ¶åŒ–çš„åŒ¹é…ï¼Œå¯ä»¥åŒ¹é…å…·ä½“çš„å€¼ã€ä¹Ÿå¯ä»¥ä½¿ç”¨è§„åˆ™å»åŒ¹é… å®ç° Match çš„ç›¸å…³å®ç°é•¿ä¸‹é¢è¿™æ ·ï¼š\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 export const Default: any = () =\u0026gt; { throw new Error(\u0026#34;Match failed (exhausted)\u0026#34;); }; export function match\u0026lt;T, U\u0026gt;( val: T, pattern: MappedBranches\u0026lt;T, U\u0026gt; | ChainedBranches\u0026lt;T, U\u0026gt; ): U { return matchDispatch(val, pattern, Default); } function matchDispatch\u0026lt;T, U\u0026gt;( val: T, pattern: ChainedBranches\u0026lt;T, U\u0026gt; | MappedBranches\u0026lt;T, U\u0026gt;, defaultBranch: DefaultBranch\u0026lt;U\u0026gt; ): U { if (Array.isArray(pattern)) { return matchChained(val, pattern, defaultBranch); } else if (isObjectLike(pattern)) { return matchMapped(val, pattern, defaultBranch); } throwInvalidPattern(); } matchæ¥æ”¶å¾…åŒ¹é…çš„å€¼è·Ÿåˆ†æ”¯çš„æ¨¡å¼ä½œä¸ºå‚æ•°ï¼Œç„¶åè°ƒç”¨ matchDispatchã€‚\nåˆ†æ”¯æœ‰mappedå’Œchainedä¸¤ç§ï¼Œé€šè¿‡ isArray å’Œ isObjectLike åŒºåˆ†ï¼Œç„¶ååˆ†åˆ«è¿›å…¥ mapped å’Œ chained çš„å¤„ç†é€»è¾‘ã€‚\nmapped matchMapped åªæ”¯æŒå¯¹ Option å’Œ Result è¿›è¡ŒåŒ¹é…ï¼Œç„¶åå¯¹ pattern ä¸­çš„é¡¹è¿›è¡ŒåŒ¹é…ã€‚\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 function matchMapped\u0026lt;T, U\u0026gt;( val: T, pattern: OptionMapped\u0026lt;any, U\u0026gt; \u0026amp; ResultMapped\u0026lt;any, any, U\u0026gt;, defaultBranch: DefaultBranch\u0026lt;U\u0026gt; ): U { if (Option.is(val)) { if (val[SymbolT]) { if (pattern.Some) { if (typeof pattern.Some === \u0026#34;function\u0026#34;) { // å¯¹äº Some ç±»å‹ï¼Œå¦‚æœå…¶åŒ¹é…åè·Ÿçš„æ˜¯ functionï¼Œè¯´æ˜æ˜¯å¯¹å€¼çš„ä»»æ„åŒ¹é… return pattern.Some(val[SymbolVal]); } else { // ä¸æ˜¯functionï¼Œè¯´æ˜å¯èƒ½æœ‰æ›´è¿›ä¸€æ­¥çš„åŒ¹é…ï¼ˆå…·ä½“çš„å€¼ã€ä½ç½®ç­‰ç­‰ï¼‰ï¼Œåˆ™å†æ¬¡è°ƒç”¨dispatchå¯¹å€¼è¿›è¡Œæ›´ç»†åŒ–çš„åŒ¹é…ï¼Œæ³¨æ„çš„æ˜¯ç¬¬ä¸‰ä¸ªå‚æ•°defaultBranchï¼Œå¦‚æœSomeä¸­æä¾›äº†é»˜è®¤åˆ†æ”¯ï¼Œé‚£ä¹ˆè¿›å…¥ï¼Œå¦åˆ™ä¸è¿›å…¥è¯¥åˆ†æ”¯è€Œæ˜¯ä½¿ç”¨å¤–å±‚çš„é»˜è®¤åˆ†æ”¯ï¼ˆå³æœ€å¤–å±‚çš„ _: () =\u0026gt; somethingï¼‰ return matchDispatch( val[SymbolVal], pattern.Some, typeof pattern._ === \u0026#34;function\u0026#34; ? pattern._ : defaultBranch ); } } } else if (typeof pattern.None === \u0026#34;function\u0026#34;) { // å¯¹NoneåŒ¹é…çš„å¤„ç† return pattern.None(); } } else if (Result.is(val)) { // å¯¹Resultåˆ†æ”¯çš„å¤„ç†ï¼Œè·ŸOptionåŸºæœ¬ç›¸åŒ const Branch = val[SymbolT] ? pattern.Ok : pattern.Err; if (Branch) { if (typeof Branch === \u0026#34;function\u0026#34;) { return Branch(val[SymbolVal]); } else { // æ—¢æ²¡åœ¨Optionä¸­åŒ¹é…åˆ°ä¹Ÿæ²¡åœ¨Resulté‡ŒåŒ¹é…åˆ°ï¼Œè¿›å…¥é»˜è®¤åˆ†æ”¯ï¼Œå¦‚æœæä¾›äº† _ çš„åŒ¹é…å°±æ‰§è¡Œè‡ªå®šä¹‰çš„é»˜è®¤åˆ†æ”¯ï¼Œå¦åˆ™è¿›å…¥å‚æ•°çš„defaultBranch // æœ€ä¸Šé¢çš„ defaultBranch ä¼ å…¥äº†ä¸€ä¸ªä¼šæŠ›å‡ºå¼‚å¸¸çš„å‡½æ•°Defaultï¼Œå³ä»£è¡¨æ²¡æœ‰åˆ†æ”¯èƒ½å¤„ç†valï¼Œè¿™æ˜¯ä¸å¯æ¥å—çš„ return matchDispatch( val[SymbolVal], Branch, typeof pattern._ === \u0026#34;function\u0026#34; ? pattern._ : defaultBranch ); } } } else { throwInvalidPattern(); } return typeof pattern._ === \u0026#34;function\u0026#34; ? pattern._() : defaultBranch(); } chained Chained mapping æ”¯æŒæ›´åŠ çµæ´»çš„æ¨¡å¼åŒ¹é…ï¼Œä¸‹é¢å±•ç¤ºéƒ¨åˆ†åŒ¹é…çš„æ–¹å¼\n1 2 3 4 5 6 7 8 9 10 const res = match(input, [ [1, \u0026#34;number\u0026#34;], // åŒ¹é…å‡†ç¡®çš„å€¼ [testObj, \u0026#34;object\u0026#34;], // åŒ¹é…å‡†ç¡®çš„å¯¹è±¡ï¼ˆæµ…ï¼ŒåŒä¸€ä¸ªå¯¹è±¡æ‰èƒ½åŒ¹é…ä¸Šï¼‰ [\u0026#34;test\u0026#34;, (val) =\u0026gt; `string ${val}`], // åŒ¹é…å‡†ç¡®çš„å€¼ï¼Œå¹¶ä½¿ç”¨å‡½æ•°ä½œä¸ºResultï¼Œä»¥æ•è·åˆ° match çš„ input å€¼ [(val) =\u0026gt; val === true, \u0026#34;true\u0026#34;], // æä¾› filter ä½œä¸ºåŒ¹é…æ¡ä»¶ [(val) =\u0026gt; (val as number) \u0026gt; 5, (val) =\u0026gt; `num ${val}`], // æä¾› filter ä¸ºåŒ¹é…æ¡ä»¶ï¼Œå¹¶ä½¿ç”¨å‡½æ•°ä½œä¸º Result æ•è· input [Fn(returnTrue), \u0026#34;fn true\u0026#34;], // åŒ¹é…ä¸€ä¸ªå‡½æ•° returnTrueï¼Œä½¿ç”¨ Fn() åŒ…è£…ä»¥è·Ÿ filter åŒºåˆ†å¼€ [Fn(returnFalse), \u0026#34;fn false\u0026#34;], // åŒ¹é…ä¸€ä¸ªå‡½æ•° returnFalseï¼Œä½¿ç”¨ Fn() åŒ…è£…ä»¥è·Ÿ filter åŒºåˆ†å¼€ () =\u0026gt; \u0026#34;default\u0026#34;, // é»˜è®¤åŒ¹é…ï¼Œå¦‚æœæ²¡æ³•åŒ¹é…åˆ°ä¸Šè¿°é¡¹å°†æ‰§è¡Œ ]); 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 type ChainedBranches\u0026lt;T, U\u0026gt; = | Branch\u0026lt;T, U\u0026gt;[] | [...Branch\u0026lt;T, U\u0026gt;[], DefaultBranch\u0026lt;U\u0026gt;]; function matchChained\u0026lt;T, U\u0026gt;( val: T, pattern: ChainedBranches\u0026lt;T, U\u0026gt;, defaultBranch: DefaultBranch\u0026lt;U\u0026gt; ): U { // éå† chianed branchesï¼Œå¾—åˆ°æ¯ä¸ªåˆ†æ”¯ for (const branch of pattern) { // åˆ†æ”¯å…è®¸æ¥å—å‡½æ•°ä½œä¸ºåˆ†æ”¯ï¼Œé™å®šä¸ºç»è¿‡ `Fn\u0026lt;U\u0026gt;` wrap è¿‡çš„å‡½æ•°ä»¥åŠé»˜è®¤çš„åˆ†æ”¯ () =\u0026gt; U if (typeof branch === \u0026#34;function\u0026#34;) { return (branch as Fn\u0026lt;U\u0026gt;)[FnVal] ? (branch as Fn\u0026lt;U\u0026gt;)[FnVal] : branch(); } else { const [cond, result] = branch; // æ¯ä¸ªåˆ†æ”¯åˆ†ä¸ºæ¡ä»¶ä¸ç»“æœï¼Œä½¿ç”¨ matches åˆ¤æ–­æ˜¯å¦åŒ¹é…ä¸Šäº†ï¼Œåœ¨åŒ¹é…ä¸Šçš„æƒ…å†µä¸‹ï¼š if (matches(cond, val, true)) { if (typeof result === \u0026#34;function\u0026#34;) { // å¦‚æœç»“æœæ˜¯ `Fn\u0026lt;U\u0026gt;` wrap è¿‡çš„åˆ™è¿”å›å‡½æ•°æœ¬èº« // ç»“æœæ˜¯æ™®é€šå‡½æ•°å°±æ‰§è¡ŒåŒ¹é…ç»“æœ return (result as Fn\u0026lt;U\u0026gt;)[FnVal] ? (result as Fn\u0026lt;U\u0026gt;)[FnVal] : (result as (val: T) =\u0026gt; U)(val); } else { // éå‡½æ•°å°±è¿”å›æ•°å€¼ return result; } } } } // éƒ½ä¸æ˜¯åˆ™æ‰§è¡Œé»˜è®¤åˆ†æ”¯ return defaultBranch(); } ä¸‹é¢ä»‹ç»ä¸‹ Fn\u0026lt;U\u0026gt; æ˜¯åšä»€ä¹ˆçš„ï¼š\n1 2 3 4 5 6 7 export const FnVal = Symbol(\u0026#34;FnVal\u0026#34;); export function Fn\u0026lt;T extends (...args: any) =\u0026gt; any\u0026gt;(fn: T): () =\u0026gt; T { const val: any = () =\u0026gt; throwFnCalled(); (val as any)[FnVal] = fn; return val; } export type Fn\u0026lt;T\u0026gt; = { (): never; [FnVal]: T }; Fn æ˜¯ç±»å‹ä¹Ÿæ˜¯å‡½æ•°ï¼Œä½œä¸ºç±»å‹çš„æ—¶å€™è¡¨ç¤ºä¸€ä¸ªæ— æ³•è¢«æ‰§è¡Œï¼ˆå³è¿”å›neverï¼Œåœ¨å®ç°é‡Œï¼Œä¸€å®šä¼šthrow ä¸€ä¸ªé”™è¯¯çš„å‡½æ•°ï¼‰ï¼Œä½†æ˜¯å­˜å‚¨äº†å‡½æ•°ï¼ˆé€šè¿‡ FnVal è¿™ä¸ª Symbol ç±»å‹æ¥ç´¢å¼•ï¼‰çš„å¯¹è±¡ã€‚\nFn çš„ä½œç”¨æ˜¯å°†å‡½æ•°åŒ…è£…æˆä¸€ä¸ªå¯ä»¥è¢«åŒ¹é…ã€å¯ä»¥ä½œä¸ºåŒ¹é…ç»“æœçš„å¯¹è±¡ï¼Œè€Œä¸æ˜¯åœ¨åŒ¹é…æˆåŠŸæ—¶æ‰§è¡Œã€æˆ–æ˜¯ä½œä¸º filter å­˜åœ¨ï¼Œå¦‚ä¸‹ï¼š\n1 2 3 4 5 // ä½¿ç”¨ Fn ä½œä¸ºåˆ†æ”¯ï¼ŒåŒ¹é…æˆåŠŸå°†è¿”å›å‡½æ•° match(Some(1), [ [Some(1), Fn(()=\u0026gt;\u0026#34;1\u0026#34;)], Fn(()=\u0026gt;\u0026#39;default\u0026#39;), ])() ä¸‹é¢ä»‹ç»è¿”å›æ˜¯å¦åŒ¹é…æ¡ä»¶çš„ matches çš„å®ç°ï¼š\nä¸è¿‡å…ˆçœ‹çœ‹ä»€ä¹ˆæ ·å¯ä»¥ç®—ä¸€ä¸ªåˆç†çš„æ¡ä»¶ï¼š\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 type Branch\u0026lt;T, U\u0026gt; = [BranchCondition\u0026lt;T\u0026gt;, BranchResult\u0026lt;T, U\u0026gt;]; type BranchCondition\u0026lt;T\u0026gt; = | Mapped\u0026lt;T, boolean\u0026gt; | (T extends { [T]: boolean } ? MonadCondition\u0026lt;T\u0026gt; : Condition\u0026lt;T\u0026gt;); type Condition\u0026lt;T\u0026gt; = T extends object ? { [K in keyof T]?: BranchCondition\u0026lt;T[K]\u0026gt; } : T; type MonadCondition\u0026lt;T\u0026gt; = T extends Option\u0026lt;infer U\u0026gt; ? Some\u0026lt;MonadCondition\u0026lt;U\u0026gt;\u0026gt; | None : T extends Result\u0026lt;infer U, infer E\u0026gt; ? Ok\u0026lt;MonadCondition\u0026lt;U\u0026gt;\u0026gt; | Err\u0026lt;MonadCondition\u0026lt;E\u0026gt;\u0026gt; : Wide\u0026lt;T\u0026gt;; type MonadMapped\u0026lt;T, U\u0026gt; = | Mapped\u0026lt;T, U\u0026gt; | ChainedBranches\u0026lt;T, U\u0026gt; | MappedBranches\u0026lt;T, U\u0026gt;; type Mapped\u0026lt;T, U\u0026gt; = (val: T) =\u0026gt; U; type Wide\u0026lt;T\u0026gt; = T extends [...infer U] ? U[number][] : Partial\u0026lt;T\u0026gt;; æˆ‘ä»¬çŸ¥é“ä¸€ä¸ªåˆ†æ”¯åˆ†æˆæ¡ä»¶å’Œç»“æœï¼Œçœ‹ BranchCondition å³åˆ†æ”¯æ¡ä»¶ï¼Œå¯ä»¥æ˜¯ä»¥ä¸‹çš„æƒ…å†µ\nMappedï¼Œè¡¨ç¤ºè¢«å‡†ç¡®åŒ¹é…çš„å€¼ï¼Œæ¯”å¦‚ Some(1) è¿™æ ·çš„ æ ¹æ®æ˜¯å¦æœ‰ [T] æˆå‘˜æ¥åŒºåˆ†æ˜¯å¦ Option/Resultï¼Œæ³¨æ„è¿™ä¸ª T å¹¶ä¸æ˜¯ç±»å‹ï¼Œè€Œæ˜¯é‚£ä¸ª Symbol å˜é‡ æœ‰ [T] çš„è¯´æ˜æ˜¯ Option æˆ–è€… Resultï¼Œè¿›å…¥ MonadCondition åˆ†åˆ«é€šè¿‡åŒ¹é… Option å’Œ Result æ¥ç¡®å®šç±»å‹ éƒ½ä¸æ˜¯åˆ™è¿›å…¥ Wide å¦‚æœæ˜¯æ•°ç»„å°±æ˜¯å¯¹æ•°ç»„çš„åŒ¹é… å¦‚æœä¸æ˜¯æ•°ç»„å°±æ˜¯å¯¹ T éƒ¨åˆ†å­—æ®µçš„åŒ¹é… æ²¡æœ‰ [T] è¿›å…¥æ™®é€šçš„æ¡ä»¶ Conditionï¼Œé€šè¿‡å˜é‡æ˜¯å¦å¯¹è±¡æ¥åˆ†ç±» æ˜¯å¯¹è±¡çš„è¯ï¼Œé‚£ä¹ˆç±»å‹éœ€è¦è¿›è¡Œç­›é€‰ä¸€ä¸‹ï¼Œåªé€‰å‡ºéœ€è¦çš„å­—æ®µåŠå…¶ç±»å‹ï¼Œæ¯ä¸ªå­—æ®µéƒ½æ˜¯ä¸€ä¸ªç‹¬ç«‹çš„åˆ†æ”¯æ¡ä»¶ï¼ˆBranchConditionï¼‰ ä¸æ˜¯å¯¹è±¡çš„è¯å°±ç›´æ¥åŒ¹é…è¯¥å€¼çš„ç±»å‹å³å¯ Monadï¼ˆå•å­ï¼‰æ˜¯å‰é¢ä»‹ç»è¿‡çš„ä¸€ä¸ªæ¦‚å¿µï¼Œç®€å•è¯´ä»£è¡¨ä¸€ä¸ªå å‘çš„å˜é‡ï¼Œå¯ä»¥æ˜¯å‡ ç§çŠ¶æ€çš„å åŠ  ä¸‹é¢åˆ™æ˜¯è¿”å›æ˜¯å¦åŒ¹é…æ¡ä»¶çš„ matches å‡½æ•°ï¼š\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 function matches\u0026lt;T\u0026gt;( cond: BranchCondition\u0026lt;T\u0026gt;, val: T, evaluate: boolean ): boolean { if (cond === Default || cond === val) { // å¦‚æœç›´æ¥åŒ¹é…ä¸Šäº†æˆ–è€…æ˜¯é»˜è®¤åˆ†æ”¯åˆ™ç›´æ¥è¿”å›true return true; } if (typeof cond === \u0026#34;function\u0026#34;) { // å¦‚æœæ˜¯è¢«åŒ…è£…åçš„å‡½æ•°å°±åˆ¤æ–­æ˜¯ä¸æ˜¯è¯¥å‡½æ•°ï¼Œ // å¦åˆ™ï¼Œåªæœ‰åœ¨ evaluate ä¸º true ï¼ˆä»£è¡¨è¦åˆ¤æ–­å…¶å€¼ï¼‰æ—¶æ‰§è¡Œæ¡ä»¶å‡½æ•° return (cond as Fn\u0026lt;T\u0026gt;)[FnVal] ? (cond as Fn\u0026lt;T\u0026gt;)[FnVal] === val : evaluate \u0026amp;\u0026amp; (cond as (val: T) =\u0026gt; boolean)(val); } // å¦‚æœæ˜¯å¯¹è±¡ if (isObjectLike(cond)) { if (T in cond) { // å¦‚æœ val æ˜¯æ¡ä»¶çš„ä¸€éƒ¨åˆ†ï¼Œå†æ·±å…¥åˆ¤æ–­ï¼ˆå†æ¬¡è°ƒç”¨matchesï¼Œå­—æ®µçº§åŒ¹é…ï¼‰ return ( (cond as any).isLike(val) \u0026amp;\u0026amp; matches((cond as any)[Val], (val as any)[Val], false) ); } if (isObjectLike(val) \u0026amp;\u0026amp; Array.isArray(cond) === Array.isArray(val)) { // å¯¹æ•°ç»„åŒ¹é…ï¼Œå…ƒç´ çº§åŒ¹é… for (const key of Object.keys(cond)) { if ( !(key in val) || !matches((cond as any)[key], (val as any)[key], evaluate) ) { return false; } } return true; } } return false; } å°ç»“ é€šè¿‡æŠŠç±»å‹ä¸€å±‚ä¸€å±‚æŠ½è±¡ï¼Œå®ç°ç±»å‹å®‰å…¨çš„åŒ¹é… Chained çš„åŒ¹é…æä¾›äº†æ¯” mapped æ›´çµæ´»çš„ä½¿ç”¨æ–¹å¼ é¢˜å¤– ä¸ºä»€ä¹ˆåªå¹¿æ³›åœ¨å‡½æ•°å¼ç¼–ç¨‹æµè¡Œ å‚è€ƒ Why-is-pattern-matching-prevalent-only-in-functional-programming-languages\næ¨¡å¼åŒ¹é…å®é™…ä¸Šå’Œä¸€ä¸ªå¼ºå¤§çš„ç±»å‹ç³»ç»Ÿæœ‰å¾ˆå¼ºçš„å…³ç³»ï¼Œé‚£å°±æ˜¯ä»£æ•°æ•°æ®ç±»å‹ï¼ˆAlgebraic Data Typeï¼‰ï¼Œåœ¨å‰é¢ç®€å•æåˆ°è¿‡ï¼Œæ¯”å¦‚ | ä¸ºä¼ ç»Ÿçš„ union ç±»å‹æä¾›äº†æ›´å¼ºå¤§çš„è¡¨è¾¾èƒ½åŠ›ï¼Œ\u0026amp; ä¹Ÿæ¯”å¤æ‚çš„ç»§æ‰¿æ›´å¥½å†™ã€‚ å› ä¸º C æ²¡æœ‰ åœ¨ä¸€äº›æ¯”è¾ƒæ–°çš„è¯­è¨€é‡Œï¼ˆæ¯”å¦‚ TypeScript å’Œ Rustï¼‰å¼ºå¤§çš„ç±»å‹ç³»ç»Ÿå°±ä¸ºæ¨¡å¼åŒ¹é…æä¾›äº†åœŸå£¤ã€‚ ç°åœ¨çš„ OO è¯­è¨€ä¹Ÿåœ¨ä¸€äº›æ¯”è¾ƒå¾®è§‚çš„å±‚é¢ä¸Šå¼•å…¥äº†ä¸€äº›å‡½æ•°å¼ç¼–ç¨‹çš„æ¦‚å¿µï¼Œæ¥æé«˜ç¨‹åºçš„è¡¨è¾¾èƒ½åŠ›ï¼Œæ¯”å¦‚ Python3.10 å°±å¼•å…¥äº† matchï¼ŒC# ä¹Ÿå¼•å…¥äº†matchã€‚\nECMAScript é‡Œçš„è¿›å±• GitHub - tc39/proposal-pattern-matching: Pattern matching syntax for ECMAScript\nè¿˜åœ¨ Proposal é˜¶æ®µï¼Œæäº†å¥½å¤šå¹´äº†ä¼¼ä¹æ²¡ä»€ä¹ˆè¿›å±•ï¼Œä¸è¿‡ star è¿˜æ˜¯å¾ˆå¤šçš„\nææ¡ˆä¸­æä¾›äº†ç±»ä¼¼ä»¥ä¸‹çš„åŒ¹é…æ–¹å¼ï¼š\n1 2 3 4 5 6 7 8 9 10 match (res) { when ({ status: 200, body, ...rest }): handleData(body, rest) when ({ status, destination: url }) if (300 \u0026lt;= status \u0026amp;\u0026amp; status \u0026lt; 400): handleRedirect(url) when ({ status: 500 }) if (!this.hasRetried): do { retry(req); this.hasRetried = true; } default: throwSomething(); } å®é™…ä¸Šæ„Ÿè§‰ä¸å¦‚å‰é¢å®ç°çš„é‚£ç§é‚£ç§å¥½çœ‹\næ€»ç»“ ä»‹ç»äº†æ¨¡å¼åŒ¹é…çš„å®ç°ä¸å¥½å¤„ï¼š ç¬¦åˆæ€è€ƒæ–¹å¼ æ¡ä»¶ä¸èµ‹å€¼çš„å…¼å¾— è¯­å¥åˆ°è¡¨è¾¾å¼çš„è½¬å˜ï¼ˆè¡¨è¾¾èƒ½åŠ›çš„å¢å¼ºï¼‰ Monad å¼çš„ç±»å‹å®‰å…¨é”™è¯¯å¤„ç† ç”¨ TS å®ç° matchï¼šç±»å‹çš„ä¸€å±‚å±‚æŠ½è±¡ æŠ•å…¥ç”Ÿäº§ï¼ŸåŸç”Ÿçš„æ”¯æŒä¸å¤Ÿå¼ºå¤§ï¼šç¼–è¯‘å™¨å¯¹åˆ†æ”¯è¦†ç›–çš„æ£€æŸ¥èƒ½åŠ›ä¸è¶³ å‚è€ƒ How is match implemented in a language like Rust? Why-is-pattern-matching-prevalent-only-in-functional-programming-languages Algebraic-data-type-wiki functions overload ","date":"2022-09-12T18:02:35+08:00","permalink":"/p/rusty-typescript--pattern-matching/","title":"Rusty Typescript -- Pattern Matching"},{"content":"rCoreCamp2022-lab4è®°å½• Lab4 æœ¬ä½“ labåœ°å€\nLab4 çš„éš¾åº¦æ„Ÿè§‰æ¯” Lab3 é«˜äº†ä¸€æ¡£ï¼Œå› ä¸ºä¹‹å‰åœ¨å­¦æ ¡æˆ–è€…è‡ªå·±å­¦ OS çš„æ—¶å€™éƒ½åŸºæœ¬éƒ½æ²¡å­¦åˆ°æ–‡ä»¶ç³»ç»Ÿï¼Œæ‰€ä»¥è¿™ä¸€å¼ å±äºæ˜¯çœŸçš„æ–°å­¦äº†ã€‚åœ¨ç†è§£ä¸Šé‡åˆ°äº†å¾ˆå¤§çš„éšœç¢ï¼Œä»£ç ä¹Ÿå¾ˆéš¾æ†‹å‡ºæ¥ã€‚\n0. è¿ç§»ä»£ç  å”¯ä¸€çš„éš¾ç‚¹æ˜¯ï¼Œè¿™ç« ä½¿ç”¨æ–‡ä»¶ç³»ç»Ÿä»£æ›¿äº†loaderï¼Œå› æ­¤\u0008åŠ è½½ç”¨æˆ·ç¨‹åºçš„æ–¹å¼ä» get_app_by_name ä»loaderé‡Œå–æ”¹æˆäº†ç”¨æ–‡ä»¶ç³»ç»Ÿçš„api å»æ‰“å¼€æ–‡ä»¶\nä¸‹é¢çš„ä»£ç ç‰‡æ®µæ‘˜è‡ª sys_spawnï¼Œä½¿ç”¨open_file å»è·å– inode è¿›è€Œåˆ›å»ºæ–°çš„ task\n1 2 3 4 5 6 7 8 if let Some(inode) = open_file(path.as_str(), OpenFlags::RDONLY) { let data = inode.read_all(); let task = current_task().unwrap(); let new_task = task.spawn(data.as_slice()); let pid = new_task.pid.0; add_task(new_task); pid as isize } 1. fstat å› ä¸ºè§‰å¾— fstat æ˜¯æœ€å¥½åšçš„æ‰€ä»¥ä»å®ƒæœ€å¼€å§‹äº†\nè·å– fstat çš„æ ¸å¿ƒæ˜¯ï¼ˆino**,** mode**,** nlinkï¼‰ä¸‰ä¸ªæ•°æ®ï¼Œä»£è¡¨inode idï¼Œæ–‡ä»¶çš„æ¨¡å¼ï¼ˆæ˜¯æ–‡ä»¶è¿˜æ˜¯ç›®å½•ï¼‰ï¼Œæœ‰å‡ ä¸ªå¼•ç”¨ï¼Œè¿™éƒ¨åˆ†å®ç°åœ¨Inode ç»“æ„ä¸­ï¼Œæˆ‘ä»¬ç»™ File trait æ·»åŠ ä¸€ä¸ªç‰¹å¾æ–¹æ³•å« fstat()ï¼Œèƒ½å¤Ÿè¿”å›ä¸‰ä¸ªç»´åº¦çš„æ•°æ®\næ³¨æ„ Stdin å’Œ Stdout ä¹Ÿæ˜¯ç‰¹æ®Šçš„æ–‡ä»¶ï¼Œä½†æ˜¯æ‡’å¾—å®ç°å°±ç›´æ¥åœ¨é‡Œé¢ panic äº†ã€‚\n1 2 3 4 impl File { // ... read, write, readable, writable fn fstat(\u0026amp;self) -\u0026gt; (u64, StatMode, u32); } fstat é‡Œæœ€éš¾çš„æ˜¯å¾—åˆ° inode idï¼Œå› ä¸º Inode ä¸­åªæä¾›äº† get_inode_id_by_nameï¼Œæˆ‘ä»¬å°†è¯¥èƒ½åŠ›åˆ†é…ç»™ fsï¼Œç”±efsæ¥å¸®å¿™å®ç°ä»å—ä¿¡æ¯ä¸­è¯»å– inode çš„id\n1 2 // impl Inode ==\u0026gt; get_inode_id fs.get_inode_id(self.block_id, self.block_offset) 1 2 3 4 5 6 7 8 9 10 impl EasyFileSystem { pub fn get_inode_id(\u0026amp;self, block_id: usize, block_offset: usize) -\u0026gt; usize { let inode_size = core::mem::size_of::\u0026lt;DiskInode\u0026gt;(); let inodes_per_block = (BLOCK_SZ / inode_size) as usize; // ç›®æ ‡ inode å¤„åœ¨ inode åŒºç¬¬nä¸ª let nth_inode_block = block_id - self.inode_area_start_block as usize; // ç›®æ ‡ inode æ‰€åœ¨åŒºå‰æœ‰å‡ ä¸ª inodeï¼Œ + åŒºé‡Œæ’ç¬¬å‡ ä¸ª inode return nth_inode_block * inodes_per_block + block_offset / inode_size; } } 2. linkat linkat çš„åŠŸèƒ½å®ç°åœ¨ Inode é‡Œï¼Œä»£ç éœ€è¦æ¨¡ä»¿ Inode ä¸­çš„ create æ–¹æ³•ï¼Œå®é™…ä¸Šæ–°å»ºæ–‡ä»¶çš„è¿‡ç¨‹ä¹Ÿæ˜¯åˆ›å»ºä¸€ä¸ªç¡¬è¿æ¥\nå…·ä½“æ€è·¯å°±æ˜¯ï¼š\næ–°æ—§æ–‡ä»¶åçš„æ ¡éªŒ åœ¨ get_block_cache é‡Œï¼Œé€šè¿‡ä» fs å¾—åˆ°çš„ block ä½ç½®ä¿¡æ¯ï¼Œæ–°å»ºä¸€ä¸ªæ–‡ä»¶ æ›´æ–°ç›®å½•è¡¨ï¼Œæ’å…¥ä¸€ä¸ªæ–°çš„DirEntry 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 /// like `fn create` pub fn linkat(\u0026amp;self, old_name: \u0026amp;str, new_name: \u0026amp;str) -\u0026gt; isize { let mut fs = self.fs.lock(); let old_inode_id = self.read_disk_inode(|disk_inode| self.find_inode_id(old_name, disk_inode) ); // old_name should point to a valid file if old_inode_id == None { return -1; } // new_name should not point to an existing file if self.read_disk_inode(|disk_inode| self.find_inode_id(new_name, disk_inode)).is_some() { return -1; } let (block_id, block_offset) = fs.get_disk_inode_pos(old_inode_id.unwrap()); get_block_cache(block_id as usize, Arc::clone(\u0026amp;self.block_device)) .lock() .modify(block_offset, |new_inode: \u0026amp;mut DiskInode| { new_inode.initialize(DiskInodeType::File) }); // update dir table self.modify_disk_inode(|root_inode| { // add a new dir entry let file_count = (root_inode.size as usize) / DIRENT_SZ; let new_size = (file_count + 1) * DIRENT_SZ; self.increase_size(new_size as u32, root_inode, \u0026amp;mut fs); // write into the new dir entry let dirent = DirEntry::new(new_name, old_inode_id.unwrap()); root_inode.write_at(file_count * DIRENT_SZ, dirent.as_bytes(), \u0026amp;self.block_device); }); 0 } 3. unlinkat unlink è·Ÿ link è¿˜æ˜¯æ¯”è¾ƒåƒï¼Œæ€è·¯æ˜¯éå†æ ¹ç›®å½•ï¼ˆä½¿ç”¨modify_disk_inodeï¼‰ï¼Œåœ¨ file_num ä¸ªæ–‡ä»¶é‡Œæ‰¾åˆ°ç¬¦åˆæ¡ä»¶çš„æ–‡ä»¶ï¼Œåˆ é™¤å…¶ç›®å½•é¡¹ï¼ˆå°†å…¶èµ‹ä¸º DirEntry::empty()ï¼‰ã€‚\nèƒ½è¿™ä¹ˆå†™æ˜¯å› ä¸º rCore é‡Œçš„æ–‡ä»¶ç³»ç»Ÿåªæœ‰ä¸€å±‚ï¼Œæ ¹ç›®å½•ä¸‹å…¨æ˜¯æ–‡ä»¶\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 /// unlink pub fn unlink(\u0026amp;self, name: \u0026amp;str) -\u0026gt; isize { self.modify_disk_inode(|root_inode| { let file_num = (root_inode.size as usize) / DIRENT_SZ; // find the correct entry and modify it, else -1 for i in 0..file_num { let mut dirent = DirEntry::empty(); let readn = root_inode.read_at( i * DIRENT_SZ, dirent.as_bytes_mut(), \u0026amp;self.block_device ); // read size should == DIRENT_SZ if readn != DIRENT_SZ { continue; } if dirent.name() == name { let dirent = DirEntry::empty(); root_inode.write_at(i * DIRENT_SZ, dirent.as_bytes(), \u0026amp;self.block_device); return 0; } } -1 }) } æ‚é¡¹ ç®€ç­”é¢˜ åœ¨æˆ‘ä»¬çš„easy-fsä¸­ï¼Œroot inodeèµ·ç€ä»€ä¹ˆä½œç”¨ï¼Ÿå¦‚æœroot inodeä¸­çš„å†…å®¹æŸåäº†ï¼Œä¼šå‘ç”Ÿä»€ä¹ˆï¼Ÿ Answer: ROOT_INODE ä»£è¡¨æ ¹ç›®å½•æ‰€å¯¹åº”çš„ Inodeï¼Œä¹Ÿæ˜¯æ•´ä¸ªæ–‡ä»¶ç³»ç»Ÿï¼ˆæ–‡ä»¶æ ‘ï¼‰çš„èµ·ç‚¹ï¼Œæˆ‘ä»¬ç®¡ç†å…¶ä»–çš„æ–‡ä»¶éƒ½æ˜¯åœ¨æ ¹ç›®å½•ä¸‹ç©å®Œæˆçš„ï¼Œå¦‚æœå®ƒåäº†ï¼Œé‚£ä¹ˆæ•´ä¸ªæ–‡ä»¶ç³»ç»Ÿå°±æ— æ³•æ­£å¸¸ç®¡ç†æ–‡ä»¶\næ–‡ä»¶ç³»ç»Ÿç¬”è®° ä¸€ä¸ªç£ç›˜æ–‡ä»¶ç³»ç»Ÿçš„ç»„ç»‡ç»“æ„ è¿™ä¸€ç« çš„ MVP slide æˆ‘è§‰å¾—æ˜¯ä¸‹å›¾ï¼Œä¸€ä¸ª fs åˆ†æˆäº†ä¸‹é¢äº”å—\nSuper Blockï¼šè®°å½•äº†åè¾¹å‡ ä¸ªåˆ†åˆ«å äº†å¤šå°‘å—ï¼ˆç£ç›˜çš„å•ä½ä½¿ç”¨å—æ¥è¡¨ç¤ºï¼Œç±»ä¼¼å†…å­˜çš„é¡µå¸§ï¼‰ Inode Bitmapï¼šè®°å½• Inodes å—çš„ä½¿ç”¨æƒ…å†µï¼Œä¸€ä¸ªä½å¯ä»¥è¡¨ç¤ºä¸€ä¸ª Inode çš„ä½¿ç”¨ä¸å¦ï¼Œåœ¨åˆ†é… Inode æ—¶èµ·åˆ°é‡è¦ä½œç”¨ Data Bitmapï¼šè·Ÿä¸Šä¸€å—å·®ä¸å¤šï¼Œè®°å½•çš„æ˜¯æ•°æ®å—çš„ä½¿ç”¨æƒ…å†µ Inodesï¼šæ˜¯DiskInodeï¼ˆå­˜å‚¨äºç£ç›˜ä¸Šçš„æ–‡ä»¶ç®¡ç†å•å…ƒï¼‰åœ¨å†…å­˜é‡Œçš„å½¢æ€ï¼Œä¸€ä¸ªInodeä»£è¡¨ç®¡ç†äº†ä¸€ä¸ªæ–‡ä»¶ï¼Œé€šè¿‡è®¿é—® Inode å¯ä»¥è®¿é—®åˆ°æ•°æ®ï¼Œè€Œå…¶å®è¿™äº›æ•°æ®å°±ç¼“å­˜åœ¨ Data Blocks é‡Œï¼Œä½†æ˜¯ä¸Šå±‚çš„æŠ½è±¡ä¸éœ€è¦æ„ŸçŸ¥åˆ° DataBlock Data Blocksï¼šçœŸå®çš„æ•°æ®ï¼Œé€šè¿‡ Inode èƒ½å¤Ÿæ‰¾åˆ° ä¸‹å›¾åˆ™ä»£è¡¨äº†ç›®å½•é¡¹ï¼Œå°±æ˜¯ä¸Šå›¾çš„å³ä¸Šè¡¨ï¼Œå®ç°ä»æ–‡ä»¶ååˆ°æ–‡ä»¶Inodeçš„æ˜ å°„ï¼ˆå½“ç„¶å¦‚æœæ˜¯ç›®å½•ï¼Œåˆ™æ˜ å°„åˆ°å…¶ä¸‹çš„ä¸€å †ç›®å½•é¡¹ï¼‰\næ„Ÿæƒ³ æ–‡ä»¶ç³»ç»Ÿå¯¹æˆ‘æ¥è¯´è¿‡äºé™Œç”Ÿï¼Œæ‰€ä»¥åœ¨è¿™èŠ±äº†éå¸¸å¤šçš„æ—¶é—´ï¼Œæ•´æ•´ä¸€å‘¨ï¼Œåˆ°ç°åœ¨ä¹Ÿä¸æ˜¯å½»åº•ç†è§£äº†è¿™å¥—ç³»ç»Ÿï¼Œå¤šäºäº†åŠ©æ•™xushanpu çš„ç¬”è®°ï¼Œç”¨è‡ªä¸Šè€Œä¸‹çš„è§†è§’å»ç†è§£ä»£ç ç»“æ„æ„Ÿè§‰æ¯” camp æ–‡æ¡£é‡Œçš„æ›´å¥½ç†è§£ã€‚\nå¯¹æ–‡ä»¶ç³»ç»Ÿçš„ç†è§£ä¸»è¦å°±æ˜¯ç¬¬ä¸€å¼ å›¾é‚£ä¸ªè§†å›¾\nå·¦ä¸Šæ˜¯ç”¨æˆ·è§†è§’ï¼Œæ–‡ä»¶ç³»ç»Ÿå°±æ˜¯ä¸€æ£µæ–‡ä»¶æ ‘\nå³ä¸Šæ˜¯ OS è§†è§’ï¼Œä¸€ä¸ªæ–‡ä»¶æ˜¯ä¸€ä¸ª Inodeï¼Œä¸­é—´æ˜¯æ–‡ä»¶ååˆ° Inode idx çš„æ˜ å°„\nä¸‹é¢çš„ç»“æ„æ˜¯ç£ç›˜è§†è§’ï¼Œä¸€ä¸ªfsåˆ†åŒºå°±æ˜¯è¿™æ ·çš„ç»“æ„\nå¦‚æœæˆ‘ä»¬æŠŠä¸€ä¸ªç£ç›˜åˆ†åŒºï¼Œé‚£ä¹ˆæ¯ä¸ªåˆ†åŒºéƒ½æ˜¯ç‹¬ç«‹çš„ fsï¼Œå› æ­¤éƒ½ä¼šæœ‰å¹³è¡Œçš„é‚£ä¸ªç»“æ„ ","date":"2022-07-30T00:29:54+08:00","permalink":"/p/rcore-camp-2022-lab4-%E8%AE%B0%E5%BD%95/","title":"rCore Camp 2022 Lab4 è®°å½•"},{"content":"rCoreCamp2022-lab3è®°å½• Lab3 æœ¬ä½“ lab åœ°å€\n0. è¿ç§»é€šè¿‡ä»¥å‰çš„æµ‹è¯• get_timeï¼š åŸæœ¬æˆ‘ç»™ TCB åŠ äº†ä¸€ä¸ª innerï¼Œè¿™éƒ¨åˆ†åœ¨ç¬¬äº”ç« é‡Œå®˜æ–¹åŠ äº†è¿™ä¸ªç»“æ„ï¼Œå› æ­¤éœ€è¦æŠŠ syscall_times å’Œ start_time ç»™è¿ç§»è¿›å» get_task_infoï¼š å’Œ get_time åŒç†ï¼Œä¸è¿‡éœ€è¦æ³¨æ„çš„æ˜¯ä»£ç æ›´æ”¹äº†é€»è¾‘ï¼ŒåŸæœ¬ç”± TASK_MANAGER è´Ÿè´£ç®¡ç†çš„ä»»åŠ¡è°ƒåº¦å’Œä»»åŠ¡æ‰§è¡Œéƒ¨åˆ†ï¼Œåˆ†æˆäº† manager å’Œ processor çš„å·¥ä½œï¼Œå‰è€…è´Ÿè´£ç®¡ç†ä»»åŠ¡è°ƒåº¦ï¼Œåè€…è´Ÿè´£æ“æ§å½“å‰ä»»åŠ¡ + å½“å‰ä»»åŠ¡çš„åˆ‡æ¢ï¼Œè¿™äºŒè€…éƒ½è¿ç§»è¿›äº† Processor é‡Œ mmap \u0026amp; munmapï¼šæ²¡ä»€ä¹ˆå˜åŒ–ï¼Œå°±æ˜¯ç›´æ¥æ¬è¿ 1. å®ç° spawn 1 fn sys_spawn(path: *const u8) -\u0026gt; isize å¹³æ—¶æˆ‘ä»¬ä¼šä½¿ç”¨ fork() + exec() æ¥å®ç°åˆ›å»ºä¸€ä¸ªæ–°çš„è¿›ç¨‹ï¼Œä½†ä¸ºä»€ä¹ˆè¦å…ˆå¤åˆ¶çŠ¶æ€æœºå†é‡ç½®çŠ¶æ€æœºï¼ˆçŠ¶æ€æœºçš„ç†è®ºè§ç»¿å¯¼å¸ˆçš„å—å¤§ OS è¯¾ï¼‰ï¼Ÿå½“ç„¶å¯ä»¥ç›´æ¥åˆ›å»ºä¸€ä¸ªæ–°çš„çŠ¶æ€ï¼\nman page æä¾›äº† spawn ç›¸å…³çš„è¯´æ˜\nå®ç°ä¸å¤ªéš¾ï¼Œå°±æ˜¯åœ¨ fork å’Œ exec ä¸Šå·å·è€Œå·²ï¼Œ\u0008å…·ä½“ä»£ç å°±ä¸æ”¾äº†\n1 2 3 4 5 6 7 8 9 impl TaskControlBlock { /// Spawn a new process without fork + exec pub fn spawn(self: \u0026amp;Arc\u0026lt;TaskControlBlock\u0026gt;, elf_data: \u0026amp;[u8]) -\u0026gt; Arc\u0026lt;TaskControlBlock\u0026gt; { // 1. è§£æ elf æ–‡ä»¶ï¼Œå¾—åˆ° memory_set, user_sp, entry_point, ä» memory_set é‡Œç®—å‡ºç‰©ç† trap_cx_ppn // 2. æ–°å»º TCBï¼Œæ•°æ®æ˜¯æ–°çš„ï¼ˆç±»ä¼¼ exec é‡Œçš„é€»è¾‘ï¼‰ // 3. å°†æ–°çš„ TCB æŒ‚åˆ°å½“å‰ TCB çš„ children é‡Œ // 4. ä¿®æ”¹æ–°çš„ TCB çš„ trap_cx çš„å€¼ } } 2. å®ç° stride stride æ„æ€æ˜¯æ­¥ä¼ï¼Œè®¡ç®—æ–¹å¼æ˜¯ stride = BIG_STRIDE / priorityï¼Œæ¯æ¬¡æ‰§è¡Œä¸€ä¸ªä»»åŠ¡è¦ pass += strideï¼Œç„¶ååœ¨è°ƒåº¦æ—¶é€‰æ‹© pass æœ€å°çš„æ‰§è¡Œã€‚å› ä¸º priority å½“äº†åˆ†æ¯ï¼Œæ‰€ä»¥è¶Šé«˜çš„ä¼˜å…ˆçº§çš„ stride è¶Šå°ï¼Œæ¯æ¬¡å°±è¶Šæ—©è¢«è°ƒåº¦ã€‚\næ¯”å¦‚ priority = 5 çš„è¿›ç¨‹å’Œ priority = 10 çš„è¿›ç¨‹ï¼Œæ¯æ¬¡ä¼˜å…ˆçº§ä¸º5çš„å¢åŠ çš„ stride æ˜¯ 10 çš„ä¸¤å€ï¼Œæ‰€ä»¥åœ¨ç›¸åŒæ—¶é—´é‡Œï¼Œæ¬¡æ•°å¤§çº¦ä¼šæ˜¯ä¼˜å…ˆçº§ 10 çš„ä¸€åŠã€‚\nä¸‹é¢çš„å®ç°å‚è€ƒäº†åŠ©æ•™ xushanpu123 çš„ç¬”è®°ï¼Œ ç»´æŠ¤ä¸€ä¸ª pass å•è°ƒé€’å¢çš„é˜Ÿåˆ—ï¼Œæ¯æ¬¡ä»å¤´å–å°±è¡Œäº†ã€‚\nå¦å¤–ä¸€ç§åšæ³•æ˜¯é˜Ÿåˆ—ä¸ä¸€å®šå•è°ƒï¼Œä½†æ˜¯æ¯æ¬¡å–æ—¶é éå†æ¥æ‰¾æœ€å°å€¼\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 impl TaskManager { pub fn add(\u0026amp;mut self, task: Arc\u0026lt;TaskControlBlock\u0026gt;) { // insert the new task into a proper position let inner = task.inner_exclusive_access(); let pass = inner.pass; // let prio = inner.priority; // drop the ownership of inner drop(inner); let len = self.ready_queue.len(); for idx in 0..len { let queue_task = self.ready_queue.get_mut(idx).unwrap(); let pass1 = queue_task.inner_exclusive_access().pass; // keep the queue head owns the smallest pass if pass \u0026lt; pass1 { // println!(\u0026#34;new task priority: {}, pass: {}, inserted before idx {}\u0026#34;, prio, pass, idx); self.ready_queue.insert(idx, task); return } } self.ready_queue.push_back(task); } } è¸©å‘ ä¼šæœ‰ already borrowed: BorrowMutError çš„ panic æŠ¥é”™ï¼Œæ˜¯åœ¨æµ‹è¯•ç»“æŸåè°ƒç”¨æœ€åä¸€ä¸ª exit æ—¶å‘ç”Ÿçš„\nå®šä½ï¼šåœ¨å‡½æ•°å‰é¢åŠ  #[trace_caller] å°±èƒ½æ˜¾ç¤ºæ–‡ä»¶+è¡Œæ•° åŸå› ï¼šåœ¨æµ‹è¯•çš„æ—¶å€™ï¼Œinitproc ä¼šè¢«æ›¿æ¢æˆå„ç« çš„ ch_usertest ,æ‰€ä»¥æ˜¯ä¸ä¼šåƒæ™®é€šçš„è¿è¡Œé‚£æ ·è¿›å…¥ initproc ç„¶åè¿è¡Œ shell çš„ï¼Œ usertest é€€å‡ºçš„æ—¶å€™æ‰€æœ‰æƒä¼šè¢«å€Ÿèµ°ï¼Œä½†æ˜¯åé¢åˆå€Ÿå›æ¥äº†å¯¼è‡´é”™è¯¯ï¼ˆå…¶å®å°±æ˜¯åœ¨ exit_current_and_run_next_task é‡Œï¼Œå°†è¦é€€å‡ºçš„å’Œä¸‹ä¸€ä¸ªä»»åŠ¡æ˜¯åŒä¸€ä¸ªï¼Œè€Œæˆ‘ä»¬éœ€è¦åŒæ—¶å¯å˜å€Ÿç”¨è¿™ä¸¤ä¸ªï¼‰ è§£å†³æ–¹æ¡ˆï¼šåœ¨æ‹¿åˆ° current ååˆ¤æ–­ pidï¼Œå¦‚æœæ˜¯ 0ï¼ˆè¡¨ç¤ºåˆè¿›ç¨‹ï¼‰å°±è°ƒç”¨ sbi é‡Œçš„ shutdown() ç›´æ¥å…³æœº stride test è¿‡ä¸äº†ï¼Œè°ƒåº¦ä¸ç¬¦åˆå…¬å¹³æ€§\næ²¡æ‰¾åˆ°åŸå› ï¼Œè°ƒåº¦çš„è¿‡ç¨‹åº”è¯¥æ˜¯æ²¡é”™çš„ï¼Œæ‰“å°å‡ºæ¥çš„ç»Ÿè®¡æ•°æ®æ²¡æœ‰é”™ è§£å†³ï¼šç»™ ci-user é‡Œçš„ ch5_stridex åŠ äº†println!ï¼Œä½¿å¾—æ‰§è¡Œé€Ÿåº¦å¤§å¹…é™ä½ï¼Œç„¶åå±…ç„¶å°±æ­£å¸¸äº†â€¦ 2022.07.26æ›´æ–°ï¼š\nå·²ç»æ‰¾åˆ°åŸå› ï¼Œæ˜¯åˆ†æ—¶ç¨‹åºåˆ‡æ¢é‚£é‡Œåšçš„è®¾ç½®å®šæ—¶æ—¶é’Ÿä¸­æ–­å‡ºé—®é¢˜äº†ï¼Œæ˜¯sbiçš„æ•…éšœï¼Œå¤ä»¤è¥ä»“åº“åœ¨commit 70ae28ab2280f3e57d14b7a631e7508fe5b4bbaf åå°±ä¿®å¤äº†ï¼Œåœ¨sbi.rsä¸­è°ƒç”¨ ecall å‰æ‰§è¡Œ \u0026ldquo;li x16, 0\u0026rdquo;\næ‚é¡¹ é—®ç­”é¢˜ stride ç®—æ³•æ·±å…¥\nstride ç®—æ³•åŸç†éå¸¸ç®€å•ï¼Œä½†æ˜¯æœ‰ä¸€ä¸ªæ¯”è¾ƒå¤§çš„é—®é¢˜ã€‚ä¾‹å¦‚ä¸¤ä¸ª stride = 10 çš„è¿›ç¨‹ï¼Œä½¿ç”¨ 8bit æ— ç¬¦å·æ•´å½¢å‚¨å­˜ passï¼Œ p1.pass = 255, p2.pass = 250ï¼Œåœ¨ p2 æ‰§è¡Œä¸€ä¸ªæ—¶é—´ç‰‡åï¼Œç†è®ºä¸Šä¸‹ä¸€æ¬¡åº”è¯¥ p1 æ‰§è¡Œã€‚\nå®é™…æƒ…å†µæ˜¯è½®åˆ° p1 æ‰§è¡Œå—ï¼Ÿä¸ºä»€ä¹ˆï¼Ÿ Answer: å¹¶ä¸ï¼Œå› ä¸ºæ•´å‹æº¢å‡ºäº†å¯¼è‡´p2.passæ›´å°\næˆ‘ä»¬ä¹‹å‰è¦æ±‚è¿›ç¨‹ä¼˜å…ˆçº§ \u0026gt;= 2 å…¶å®å°±æ˜¯ä¸ºäº†è§£å†³è¿™ä¸ªé—®é¢˜ã€‚å¯ä»¥è¯æ˜ï¼Œ åœ¨ä¸è€ƒè™‘æº¢å‡ºçš„æƒ…å†µä¸‹ , åœ¨è¿›ç¨‹ä¼˜å…ˆçº§å…¨éƒ¨ \u0026gt;= 2 çš„æƒ…å†µä¸‹ï¼Œå¦‚æœä¸¥æ ¼æŒ‰ç…§ç®—æ³•æ‰§è¡Œï¼Œé‚£ä¹ˆ PASS_MAX â€“ PASS_MIN \u0026lt;= BigStride / 2ã€‚\nä¸ºä»€ä¹ˆï¼Ÿå°è¯•ç®€å•è¯´æ˜ï¼ˆä¸è¦æ±‚ä¸¥æ ¼è¯æ˜ï¼‰ã€‚ Answer: ï¼ˆæ²¡ææ‡‚ï¼‰\nå·²çŸ¥ä»¥ä¸Šç»“è®ºï¼Œ è€ƒè™‘æº¢å‡ºçš„æƒ…å†µä¸‹ ï¼Œå¯ä»¥ä¸º pass è®¾è®¡ç‰¹åˆ«çš„æ¯”è¾ƒå™¨ï¼Œè®© BinaryHeap çš„ pop æ–¹æ³•èƒ½è¿”å›çœŸæ­£æœ€å°çš„ Passã€‚è¡¥å…¨ä¸‹åˆ—ä»£ç ä¸­çš„ partial_cmp å‡½æ•°ï¼Œå‡è®¾ä¸¤ä¸ª Pass æ°¸è¿œä¸ä¼šç›¸ç­‰ã€‚ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 use core::cmp::Ordering; struct Pass(u64); impl PartialOrdforPass{ fn partial_cmp(\u0026amp;self, other: \u0026amp;Self)-\u0026gt; Option\u0026lt;Ordering\u0026gt;{ // å£èƒ¡çš„ä»£ç  } } impl PartialEqforPass{ fn eq(\u0026amp;self, other: \u0026amp;Self)-\u0026gt; bool { false } } TIPS: ä½¿ç”¨ 8 bits å­˜å‚¨ pass, BigStride = 255, åˆ™: (125 \u0026lt; 255) == false, (129 \u0026lt; 255) == true ç¬¬äº”ç« -è¿›ç¨‹ç®¡ç†ç¬”è®° [WIP]\næ„Ÿæƒ³ æ„Ÿè§‰è¿™ç« çš„ lab ä»»åŠ¡ä¸å¤ªéš¾ï¼Œspawn å…¶å®å°±æ˜¯æŠŠ fork å’Œ exec ç¼åˆä¸€ä¸‹ï¼Œä¸éš¾å®ç° stride ç®—æ³•çš„åŸç†ä¹Ÿå¾ˆç®€å•ï¼Œä½†æ˜¯å®ç°äº†æœ€åŸºæœ¬çš„å…¬å¹³æ€§è°ƒåº¦ï¼Œå¯¹æˆ‘æ¥è¯´æ„Ÿè§‰è¿˜æ˜¯æŒºæ–°å¥‡çš„ å› ä¸º sbi çš„ bug è€Œå¯¼è‡´å¡äº†å‡ å¤©ï¼Œå¾ˆéš¾å—ï¼Œå¹¸å¥½å¾®ä¿¡ç¾¤æœ‰äººè§£ç­”ï¼Œå†æ¬¡æ„Ÿå—åˆ°äº†\u0008æœ‰äººé™ªä½ ä¸€èµ·å†™ lab çš„é‡è¦æ€§ï¼Œä¸€ä¸ªäººæ£é¼“çš„è¯é‡åˆ°è¿™ç§æƒ…å†µå¾ˆå¯èƒ½è¦æ”¾å¼ƒäº†ã€‚æ„Ÿè°¢ç¾¤å‹ ","date":"2022-07-23T00:29:54+08:00","permalink":"/p/rcore-camp-2022-lab3-%E8%AE%B0%E5%BD%95/","title":"rCore Camp 2022 Lab3 è®°å½•"},{"content":"rCoreCamp2022-lab2è®°å½• Lab2 æœ¬ä½“ labåœ°å€\n1. é‡å†™ sys_get_time ä¹‹å‰ sys_get_time å¤±æ•ˆçš„åŸå› æ˜¯ç°åœ¨å¢åŠ äº†è™šæ‹Ÿå†…å­˜çš„è®¾å®šï¼Œè€Œè·å–æ—¶é—´é çš„æ˜¯å‚æ•°ä¼ å…¥æŒ‡é’ˆæ¥èµ‹å€¼ï¼Œè¿™æ · ts ä¸æ˜¯çœŸæ­£çš„ç‰©ç†åœ°å€ï¼Œå› æ­¤ä¼šå¤±æ•ˆï¼Œå› æ­¤éœ€è¦æ–°ä½œçš„å·¥ä½œå°±æ˜¯è¿›è¡Œåœ°å€è½¬æ¢ã€‚\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 // YOUR JOB: å¼•å…¥è™šåœ°å€åé‡å†™ sys_get_time // æ ¸å¿ƒä»£ç  pub fn sys_get_time(ts: *mut TimeVal, _tz: usize) -\u0026gt; isize { let virt_addr = VirtAddr(ts as usize); if let Some(phys_addr) = virt2phys_addr(virt_addr) { let us = get_time_us(); let kernel_ts = phys_addr.0 as *mut TimeVal; unsafe { *kernel_ts = TimeVal { sec: us / 1_000_000, usec: us % 1_000_000, }; } 0 } else { -1 } } åœ°å€è½¬æ¢å°±æ˜¯æŸ¥è¡¨è€Œå·²ã€‚\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 // è™šæ‹Ÿåœ°å€è½¬æ¢æˆç‰©ç†åœ°å€ fn virt2phys_addr(virt_addr: VirtAddr) -\u0026gt; Option\u0026lt;PhysAddr\u0026gt; { let offset = virt_addr.page_offset(); let vpn = virt_addr.floor(); let ppn = PageTable::from_token(current_user_token()) .translate(vpn) .map(|entry| entry.ppn()); if let Some(ppn) = ppn { Some(PhysAddr::combine(ppn, offset)) } else { println!(\u0026#34;virt2phys_addr() fail\u0026#34;); None } } 2. é‡å†™ sys_task_info è¿™ä¸ªè·Ÿ 1 å‡ ä¹ä¸€æ¨¡ä¸€æ ·ï¼Œé¢å¤–å·¥ä½œåªæœ‰æ·»åŠ åœ°å€è½¬æ¢\n1 2 3 4 5 6 7 8 9 // YOUR JOB: å¼•å…¥è™šåœ°å€åé‡å†™ sys_task_info pub fn sys_task_info(ti: *mut TaskInfo) -\u0026gt; isize { if let Some(phys_addr) = virt2phys_addr(VirtAddr(ti as usize)) { get_task_info(phys_addr.0 as *mut TaskInfo); 0 } else { -1 } } èŠ±äº†ä¸¤å¤©è§£å†³äº†ä¸€ä¸ªå‘ï¼Œ TaskStatus::Running åœ¨ ci çš„æ—¶å€™å˜æˆäº† TaskStatus::Ready ï¼Œgithub ä¸Šæœ‰ä¸€ä¸ª pr è§£å†³äº†è¿™ä¸ªé—®é¢˜ï¼Œæ˜¯å› ä¸º ci é‡Œçš„æšä¸¾å€¼å¤šäº†ä¸ª UnInit å€¼ï¼Œå¯¼è‡´è§£æé”™è¯¯ï¼ˆä»æ•´æ•°è§£ææˆæšä¸¾ï¼‰\n3. å®ç° mmap 1 fn sys_mmap(start: usize, len: usize, port: usize) -\u0026gt; isize ä¸€å¼€å§‹ç›´æ¥ä½¿ç”¨ frame_allocate() å»åˆ†é…ç‰©ç†é¡µï¼Œä½†æ˜¯åé¢ä¸€ç›´è¿‡ä¸äº†ï¼Œç„äº†ä¸€ä¸‹åˆ«äººçš„ä»£ç ï¼Œå‘ç°æ ¹æœ¬å°±è®¾è®¡é”™äº†ï¼Œåœ¨æŠ½è±¡å±‚é¢ä¸Šï¼Œä»£ç æ¡†æ¶å·²ç»å®ç°äº† MemorySetï¼Œè´Ÿè´£ç®¡ç†ä¸€ä¸ªåº”ç”¨æ‰€è·å¾—çš„æ‰€æœ‰å†…å­˜ï¼Œå› æ­¤æˆ‘ä»¬è¦åšçš„æ˜¯å¾€ MemorySet é‡Œæ–°åŠ ä¸€ä¸ª MapAreaï¼Œè¡¨ç¤ºä¸€æ®µè¿ç»­çš„å†…å­˜ã€‚\nä¸­é—´çš„æ ¡éªŒã€è½¬æ¢éƒ½ä¸å¤ªéš¾ï¼Œè¦è·å–åˆ°å½“å‰ä»»åŠ¡çš„ memory_setï¼Œç„¶åå†å¾€åº”ç”¨æ’é¡µã€‚\næ ¸å¿ƒæ–¹æ³•é›†æˆåœ¨ TASK_MANAGER ä¸­ï¼Œé€šè¿‡ insert_framed_area æ¥æ’å…¥é¡µé¢ã€‚\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 fn task_map(\u0026amp;self, start: usize, len: usize, port: usize) -\u0026gt; isize { if start \u0026amp; (PAGE_SIZE - 1) != 0 { println!( \u0026#34;expect the start address to be aligned with a page, but get an invalid start: {:#x}\u0026#34;, start ); return -1; } // portæœ€ä½ä¸‰ä½[x w r]ï¼Œå…¶ä»–ä½å¿…é¡»ä¸º0 if port \u0026gt; 7usize || port == 0 { println!(\u0026#34;invalid port: {:#b}\u0026#34;, port); return -1; } let mut inner = self.inner.exclusive_access(); let task_id = inner.current_task; let current_task = \u0026amp;mut inner.tasks[task_id]; let memory_set = \u0026amp;mut current_task.memory_set; // check valid let start_vpn = VirtPageNum::from(VirtAddr(start)); let end_vpn = VirtPageNum::from(VirtAddr(start + len).ceil()); for vpn in start_vpn.0 .. end_vpn.0 { if let Some(pte) = memory_set.translate(VirtPageNum(vpn)) { if pte.is_valid() { println!(\u0026#34;vpn {} has been occupied!\u0026#34;, vpn); return -1; } } } // PTE_U çš„è¯­ä¹‰æ˜¯ã€ç”¨æˆ·èƒ½å¦è®¿é—®è¯¥ç‰©ç†å¸§ã€‘ let permission = MapPermission::from_bits((port as u8) \u0026lt;\u0026lt; 1).unwrap() | MapPermission::U; memory_set.insert_framed_area(VirtAddr(start), VirtAddr(start+len), permission); 0 } 4. å®ç° munmap 1 fn sys_munmap(start: usize, len: usize) -\u0026gt; isize è·Ÿ 3 å·®ä¸å¤šï¼Œæ³¨æ„è¦ unmap çš„æ¡ä»¶æ˜¯é¡µå¿…é¡»åœ¨ä½¿ç”¨ï¼Œå› æ­¤å¦‚æœ pte æ˜¯ä¸å¯ç”¨çš„ï¼Œåº”è¯¥æŠ¥é”™\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 fn task_munmap(\u0026amp;self, start: usize, len: usize) -\u0026gt; isize { if start \u0026amp; (PAGE_SIZE - 1) != 0 { println!( \u0026#34;expect the start address to be aligned with a page, but get an invalid start: {:#x}\u0026#34;, start ); return -1; } let mut inner = self.inner.exclusive_access(); let task_id = inner.current_task; let current_task = \u0026amp;mut inner.tasks[task_id]; let memory_set = \u0026amp;mut current_task.memory_set; // check valid let start_vpn = VirtPageNum::from(VirtAddr(start)); let end_vpn = VirtPageNum::from(VirtAddr(start + len).ceil()); for vpn in start_vpn.0 .. end_vpn.0 { if let Some(pte) = memory_set.translate(VirtPageNum(vpn)) { if !pte.is_valid() { println!(\u0026#34;vpn {} is not valid before unmap\u0026#34;, vpn); return -1; } } } let vpn_range = VPNRange::new(start_vpn, end_vpn); memory_set.munmap(vpn_range); 0 } æ‚é¡¹ é—®ç­”é¢˜ [WIP]\nç¼ºé¡µç¼ºé¡µæŒ‡çš„æ˜¯è¿›ç¨‹è®¿é—®é¡µé¢æ—¶é¡µé¢ä¸åœ¨é¡µè¡¨ä¸­æˆ–åœ¨é¡µè¡¨ä¸­æ— æ•ˆçš„ç°è±¡ï¼Œæ­¤æ—¶ MMU å°†ä¼šè¿”å›ä¸€ä¸ªä¸­æ–­ï¼Œ å‘ŠçŸ¥ os è¿›ç¨‹å†…å­˜è®¿é—®å‡ºäº†é—®é¢˜ã€‚os é€‰æ‹©å¡«è¡¥é¡µè¡¨å¹¶é‡æ–°æ‰§è¡Œå¼‚å¸¸æŒ‡ä»¤æˆ–è€…æ€æ­»è¿›ç¨‹ã€‚\nè¯·é—®å“ªäº›å¼‚å¸¸å¯èƒ½æ˜¯ç¼ºé¡µå¯¼è‡´çš„ï¼Ÿ å‘ç”Ÿç¼ºé¡µæ—¶ï¼Œæè¿°ç›¸å…³é‡è¦å¯„å­˜å™¨çš„å€¼ï¼Œä¸Šæ¬¡å®éªŒæè¿°è¿‡çš„å¯ä»¥ç®€ç•¥ã€‚ ç¼ºé¡µæœ‰ä¸¤ä¸ªå¸¸è§çš„åŸå› ï¼Œå…¶ä¸€æ˜¯ Lazy ç­–ç•¥ï¼Œä¹Ÿå°±æ˜¯ç›´åˆ°å†…å­˜é¡µé¢è¢«è®¿é—®æ‰å®é™…è¿›è¡Œé¡µè¡¨æ“ä½œã€‚ æ¯”å¦‚ï¼Œä¸€ä¸ªç¨‹åºè¢«æ‰§è¡Œæ—¶ï¼Œè¿›ç¨‹çš„ä»£ç æ®µç†è®ºä¸Šéœ€è¦ä»ç£ç›˜åŠ è½½åˆ°å†…å­˜ã€‚ä½†æ˜¯ os å¹¶ä¸ä¼šé©¬ä¸Šè¿™æ ·åšï¼Œ è€Œæ˜¯ä¼šä¿å­˜ .text æ®µåœ¨ç£ç›˜çš„ä½ç½®ä¿¡æ¯ï¼Œåœ¨è¿™äº›ä»£ç ç¬¬ä¸€æ¬¡è¢«æ‰§è¡Œæ—¶æ‰å®Œæˆä»ç£ç›˜çš„åŠ è½½æ“ä½œã€‚\nè¿™æ ·åšæœ‰å“ªäº›å¥½å¤„ï¼Ÿ å…¶å®ï¼Œæˆ‘ä»¬çš„ mmap ä¹Ÿå¯ä»¥é‡‡å– Lazy ç­–ç•¥ï¼Œæ¯”å¦‚ï¼šä¸€ä¸ªç”¨æˆ·è¿›ç¨‹å…ˆåç”³è¯·äº† 10G çš„å†…å­˜ç©ºé—´ï¼Œ ç„¶åç”¨äº†å…¶ä¸­ 1M å°±ç›´æ¥é€€å‡ºäº†ã€‚æŒ‰ç…§ç°åœ¨çš„åšæ³•ï¼Œæˆ‘ä»¬æ˜¾ç„¶äºå¤§äº†ï¼Œè¿›è¡Œäº†å¾ˆå¤šæ²¡æœ‰æ„ä¹‰çš„é¡µè¡¨æ“ä½œã€‚\nå¤„ç† 10G è¿ç»­çš„å†…å­˜é¡µé¢ï¼Œå¯¹åº”çš„ SV39 é¡µè¡¨å¤§è‡´å ç”¨å¤šå°‘å†…å­˜ (ä¼°ç®—æ•°é‡çº§å³å¯)ï¼Ÿ è¯·ç®€å•æ€è€ƒå¦‚ä½•æ‰èƒ½å®ç° Lazy ç­–ç•¥ï¼Œç¼ºé¡µæ—¶åˆå¦‚ä½•å¤„ç†ï¼Ÿæè¿°åˆç†å³å¯ï¼Œä¸éœ€è¦è€ƒè™‘å®ç°ã€‚ ç¼ºé¡µçš„å¦ä¸€ä¸ªå¸¸è§åŸå› æ˜¯ swap ç­–ç•¥ï¼Œä¹Ÿå°±æ˜¯å†…å­˜é¡µé¢å¯èƒ½è¢«æ¢åˆ°ç£ç›˜ä¸Šäº†ï¼Œå¯¼è‡´å¯¹åº”é¡µé¢å¤±æ•ˆã€‚\næ­¤æ—¶é¡µé¢å¤±æ•ˆå¦‚ä½•è¡¨ç°åœ¨é¡µè¡¨é¡¹(PTE)ä¸Šï¼Ÿ åŒé¡µè¡¨ä¸å•é¡µè¡¨\nä¸ºäº†é˜²èŒƒä¾§ä¿¡é“æ”»å‡»ï¼Œæˆ‘ä»¬çš„ os ä½¿ç”¨äº†åŒé¡µè¡¨ã€‚ä½†æ˜¯ä¼ ç»Ÿçš„è®¾è®¡ä¸€ç›´æ˜¯å•é¡µè¡¨çš„ï¼Œä¹Ÿå°±æ˜¯è¯´ï¼Œ ç”¨æˆ·çº¿ç¨‹å’Œå¯¹åº”çš„å†…æ ¸çº¿ç¨‹å…±ç”¨åŒä¸€å¼ é¡µè¡¨ï¼Œåªä¸è¿‡å†…æ ¸å¯¹åº”çš„åœ°å€åªå…è®¸åœ¨å†…æ ¸æ€è®¿é—®ã€‚ (å¤‡æ³¨ï¼šè¿™é‡Œçš„å•/åŒçš„è¯´æ³•ä»…ä¸ºè‡ªåˆ›çš„é€šä¿—è¯´æ³•ï¼Œå¹¶æ— è¿™ä¸ªåè¯æ¦‚å¿µï¼Œè¯¦æƒ…è§ KPTI )\nåœ¨å•é¡µè¡¨æƒ…å†µä¸‹ï¼Œå¦‚ä½•æ›´æ¢é¡µè¡¨ï¼Ÿ å•é¡µè¡¨æƒ…å†µä¸‹ï¼Œå¦‚ä½•æ§åˆ¶ç”¨æˆ·æ€æ— æ³•è®¿é—®å†…æ ¸é¡µé¢ï¼Ÿï¼ˆtips:çœ‹çœ‹ä¸Šä¸€é¢˜æœ€åä¸€é—®ï¼‰ å•é¡µè¡¨æœ‰ä½•ä¼˜åŠ¿ï¼Ÿï¼ˆå›ç­”åˆç†å³å¯ï¼‰ åŒé¡µè¡¨å®ç°ä¸‹ï¼Œä½•æ—¶éœ€è¦æ›´æ¢é¡µè¡¨ï¼Ÿå‡è®¾ä½ å†™ä¸€ä¸ªå•é¡µè¡¨æ“ä½œç³»ç»Ÿï¼Œä½ ä¼šé€‰æ‹©ä½•æ—¶æ›´æ¢é¡µè¡¨ï¼ˆå›ç­”åˆç†å³å¯ï¼‰ï¼Ÿ ç¬¬å››ç« -åœ°å€ç©ºé—´ç¬”è®° SV39 å¤šçº§é¡µè¡¨ ä¸‹å›¾æ˜¯æˆ‘è§‰å¾—æœ€èƒ½è®²æ¸… SV39 å¤šçº§é¡µè¡¨æœºåˆ¶çš„ï¼Œå¯¹æˆ‘çš„ç†è§£æœ‰å¾ˆå¤§å¸®åŠ©\u0008ï¼Œæ¥è‡ª 2022æ˜¥OS slides- lec5\nä¸€ä¸ªé¡µè¡¨æœ‰512é¡¹ï¼Œä¸€é¡¹çš„sizeä¸ºusizeï¼Œåœ¨RV64ä¸­å°±æ˜¯8å­—èŠ‚ï¼Œå› æ­¤ä¸€ä¸ªé¡µè¡¨åˆšå¥½å ä¸€ä¸ªç‰©ç†é¡µå¸§ï¼ˆ4Kï¼‰ï¼Œå› æ­¤è¦æ‰¾åˆ°æŸä¸€ä¸ªé¡µè¡¨ï¼Œåªéœ€è¦çŸ¥é“å…¶PPNï¼ˆoffsetä¸º0å³å¯ï¼‰\nè“è‰²æ¡†æ¡†ä»£è¡¨ä¸€ä¸ªè™šæ‹Ÿåœ°å€çš„ç»„æˆï¼Œå…¶ä¸­åªæœ‰ä½12+9+9+9ä½æ’ä¸Šäº†ç”¨åœºï¼Œé«˜ä½éƒ½æ˜¯æ²¡ç”¨çš„\nå…¶ä¸­ä¸‰ä¸ª9ä½çš„åˆ†åˆ«å¯¹åº”è¯¥åœ°å€åˆ†åˆ«åœ¨ä¸‰çº§é¡µè¡¨ä¸­çš„åç§»ï¼Œè€Œå‰ä¸€çº§é¡µè¡¨é¡¹ä¸­å°±å­˜ç€å½“å‰è¿™ä¸ªé¡µè¡¨çš„ç‰©ç†åœ°å€ ä¸€ä¸ªé¡µè¡¨é¡¹çš„ç»„æˆï¼š\nå·¦è¾¹ä¿ç•™æ— ç”¨ æ¥ç€æ˜¯PPN è¿˜æœ‰2ä½çš„ä¿ç•™ æœ€åæ˜¯flagsï¼Œæ ‡å¿—ç€ä¸‹ä¸€çº§çš„å„ç§ä¿¡æ¯ é—®ç­”ä½œä¸š è¯·åˆ—ä¸¾ SV39 é¡µè¡¨é¡µè¡¨é¡¹çš„ç»„æˆï¼Œæè¿°å…¶ä¸­çš„æ ‡å¿—ä½æœ‰ä½•ä½œç”¨\næˆ‘è®¤ä¸ºè¿™å¼ å›¾å¾ˆå¥½åœ°è¡¨è¾¾äº† SV39 å¤šçº§é¡µè¡¨çš„ç»“æ„ï¼Œè™šæ‹Ÿåœ°å€åˆ†æˆ EXTï¼ˆæ²¡ç”¨ï¼‰ï¼Œåœ¨ä¸‰çº§é¡µè¡¨ä¸­çš„åç§»ï¼ˆor ç´¢å¼•ï¼‰ï¼Œä»¥åŠåç§»åœ°å€ã€‚\nç¬¬ä¸€çº§é¡µè¡¨çš„åŸºå€å­˜åœ¨ satp å¯„å­˜å™¨é‡Œï¼Œåœ¨åˆ‡æ¢ä»»åŠ¡çš„æ—¶å€™ä¼šåˆ‡æ¢ satpï¼Œå®ç°äº†ä¸åŒåº”ç”¨çš„åœ°å€éš”ç¦»ï¼Œå› ä¸ºä¸ä¼šè®¿é—®åˆ°åŒä¸€ä¸ªé¡µè¡¨ã€‚\nå‰ä¸¤çº§é¡µè¡¨åˆ†ä¸º PPN å’Œ FLags ä¸¤éƒ¨åˆ†ï¼Œå‰è€…ä»£è¡¨ä¸‹ä¸€\u0008é¡µè¡¨çš„åŸºå€ï¼ˆä¸€ä¸ªé¡µè¡¨æœ‰ 512 ä¸ª PTE ï¼Œ\u0008ä¸€ä¸ª PTE çš„é•¿åº¦ä¸º usizeï¼Œåœ¨ RV64 ä¸‹ä¸º 64bitï¼Œå› æ­¤ä¸€ä¸ªé¡µè¡¨åˆšå¥½å ä¸€ä¸ªç‰©ç†é¡µï¼Œ4K ï¼‰ã€‚\næœ€ç»ˆç”±ä¸‰çº§é¡µè¡¨çš„ PPN è·Ÿ VA çš„ Offset ç»„åˆæˆäº†ç‰©ç†åœ°å€ã€‚\næ ‡å¿—ä½å¦‚ä¸Šå›¾ï¼Œè¨€ç®€æ„èµ…ï¼Œéœ€è¦æ³¨æ„çš„æ˜¯ [10: 8] è¢« RSW å æ®ï¼Œä¿ç•™ç”¨è€Œå·²ï¼Œæ²¡æœ‰å…¶ä»–ä½œç”¨ã€‚\nç¼ºé¡µ\nç¼ºé¡µæŒ‡çš„æ˜¯è¿›ç¨‹è®¿é—®é¡µé¢æ—¶é¡µé¢ä¸åœ¨é¡µè¡¨ä¸­æˆ–åœ¨é¡µè¡¨ä¸­æ— æ•ˆçš„ç°è±¡ï¼Œæ­¤æ—¶ MMU å°†ä¼šè¿”å›ä¸€ä¸ªä¸­æ–­ï¼Œ å‘ŠçŸ¥ os è¿›ç¨‹å†…å­˜è®¿é—®å‡ºäº†é—®é¢˜ã€‚os é€‰æ‹©å¡«è¡¥é¡µè¡¨å¹¶é‡æ–°æ‰§è¡Œå¼‚å¸¸æŒ‡ä»¤æˆ–è€…æ€æ­»è¿›ç¨‹ã€‚\nè¯·é—®å“ªäº›å¼‚å¸¸å¯èƒ½æ˜¯ç¼ºé¡µå¯¼è‡´çš„ï¼Ÿ å‘ç”Ÿç¼ºé¡µæ—¶ï¼Œæè¿°ç›¸å…³é‡è¦å¯„å­˜å™¨çš„å€¼ï¼Œä¸Šæ¬¡å®éªŒæè¿°è¿‡çš„å¯ä»¥ç®€ç•¥ã€‚ ç¼ºé¡µæœ‰ä¸¤ä¸ªå¸¸è§çš„åŸå› ï¼Œå…¶ä¸€æ˜¯ Lazy ç­–ç•¥ï¼Œä¹Ÿå°±æ˜¯ç›´åˆ°å†…å­˜é¡µé¢è¢«è®¿é—®æ‰å®é™…è¿›è¡Œé¡µè¡¨æ“ä½œã€‚ æ¯”å¦‚ï¼Œä¸€ä¸ªç¨‹åºè¢«æ‰§è¡Œæ—¶ï¼Œè¿›ç¨‹çš„ä»£ç æ®µç†è®ºä¸Šéœ€è¦ä»ç£ç›˜åŠ è½½åˆ°å†…å­˜ã€‚ä½†æ˜¯ os å¹¶ä¸ä¼šé©¬ä¸Šè¿™æ ·åšï¼Œ è€Œæ˜¯ä¼šä¿å­˜ .text æ®µåœ¨ç£ç›˜çš„ä½ç½®ä¿¡æ¯ï¼Œåœ¨è¿™äº›ä»£ç ç¬¬ä¸€æ¬¡è¢«æ‰§è¡Œæ—¶æ‰å®Œæˆä»ç£ç›˜çš„åŠ è½½æ“ä½œã€‚\nè¿™æ ·åšæœ‰å“ªäº›å¥½å¤„ï¼Ÿ å…¶å®ï¼Œæˆ‘ä»¬çš„ mmap ä¹Ÿå¯ä»¥é‡‡å– Lazy ç­–ç•¥ï¼Œæ¯”å¦‚ï¼šä¸€ä¸ªç”¨æˆ·è¿›ç¨‹å…ˆåç”³è¯·äº† 10G çš„å†…å­˜ç©ºé—´ï¼Œ ç„¶åç”¨äº†å…¶ä¸­ 1M å°±ç›´æ¥é€€å‡ºäº†ã€‚æŒ‰ç…§ç°åœ¨çš„åšæ³•ï¼Œæˆ‘ä»¬æ˜¾ç„¶äºå¤§äº†ï¼Œè¿›è¡Œäº†å¾ˆå¤šæ²¡æœ‰æ„ä¹‰çš„é¡µè¡¨æ“ä½œã€‚\nå¤„ç† 10G è¿ç»­çš„å†…å­˜é¡µé¢ï¼Œå¯¹åº”çš„ SV39 é¡µè¡¨å¤§è‡´å ç”¨å¤šå°‘å†…å­˜ (ä¼°ç®—æ•°é‡çº§å³å¯)ï¼Ÿ è¯·ç®€å•æ€è€ƒå¦‚ä½•æ‰èƒ½å®ç° Lazy ç­–ç•¥ï¼Œç¼ºé¡µæ—¶åˆå¦‚ä½•å¤„ç†ï¼Ÿæè¿°åˆç†å³å¯ï¼Œä¸éœ€è¦è€ƒè™‘å®ç°ã€‚ ç¼ºé¡µçš„å¦ä¸€ä¸ªå¸¸è§åŸå› æ˜¯ swap ç­–ç•¥ï¼Œä¹Ÿå°±æ˜¯å†…å­˜é¡µé¢å¯èƒ½è¢«æ¢åˆ°ç£ç›˜ä¸Šäº†ï¼Œå¯¼è‡´å¯¹åº”é¡µé¢å¤±æ•ˆã€‚\næ­¤æ—¶é¡µé¢å¤±æ•ˆå¦‚ä½•è¡¨ç°åœ¨é¡µè¡¨é¡¹(PTE)ä¸Šï¼Ÿ åŒé¡µè¡¨ä¸å•é¡µè¡¨\nä¸ºäº†é˜²èŒƒä¾§ä¿¡é“æ”»å‡»ï¼Œæˆ‘ä»¬çš„ os ä½¿ç”¨äº†åŒé¡µè¡¨ã€‚ä½†æ˜¯ä¼ ç»Ÿçš„è®¾è®¡ä¸€ç›´æ˜¯å•é¡µè¡¨çš„ï¼Œä¹Ÿå°±æ˜¯è¯´ï¼Œ ç”¨æˆ·çº¿ç¨‹å’Œå¯¹åº”çš„å†…æ ¸çº¿ç¨‹å…±ç”¨åŒä¸€å¼ é¡µè¡¨ï¼Œåªä¸è¿‡å†…æ ¸å¯¹åº”çš„åœ°å€åªå…è®¸åœ¨å†…æ ¸æ€è®¿é—®ã€‚ (å¤‡æ³¨ï¼šè¿™é‡Œçš„å•/åŒçš„è¯´æ³•ä»…ä¸ºè‡ªåˆ›çš„é€šä¿—è¯´æ³•ï¼Œå¹¶æ— è¿™ä¸ªåè¯æ¦‚å¿µï¼Œè¯¦æƒ…è§ KPTI )\nåœ¨å•é¡µè¡¨æƒ…å†µä¸‹ï¼Œå¦‚ä½•æ›´æ¢é¡µè¡¨ï¼Ÿ å•é¡µè¡¨æƒ…å†µä¸‹ï¼Œå¦‚ä½•æ§åˆ¶ç”¨æˆ·æ€æ— æ³•è®¿é—®å†…æ ¸é¡µé¢ï¼Ÿï¼ˆtips:çœ‹çœ‹ä¸Šä¸€é¢˜æœ€åä¸€é—®ï¼‰ å•é¡µè¡¨æœ‰ä½•ä¼˜åŠ¿ï¼Ÿï¼ˆå›ç­”åˆç†å³å¯ï¼‰ åŒé¡µè¡¨å®ç°ä¸‹ï¼Œä½•æ—¶éœ€è¦æ›´æ¢é¡µè¡¨ï¼Ÿå‡è®¾ä½ å†™ä¸€ä¸ªå•é¡µè¡¨æ“ä½œç³»ç»Ÿï¼Œä½ ä¼šé€‰æ‹©ä½•æ—¶æ›´æ¢é¡µè¡¨ï¼ˆå›ç­”åˆç†å³å¯ï¼‰ï¼Ÿ ","date":"2022-07-18T00:29:54+08:00","permalink":"/p/rcore-camp-2022-lab2-%E8%AE%B0%E5%BD%95/","title":"rCore Camp 2022 Lab2 è®°å½•"},{"content":"rCoreCamp2022-lab1è®°å½• Lab1æœ¬ä½“ labåœ°å€\nå®ç°ä»¥ä¸‹å‡½æ•°çš„åŠŸèƒ½\n1 2 3 4 5 6 fn sys_task_info(ti: *mut TaskInfo) -\u0026gt; isize struct TaskInfo { status: TaskStatus, syscall_times: [u32; MAX_SYSCALL_NUM], time: usize } åˆ†è§£éœ€æ±‚ è®© TASK_MANAGER æœ‰è·å– task çŠ¶æ€çš„èƒ½åŠ› è®© TASK_MANAGER æœ‰æ›´æ–° task çŠ¶æ€çš„èƒ½åŠ› å®ç° å…¶å®å°±æ˜¯å¯¹ TASK_MANAGER ç®¡ç†çš„æ¯ä¸ª task ç»´æŠ¤ä¸€ä¸ª TaskInfo çš„å¯¹è±¡ï¼Œæ¯æ¬¡ syscall çš„æ—¶å€™è¿›è¡Œè®°å½•ã€‚\nå› æ­¤æˆ‘ä»¬ç»™ Task çš„å¯¹è±¡åŠ å…¥ä¸€ä¸ªæ–°çš„ inner å­—æ®µï¼Œç»´æŠ¤è¯¥ä»»åŠ¡å¼€å§‹æ—¶é—´å’Œç³»ç»Ÿè°ƒç”¨æƒ…å†µã€‚\nä¹‹åç»™ TASK_MANAGER åŠ  set å’Œ get çš„èƒ½åŠ›ï¼Œéƒ½æŒºå¥½æ‡‚çš„\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 // src/task/mod.rs fn set_syscall_times(\u0026amp;self, syscall_id: usize) { let mut inner = self.inner.exclusive_access(); let current_id = inner.current_task; inner.tasks[current_id].task_info_inner.syscall_times[syscall_id] += 1; } fn get_current_task_info(\u0026amp;self, ti: *mut TaskInfo) { let inner = self.inner.exclusive_access(); let current_id = inner.current_task; let TaskInfoInner {syscall_times, start_time} = inner.tasks[current_id].task_info_inner; unsafe { *ti = TaskInfo { status: TaskStatus::Running, syscall_times, time: get_time_ms() - start_time, }; } } ç„¶åå¯¹å¤–æä¾›æ¥å£\n1 2 3 4 5 6 7 pub fn record_syscall(syscall_id: usize) { TASK_MANAGER.set_syscall_times(syscall_id); } pub fn get_task_info(ti: *mut TaskInfo) { TASK_MANAGER.get_current_task_info(ti); } æ¯æ¬¡è°ƒç”¨syscallçš„æ—¶å€™è®°å½•ä¸€ä¸‹å°±è¡Œäº†ã€‚\nç®€ç­”ä½œä¸š æ­£ç¡®è¿›å…¥ U æ€åï¼Œç¨‹åºçš„ç‰¹å¾è¿˜åº”æœ‰ï¼šä½¿ç”¨ S æ€ç‰¹æƒæŒ‡ä»¤ï¼Œè®¿é—® S æ€å¯„å­˜å™¨åä¼šæŠ¥é”™ã€‚ è¯·åŒå­¦ä»¬å¯ä»¥è‡ªè¡Œæµ‹è¯•è¿™äº›å†…å®¹ (è¿è¡Œ Rust ä¸‰ä¸ª bad æµ‹ä¾‹ (ch2b_bad_*.rs) ï¼Œ æ³¨æ„åœ¨ç¼–è¯‘æ—¶è‡³å°‘éœ€è¦æŒ‡å®š LOG=ERROR æ‰èƒ½è§‚å¯Ÿåˆ°å†…æ ¸çš„æŠ¥é”™ä¿¡æ¯) ï¼Œ æè¿°ç¨‹åºå‡ºé”™è¡Œä¸ºï¼ŒåŒæ—¶æ³¨æ„æ³¨æ˜ä½ ä½¿ç”¨çš„ sbi åŠå…¶ç‰ˆæœ¬ã€‚\næ·±å…¥ç†è§£ trap.S ä¸­ä¸¤ä¸ªå‡½æ•° __alltrapså’Œ__restoreçš„ä½œç”¨ï¼Œå¹¶å›ç­”å¦‚ä¸‹é—®é¢˜:\nL40ï¼šåˆšè¿›å…¥ __restore æ—¶ï¼Œa0 ä»£è¡¨äº†ä»€ä¹ˆå€¼ã€‚è¯·æŒ‡å‡º __restore çš„ä¸¤ç§ä½¿ç”¨æƒ…æ™¯ã€‚\nåœ¨L37æœ‰ä¸€è¡Œmv a0, spçš„æŒ‡ä»¤ï¼Œè¿™æ˜¯addi a0, sp, 0çš„è¯­æ³•ç³–ï¼Œå…¶å®å°±æ˜¯movï¼Œåœ¨__alltrapsé‡Œæ˜¯ç»™å‚æ•°èµ‹å€¼ï¼Œä½†æ˜¯åœ¨ä¹‹åa0å¹¶æ²¡æœ‰å†æ¬¡å‡ºç°è¿‡ï¼Œç»“åˆtrap_handlerçš„å‚æ•°å’Œè¿”å›å€¼ï¼Œå¯ä»¥è®¤ä¸ºåˆè¢«è¿”å›å›å»äº†ï¼Œæ‰€ä»¥a0ç›´åˆ°__restoreæ—¶éƒ½æ˜¯taskContextã€‚\n__restoreå°è£…åœ¨goto_restoreé‡Œï¼Œæˆ‘ä»¬ctrl få…¨å±€æ‰¾ä¸€ä¸‹å¯ä»¥çœ‹åˆ°å”¯ä¸€å¼•ç”¨çš„åœ°æ–¹ï¼šTASK_MANAGERçš„åˆå§‹åŒ–\nè¿™ä¸ªåœ°æ–¹æŠŠæ¯ä¸ªåº”ç”¨çš„ä¸Šä¸‹æ–‡ï¼ˆåŒ…æ‹¬32ä¸ªå¯„å­˜å™¨ã€sepcã€sstatuså€¼ï¼‰å­˜èµ·æ¥è¿”å›ç„¶åä»supervisorè¿”å›åˆ°user\nå…¶å®æ‰€æœ‰ä» supervisor =\u0026gt; user éƒ½å¯ä»¥ä½¿ç”¨__restoreï¼Œè·Ÿ__alltrapsæ˜¯åè¿‡æ¥çš„ï¼Œå¯¹å¶ä½¿ç”¨ï¼Œå¦ä¸€ç§åœºæ™¯æƒ³ä¸å‡ºæ¥â€¦â€¦ã€‚\nL46-L51ï¼šè¿™å‡ è¡Œæ±‡ç¼–ä»£ç ç‰¹æ®Šå¤„ç†äº†å“ªäº›å¯„å­˜å™¨ï¼Ÿè¿™äº›å¯„å­˜å™¨çš„çš„å€¼å¯¹äºè¿›å…¥ç”¨æˆ·æ€æœ‰ä½•æ„ä¹‰ï¼Ÿè¯·åˆ†åˆ«è§£é‡Šã€‚\n1 2 3 4 5 6 ld t0, 32*8(sp) ld t1, 33*8(sp) ld t2, 2*8(sp) csrw sstatus, t0 csrw sepc, t1 csrw sscratch, t2 t0ç»™äº† sstatusï¼Œæ˜¯ trap å‘ç”Ÿå‰ cpu ç‰¹æƒçº§çš„ä¿¡æ¯ï¼ˆå¦‚S/Uï¼‰\nt1ç»™äº† sepcï¼Œæ˜¯ trap å‘ç”Ÿå‰æ‰§è¡Œçš„æœ€åä¸€æ¡æŒ‡ä»¤çš„åœ°å€\nt2ç»™äº† sscratchï¼Œæ˜¯åŸæ¥ user stack çš„ sp\nè¿™ä»¨éƒ½æ˜¯ç”¨æ¥æ¢å¤çŠ¶æ€çš„ï¼ˆåœ¨è¿›å…¥supervisorçš„æ—¶å€™æŠŠåŸæ¥ä¿¡æ¯å­˜åœ¨è¿™é‡Œé¢äº†ï¼‰\nL53-L59ï¼šä¸ºä½•è·³è¿‡äº† x2 å’Œ x4ï¼Ÿ\né—®é¢˜2å’Œ3éƒ½åœ¨ç‰¹æƒçº§äº¤æ¢è¿™ç« é‡Œè®²äº†ï¼Œx2æ˜¯ sp(stack pointer) ï¼Œx4 æ˜¯ tp(thread pointer)\nè·³è¿‡x2ï¼šç”¨æˆ·æ ˆçš„æ ˆæŒ‡é’ˆä¿å­˜åœ¨ sscratch ä¸­ï¼Œå¿…é¡»é€šè¿‡ \u0026lt;span class=\u0026quot;pre\u0026quot;\u0026gt;csrr\u0026lt;/span\u0026gt; æŒ‡ä»¤è¯»åˆ°é€šç”¨å¯„å­˜å™¨ä¸­åæ‰èƒ½ä½¿ç”¨ï¼Œå› æ­¤æˆ‘ä»¬å…ˆè€ƒè™‘ä¿å­˜å…¶å®ƒé€šç”¨å¯„å­˜å™¨ï¼Œè…¾å‡ºç©ºé—´ã€‚\nè·³è¿‡x4ï¼šéç‰¹æ®Šæƒ…å†µä¸éœ€è¦ç”¨åˆ°x4ï¼ˆå­˜ç–‘ï¼Ÿï¼‰\nL63ï¼šè¯¥æŒ‡ä»¤ä¹‹å sp å’Œ sscratch ä¸­çš„å€¼åˆ†åˆ«æœ‰ä»€ä¹ˆæ„ä¹‰ï¼Ÿ\n1 csrrw sp, sscratch, sp csrrw r1, r2, r3çš„æ„æ€æ˜¯æŠŠ r2 å†™è¿› r1 ï¼ŒæŠŠ r3 å†™è¿› r2 ï¼Œåœ¨ä¸Šé¢å°±æ˜¯äº¤æ¢ sp å’Œ sscratch çš„æ„æ€ã€‚\nsp åŸæ¥æ˜¯ç”¨æˆ·æ ˆï¼Œsscratch åŸæ¥æ˜¯å†…æ ¸æ ˆï¼Œäº¤æ¢å sp æŒ‡å‘ kernel stackï¼Œ sscratch æŒ‡å‘ user stack\n__restore: ä¸­å‘ç”ŸçŠ¶æ€åˆ‡æ¢åœ¨å“ªä¸€æ¡æŒ‡ä»¤ï¼Ÿä¸ºä½•è¯¥æŒ‡ä»¤æ‰§è¡Œä¹‹åä¼šè¿›å…¥ç”¨æˆ·æ€ï¼Ÿ\næˆ‘çŒœæ˜¯csrw sstatus, t0ï¼Œsstatusä»£è¡¨ç”¨æˆ·çŠ¶æ€\nL13ï¼šè¯¥æŒ‡ä»¤ä¹‹åï¼Œsp å’Œ sscratch ä¸­çš„å€¼åˆ†åˆ«æœ‰ä»€ä¹ˆæ„ä¹‰ï¼Ÿ\nåŒ4ï¼Œåè¿‡æ¥ï¼ˆæ€€ç–‘ä¸Šé¢L63æ˜¯ç¬”è¯¯\nä» U æ€è¿›å…¥ S æ€æ˜¯å“ªä¸€æ¡æŒ‡ä»¤å‘ç”Ÿçš„ï¼Ÿ\nçœ‹ä¸å‡ºæ¥â€¦â€¦å› ä¸ºç°åœºæ²¡æœ‰æ”¹å˜ sstatus çš„ã€‚\n","date":"2022-07-14T01:20:44+08:00","permalink":"/p/rcore-camp-2022-lab1-%E8%AE%B0%E5%BD%95/","title":"rCore Camp 2022 Lab1 è®°å½•"},{"content":"chap 1. è®¡ç®—æœºæŠ½è±¡åŠç›¸å…³æŠ€æœ¯ å…«ä¸ªä¼Ÿå¤§æ€æƒ³ï¼š é¢å‘æ‘©å°”å®šå¾‹çš„è®¾è®¡\nè®¾è®¡èŠ¯ç‰‡çš„æ—¶å€™è¦è€ƒè™‘æœªæ¥å·¥è‰ºï¼Œéœ€è¦è¶…å‰ç‚¹ ä½¿ç”¨æŠ½è±¡ç®€åŒ–è®¾è®¡ åŠ é€Ÿç»å¸¸æ€§äº‹ä»¶ é€šè¿‡å¹¶è¡Œæé«˜æ€§èƒ½ é€šè¿‡æµæ°´çº¿æé«˜æ€§èƒ½ é€šè¿‡é¢„æµ‹æé«˜æ€§èƒ½ å­˜å‚¨å±‚æ¬¡\nMemory Hierarchy é€šè¿‡å†—ä½™æé«˜å¯é æ€§ chap2 æŒ‡ä»¤ RVå­—æ®µ Rå‹ï¼ˆç”¨äºå¯„å­˜å™¨ï¼‰ funct7 rs2 rs1 funct3 rd opcode æ€»å…± 7ä½ 5ä½ 5ä½ 3ä½ 5ä½ 7ä½ 32ä½ opcodeï¼šæŒ‡ä»¤åŸºæœ¬æ“ä½œ rdï¼šç›®çš„æ“ä½œæ•°å¯„å­˜å™¨ï¼Œå­˜æ”¾ç»“æœ funct3ï¼šä¸€ä¸ªå¦å¤–çš„æ“ä½œç å­—æ®µ rs1ï¼šç¬¬ä¸€ä¸ªæºæ“ä½œæ•°å¯„å­˜å™¨ rs2ï¼šç¬¬äºŒä¸ªæºæ“ä½œæ•°å¯„å­˜å™¨ funct7ï¼šä¸€ä¸ªå¦å¤–çš„æ“ä½œç å­—æ®µ funct3å’Œfunct7ç”¨æ¥è¡¨ç¤ºopcodeçš„é™„åŠ å­—æ®µï¼ˆæ¯”å¦‚addå’Œsubçš„opcodeéƒ½æ˜¯0110011ï¼Œè€Œaddçš„funct7æ˜¯0000000ï¼Œsubçš„æ˜¯0100000\nIå‹ï¼ˆç”¨äºå¸¦å¸¸æ•°çš„ç®—æ•°æŒ‡ä»¤å’ŒåŠ è½½æŒ‡ä»¤ï¼‰ immediate rs1 funct3 rd opcode æ€»å…± 7ä½ 5ä½ 3ä½ 5ä½ 7ä½ 32ä½ immediateä¸ºè¡¥ç ï¼Œå¯ä»¥è¡¨ç¤º-2^11^ åˆ°2^11^ - 1ä¹‹é—´çš„æ•´æ•°ï¼Œå½“Iå‹æ ¼å¼ç”¨äºåŠ è½½æŒ‡ä»¤æ—¶ï¼Œimmediateè¡¨ç¤ºä¸€ä¸ªåç§»é‡ ldæŒ‡ä»¤çš„funct3ä¸º3 Så‹ï¼ˆç”¨äºStoreï¼‰ immediate[11:5] rs2 rs1 funct3 immediate[4:0] opcode æ€»å…± 7ä½ 5ä½ 5ä½ 3ä½ 5ä½ 7ä½ 32ä½ immediateè®¾è®¡æˆä¸¤ä¸ªå­—æ®µæ˜¯å› ä¸ºæƒ³æŠŠrs2å’Œrs1è·Ÿä¸Šé¢çš„å¤„äºåŒä¸€ä½ç½®ï¼Œé™ä½ç¡¬ä»¶å¤æ‚æ€§ï¼Œfunct3å’Œopcodeä¹Ÿæ˜¯åŒä¸€ä½ç½® é€»è¾‘æ“ä½œ RVé‡Œæ²¡æœ‰!çš„é€»è¾‘æ“ä½œï¼Œå¯ä»¥ä½¿ç”¨xxx XOR å…¨FFå®ç°\nç§»ä½æ“ä½œæ˜¯Iå‹æ ¼å¼ï¼Œå› ä¸ºåªç”¨åˆ°immediateçš„ä½6ä½å­—æ¯ï¼ˆä¸èƒ½ç§»è¶…è¿‡63æ¬¡ï¼‰ï¼Œæ‰€ä»¥é«˜6ä½è¢«å½“åšå¦å¤–çš„æ“ä½œç å­—æ®µï¼Œå³funct6\nè°ƒç”¨çº¦å®š x10~x17ï¼šå…«ä¸ªï¼Œç”¨äºä¼ å‚/è¿”å›å€¼\nx0ï¼šä¸€å®šæ˜¯å¸¸é‡0ï¼Œå¦‚æœè¯•å›¾æ›´æ”¹ä¼šè¢«ç›´æ¥ä¸¢å¼ƒ\nx1ï¼šè¿”å›åœ°å€å¯„å­˜å™¨ï¼Œç”¨äºè¿”å›åˆ°èµ·å§‹ç‚¹\nè·³è½¬-é“¾æ¥æŒ‡ä»¤ï¼ˆjalï¼‰ï¼šè·³è½¬åˆ°æŸä¸ªåœ°å€çš„åŒæ—¶å°†ä¸‹ä¸€æ¡æŒ‡ä»¤çš„åœ°å€ä¿å­˜åˆ°ç›®æ ‡å¯„å­˜å™¨rd\njal x1, ProcedureAddressï¼šè·³è½¬åˆ°ProcedureAddresså¹¶æŠŠè¿”å›åœ°å€å†™å…¥x1 RVä¸­x2æ˜¯æ ˆæŒ‡é’ˆï¼ˆstack pointer/ spï¼‰\nRVæŠŠ19ä¸ªå¯„å­˜å™¨åˆ†æˆä¸¤ç»„ï¼š\nx5~x7ä»¥åŠx28~x31ï¼šä¸´æ—¶å¯„å­˜å™¨ï¼Œè¿‡ç¨‹è°ƒç”¨é‡Œä¸è¢«ã€è¢«è°ƒç”¨è€…ï¼ˆcalleeï¼‰ã€‘ä¿å­˜ x8~x9ä»¥åŠx18~x27ï¼šä¿å­˜å¯„å­˜å™¨ï¼Œåœ¨è¿‡ç¨‹è°ƒç”¨é‡Œå¿…é¡»è¢«ä¿å­˜ RVä½¿ç”¨å¸§æŒ‡é’ˆï¼ˆframe pointerï¼‰æ¥è¡¨ç¤ºè¿‡ç¨‹å¸§çš„ç¬¬ä¸€ä¸ªåŒå­—ï¼ˆç±»ä¼¼x64çš„rbpï¼‰\nè¶…è¿‡8ä¸ªå‚æ•°æ€ä¹ˆåŠï¼Ÿè·Ÿx86çš„å¤„ç†æ–¹å¼ä¸€æ ·ï¼Œé¢å¤–çš„æ”¾stackä¸Š\nå¤§ç«‹å³æ•°å¤„ç† luiæŒ‡ä»¤ï¼ˆload upper immediateï¼‰ å–ç«‹å³æ•°é«˜ä½ï¼Œå°†20ä½å¸¸æ•°åŠ è½½åˆ°å¯„å­˜å™¨çš„31åˆ°12ä½ï¼Œå¹¶æŠŠ31ä½å¤åˆ¶å¡«å……åˆ°æœ€å·¦è¾¹32ä½ï¼Œæœ€å³è¾¹12ä½ç”¨0å¡«å……ã€‚\nè¿™æ¡æŒ‡ä»¤å…è®¸ä½¿ç”¨ä¸¤æ¡æŒ‡ä»¤åˆ›å»º32ä½å¸¸é‡ã€‚luiçš„æŒ‡ä»¤æ ¼å¼ä¸ºUå‹ï¼Œå› ä¸ºå…¶ä»–çš„ä¸æ”¯æŒå¤§å¸¸é‡ã€‚\nåŠ è½½ä¸€ä¸ªå¤§å¸¸é‡çš„è¿‡ç¨‹å¦‚lui x19, 12åˆ°31ä½çš„æ•°; addi x19, x19, ä½12ä½çš„æ•°\nåˆ†æ”¯å¯»å€ åˆ†æ”¯æŒ‡ä»¤ä½¿ç”¨SBå‹æŒ‡ä»¤ï¼Œå¯ä»¥è¡¨ç¤º-4096åˆ°4094çš„åˆ†æ”¯åœ°å€ï¼Œä»¥2çš„å€æ•°è¡¨ç¤ºã€‚\nSBå‹ æ¯”å¦‚bne x10, x11, 2000 // if x10 != x11, goto location 2000\nè¡¨ç¤ºä¸º\nimm[12] imm[10:5] rs2 rs1 funct3 imm[4:1] imm[11] opcode 0 111110 01011 01010 001 1000 0 1100111 opcode=1100111æ˜¯æ¡ä»¶åˆ†æ”¯çš„æ“ä½œç ï¼Œbneçš„funct3æ˜¯001\nå”¯ä¸€ä½¿ç”¨UJå‹çš„jalæŒ‡ä»¤ï¼ˆæ— æ¡ä»¶è·³è½¬-é“¾æ¥ï¼‰ æ¯”å¦‚jal x0, 2000 // goto location 2000 = 0111 1101 0000\nimm[20] imm[10:1] imm[11] imm[19:12] rd opcode 0 11 1110 1000 0 0000 0000 0 0000 110 1111 ä½†æ˜¯20ä½çš„åœ°å€ç©ºé—´å¤ªå°äº†ï¼Œå¦ä¸€ç§æ–¹æ³•ä½¿ç”¨å¯„å­˜å™¨+åç§»çš„æ–¹å¼ï¼Œèƒ½å¤Ÿæ‰©å¤§åˆ°2^64^\nä½¿ç”¨å“ªä¸ªå¯„å­˜å™¨ï¼Ÿ\nSPECåŸºå‡†æµ‹è¯•é‡Œæœ‰ä¸€åŠçš„æ¡ä»¶åˆ†æ”¯è·³åˆ°å°äº16è·ç¦»çš„ä½ç½®\nå› æ­¤å¦‚æœç”¨PCæ¥å½“åŸºå€ï¼Œé‚£å°±å¾ˆç†æƒ³ï¼Œè¿™ç§å«PCç›¸å¯¹å¯»å€ï¼ŒRVå¯¹æ¡ä»¶åˆ†æ”¯å’Œæ— æ¡ä»¶è·³è½¬ä½¿ç”¨PCç›¸å¯¹å¯»å€ã€‚åœ¨RVé‡ŒPCç›¸å¯¹åå€šè¡¨ç¤ºåˆ†æ”¯å’Œç›®æ ‡æŒ‡ä»¤ä¹‹é—´çš„åŠå­—æ•°ï¼ˆ2 bytesï¼‰ï¼Œjalé‡Œ20ä½å¯ä»¥ç¼–ç PCÂ±2^19^ä¸ªåŠå­—/ Â±1MBçš„è·ç¦»\nåŒæ­¥ atomic exchangeåŸè¯­ jyyè®²è¿‡ï¼Œæ‹¿1å»å¯¹ğŸ”å˜é‡ä¸æ–­äº¤æ¢ï¼Œäº¤æ¢å‡ºæ¥0è¯´æ˜æ‹¿åˆ°é”äº†ï¼Œäº¤æ¢å‡ºæ¥1è¯´æ˜æ²¡æ‹¿åˆ°ï¼ˆè¢«å ç”¨ï¼‰\næŒ‡ä»¤å¯¹ ç¬¬äºŒæ¡æŒ‡ä»¤è¿”å›ä¸€ä¸ªå€¼ï¼Œè¡¨ç¤ºè¯¥æŒ‡ä»¤å¯¹æ˜¯å¦è¢«åŸå­æ‰§è¡Œã€‚\nè¿™å¯¹æŒ‡ä»¤æŒ‡ä¿ç•™åŠ è½½ï¼ˆload-reservedï¼‰åŒå­—çš„ç‰¹æ®ŠåŠ è½½æŒ‡ä»¤ï¼ˆç§°ä¸ºlr.dï¼‰å’Œä¸€ä¸ªæ¡ä»¶å­˜å‚¨ï¼ˆsotre-conditionalï¼‰åŒå­—çš„ç‰¹æ®Šå­˜å‚¨æŒ‡ä»¤ï¼ˆç§°ä¸ºsc.dï¼‰ï¼Œå¦‚æœåŠ è½½çš„å†…å®¹è·Ÿå­˜å‚¨å‰æ¢æµ‹åˆ°çš„å†…å®¹ä¸åŒï¼Œæ¡ä»¶å­˜å‚¨å°±ä¼šå¤±è´¥ï¼Œä¸ä¼šå†™å…¥å†…å­˜ã€‚æˆåŠŸå°±ä¼šæŠŠå¦ä¸€ä¸ªå¯„å­˜å™¨çš„å€¼æ›´æ”¹ä¸º0ï¼Œå¦‚æœå¤±è´¥å°±æ”¹æˆé0ã€‚\nsc.dæŒ‡å®šäº†ä¸‰ä¸ªå¯„å­˜å™¨ï¼šä¿å­˜åœ°å€ã€æŒ‡ç¤ºåŸå­æ“ä½œå¤±è´¥æˆåŠŸã€å¦‚æœæˆåŠŸå°±æŠŠæŒ‡å†™å…¥å†…å­˜ã€‚\nä¸Šé¢çš„è¿‡ç¨‹å®ç°äº†åœ¨x20æŒ‡å®šçš„å†…å­˜ä¸Šçš„åŸå­äº¤æ¢ï¼Œå³atomic_exchange(x23, mem[x20]\né“¾æ¥ ä¸‰ä¸ªå·¥ä½œæ­¥éª¤ï¼š\nå°†ä»£ç å’Œæ•°æ®æ¨¡å—æŒ‰ç¬¦å·ç‰¹å¾æ”¾å…¥å†…å­˜ å†³å®šæ•°æ®å’ŒæŒ‡ä»¤æ ‡ç­¾çš„åœ°å€ ä¿®æ­£å†…éƒ¨å’Œå¤–éƒ¨å¼•ç”¨ MIPS vs RISC-V ç›¸åŒ ä¸åŒ é™¤äº†eqã€neqå¤–çš„æ¡ä»¶åˆ†æ”¯ã€‚RVåªæä¾›åˆ†æ”¯æŒ‡ä»¤æ¥æ¯”è¾ƒä¸¤ä¸ªå¯„å­˜å™¨ï¼Œè€ŒMIPSæä¾›æ¯”è¾ƒæŒ‡ä»¤ï¼ŒæŠŠæ¯”è¾ƒç»“æœå†™å…¥ä¸€ä¸ªå¯„å­˜å™¨ï¼ˆ0 or 1ï¼‰ MIPSåªæ‰§è¡Œå°äºæ¯”è¾ƒï¼Œå­˜åœ¨æœ‰ç¬¦å·å’Œæ— ç¬¦å·ç‰ˆæœ¬ï¼ˆsltå’Œsltuï¼‰ å®Œæ•´çš„MIPSæŒ‡ä»¤ç³»ç»Ÿ \u0026raquo; RSIC-V æ€»ç»“ è®²äº†æŒ‡ä»¤ç³»ç»Ÿä½“ç³»ç»“æ„ISAï¼ˆInstruction Set Architectureï¼‰çš„å†å² RVçš„æŒ‡ä»¤ç»“æ„ å®ç°åŒæ­¥ RVä¸x86ã€MIPSçš„æ¯”è¾ƒ ","date":"2022-07-11T01:37:38+08:00","permalink":"/p/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E8%AE%BE%E8%AE%A1-%E8%BD%AF%E4%BB%B6%E7%A1%AC%E4%BB%B6%E6%8E%A5%E5%8F%A3-risc-v%E7%89%88%E7%AC%94%E8%AE%B0/","title":"è®¡ç®—æœºç»„æˆè®¾è®¡-è½¯ä»¶ç¡¬ä»¶æ¥å£-RISC-Vç‰ˆç¬”è®°"},{"content":"è¿™ç¯‡æ–‡æ˜¯2021ç§‹çš„ä¸€æ¬¡è”åˆ›webç»„å†…åˆ†äº«\nSourceMapæ˜¯ä»€ä¹ˆ å‘é€åˆ°å‰ç«¯çš„ä»£ç å¾€å¾€ä¸æ˜¯å†™çš„æ—¶å€™çš„æ ·å­ ä¸ºäº†æ–¹ä¾¿è°ƒè¯•ï¼Œåœ¨SourceMapæ–‡ä»¶ä¸­è§„å®šäº†æºæ–‡ä»¶å’Œæ‰“åŒ…åçš„æ–‡ä»¶çš„æ˜ å°„ã€‚ 1 2 3 4 5 6 // index.js function foo() { return getNum(); } // åªéœ€è¦åœ¨æ”¹é€ åçš„ä»£ç æœ€ååŠ ä¸Šè¿™ä¸€è¡Œæ³¨é‡Šå°±ä¼šè¢«è§£æ //# sourceMappingURL=http://example.com/index.map 1 2 3 4 5 // index.ts // ... function foo():number { return getNum(); } 1 2 3 4 5 6 7 8 9 // index.map(å…¶å®æ˜¯ä¸€ä¸ªjsonæ–‡ä»¶ // æ­£å„¿å…«ç»çš„SourceMapå¹¶ä¸è¿™ä¹ˆå†™ { \u0026#34;sources\u0026#34;: [\u0026#34;path/index.ts\u0026#34;], // å¯ä»¥æœ‰å¾ˆå¤šä¸ª \u0026#34;mappings\u0026#34;: \u0026#34;index.jsç¬¬äºŒè¡Œç¬¬ä¸€å¥æ˜ å°„åˆ°index.tsçš„ç¬¬ä¸‰è¡Œç¬¬ä¸€å¥, index.jsç¬¬xè¡Œç¬¬yå¥æ˜ å°„åˆ°index.tsç¬¬iè¡Œç¬¬jå¥, CAAEA\u0026#34; } MDNçš„SourceMapä½¿ç”¨demo https://mdn.github.io/devtools-examples/sourcemaps-in-console/index.html\nSourceMapçš„ä¸€äº›feature åªæœ‰åœ¨DevToolsä¸­æ‰“å¼€enable source mapæ‰æœ‰æ•ˆï¼Œå› æ­¤æ³¨é‡Šé‡Œçš„é“¾æ¥æ˜¯å¯ä»¥åŠ¨æ€æ„é€ çš„ æ‰“å¼€DevToolsæ—¶æ‰ä¼šåŠ è½½Map ç”±äºå¯ä»¥ä½¿ç”¨ç½‘ç»œæ¥è·å–SourceMapï¼Œå› æ­¤ä¸€å®šå¯ä»¥å‘é€ç½‘ç»œè¯·æ±‚(GET) ç½‘ç»œè¯·æ±‚ä¸ä¼šåœ¨DevToolsçš„Networkä¸­å±•ç¤ºï¼ˆå½“ç„¶wiresharkç­‰æ˜¯èƒ½æŠ“åˆ°çš„ï¼‰ ä¼ è¾“æ˜¯å•å‘çš„ï¼ˆå³ä¸ä¼šè§£æresponseï¼‰ SourceMapçš„éæ­£ç»ç”¨æ³• æ‚„æ‚„å‘é€è¯·æ±‚ ä¹‹å‰è¯´å¯ä»¥åŠ¨æ€æ„é€ é“¾æ¥ï¼Œé‚£ä¹ˆåªè¦ç”±è„šæœ¬æ§åˆ¶ï¼Œå¯ä»¥éšæ—¶å‘é€getè¯·æ±‚å‡ºå»ï¼Œè€Œä¸”ä¸ä¼šç•™ä¸‹æ˜æ˜¾çš„ç—•è¿¹ã€‚ï¼ˆå¯ä»¥éšæ—¶remove\n1 2 3 4 5 6 7 const report = (url, data) =\u0026gt; { const script = document.createElement(\u0026#39;script\u0026#39;); script.textContent = `//# sourceMappingURL=${url}?data=${data}`; document.head.appendChild(script); script.remove(); } report(\u0026#39;/report\u0026#39;, \u0026#39;value\u0026#39;); ç›‘å¬DevToolsçš„æ‰“å¼€äº‹ä»¶ ä¹‹å‰è¯´æ²¡æ³•è§£æresponseï¼Ÿå¦‚ä½•åšåˆ°åŒå‘æ²Ÿé€šï¼Ÿ æœ‰æ²¡æœ‰åŠæ³•ä¸ç”¨è§£æresponseä¹Ÿèƒ½å°†çŠ¶æ€ä¿ç•™åˆ°æœ¬åœ°çš„æ–¹å¼ï¼Ÿ Set-Cookie \u0026amp;\u0026amp; document.cookie (æˆ‘ä»¬è®¤ä¸ºç½‘ç«™çš„å‰ç«¯æ˜¯ğŸ˜ˆï¼Œå› æ­¤httpOnlyçš„headerç”±ğŸ˜ˆæŠŠæ§ï¼Œå¯ä»¥è®¾ç½®ä¸ºfalseï¼Œè¿™æ ·jså°±èƒ½å¤Ÿè·å–è¯¥cookieï¼‰ ç›‘å¬è¿™ä¸ªèƒ½å¹²å˜›ï¼Ÿ æ¯”å¦‚ä½ æœ‰æ€ªæµªæ€ªæµªçš„ğŸ˜ˆä»£ç ï¼Œåœ¨è°ƒè¯•äººå‘˜æ‰“å¼€devtoolsçš„æ—¶å€™å°±å¯ä»¥åˆ é™¤è¯¥éƒ¨åˆ†ä»£ç æˆ–è€…ä¿®æ”¹æˆäººç•œæ— å®³çš„ğŸ‘¼ä»£ç ï¼Œè¿™æ ·å°±è¾¾åˆ°äº†Anti-debuggingçš„ç›®çš„ã€‚ æ¯”å¦‚æœ€æç«¯çš„ä½ å¯ä»¥ document.body.innerHTML = \u0026quot;\u0026quot;;\né‰´äºå…¶æ“ä½œçš„é«˜çµæ´»æ€§ï¼Œå³ä½¿ä¸æ˜¯åšåäº‹ä¹Ÿå¯ä»¥ç©å‡ºä¸€äº›èŠ±æ¥ï¼Œå¯ä»¥ç”¨äºè·Ÿç”¨æˆ·å¼€ç©ç¬‘ã€‚\nç»•è¿‡å†…å®¹å®‰å…¨ç­–ç•¥(Content Security Policy) å†…å®¹å®‰å…¨ç­–ç•¥æ˜¯æµè§ˆå™¨ç”¨äºä¿æŠ¤æœåŠ¡å™¨çš„ä¸€ç§å®‰å…¨é™åˆ¶ï¼Œå¯ä»¥ç”±æœåŠ¡ç«¯è®¾ç½®å®‰å…¨ç­–ç•¥ï¼Œå¯ä»¥é˜²æ­¢è®¸å¤šXSSçš„æ³¨å…¥ã€‚\nEg: æœåŠ¡ç«¯è¿”å›æ—¶å¸¦ä¸Šäº†ä»¥ä¸‹headerï¼Œåªå…è®¸æ¥è‡ªå‘åŒæºåŸŸåå‘é€è¯·æ±‚ï¼ˆæˆ–è€…è¯´è¿™ä¸ªé¡µé¢ä¸‹çš„æ‰€æœ‰èµ„æºéƒ½åº”å½“æ¥è‡ªåŒæºåŸŸåï¼‰ï¼Œä¸ç¬¦åˆè¦æ±‚çš„è¯·æ±‚å°†ä¼šè¢«æµè§ˆå™¨æ‹¦æˆª Content-Security-Policy: default-src \u0026lsquo;self\u0026rsquo;\nä½†æ˜¯ç”¨sourceMappingUrlå¯ä»¥ç»•è¿‡è¿™ä¸ªé™åˆ¶ï¼Œå°±æ˜¯è¯´æˆ‘ä»¬å¯ä»¥ sourceMappingUrl = http://others.com è€Œä¸å—å½±å“\nSum up ä¸€ä¸ªæœ‰æ„æ€çš„trickï¼Œæä¾›äº†ä¸€ç§åœ¨å‰ç«¯åšå°åŠ¨ä½œè€Œä¸ä¼šåœ¨DevToolsé‡Œæš´éœ²çš„æ–¹æ³•ï¼Œæ¯”å¦‚ï¼š\næ‚„æ‚„åœ°å‘é€ä¸€äº›è¯·æ±‚ åœ¨æœ‰å¼€å‘äººå‘˜æ‰“å¼€è°ƒè¯•ç•Œé¢çš„æ—¶å€™å¯ä»¥å°†ä»¥å‰çš„æ‰‹è„šåˆ é™¤ä»¥è¾¾åˆ°Anti-Debuggingçš„æ•ˆæœï¼Œåœ¨è°ƒè¯•è¿‡ç¨‹ä¸­ä¼šå‘ç°æ•´ä¸ªä»£ç äººç•œæ— å®³ã€‚ ç”¨æ¥å®ç°ã€ç›‘å¬DevToolså¯åŠ¨ã€‘è¿™æ ·ä¸€ä¸ªæµè§ˆå™¨ä¸­æ²¡æœ‰æä¾›çš„äº‹ä»¶ã€‚ ä¸è¿‡ç¼ºç‚¹ä¹Ÿå¾ˆæ˜æ˜¾ï¼š\næ¯•ç«ŸæŠ¥æ–‡å‘é€å‡ºå»äº†ï¼Œwireshark/snifferséƒ½æ˜¯èƒ½æŠ“åˆ°åŒ…çš„ï¼ŒåŒæ—¶sourcemapç›¸å…³ä»£ç ä¹Ÿæ— æ³•å®Œå…¨éšè—èµ·æ¥ï¼Œæ— æ³•å®Œå…¨åšåˆ°éšèº« éœ€è¦æµè§ˆå™¨æ‰“å¼€SourceMapåŠŸèƒ½æ‰èƒ½æ­£å¸¸å·¥ä½œï¼ˆä¸è¿‡ä¼¼ä¹ç°åœ¨æµè§ˆå™¨éƒ½é»˜è®¤æ‰“å¼€çš„ï¼Ÿæœªè¯å® DevToolsæ‰“å¼€æ—¶æ‰èƒ½å¤ŸåŠ è½½SourceMapï¼Œå¦‚æœæ˜¯æƒ³åšç›‘æ§æ˜¾ç„¶ä¸å¤Ÿå…¨é¢ï¼Œå› ä¸ºç»å¤§å¤šæ•°äººæ‰“å¼€ç½‘é¡µåä¸ä¼šå»æŒ‰F12 å› æ­¤è¿˜æ˜¯ä½œä¸ºä¸€ä¸ªJavaScript Anti-Debuggingçš„ä¸€ä¸ªtrickï¼Œè€Œä¸æ˜¯æ— æ•Œçš„å­˜åœ¨ã€‚ å‚è€ƒèµ„æ–™ ä¸»è¦çš„å†…å®¹æ¥æºäºè¿™ä¸€ç¯‡blogï¼š https://weizman.github.io/?javascript-anti-debugging-some-next-level-shit-part-1 JavaScript Source Map è¯¦è§£ - é˜®ä¸€å³°çš„ç½‘ç»œæ—¥å¿— ä½¿ç”¨ source map - Firefox å¼€å‘è€…å·¥å…· | MDN å†…å®¹å®‰å…¨ç­–ç•¥( CSP ) - HTTP | MDN å¾®å‹demo ","date":"2021-10-28T18:40:44+08:00","permalink":"/p/sourcemap%E4%B8%8Ejs%E5%8F%8D%E8%B0%83%E8%AF%95/","title":"SourceMapä¸JSåè°ƒè¯•"}]