[{"content":"背景 我正在编写 complish：希望能通过 chatGPT 来解析任意 CLI 的 help page（即 cmd --help 后打印的内容），之后生成各个 shell 的补全文件，从而能够通过 \u0026lt;TAB\u0026gt; 键来获得该 CLI 参数的候选提示。\n1 2 3 4 5 6 7 ✗ mycmd \u0026lt;TAB\u0026gt; -g -- great! -h -- Print help help -- Print help page(cmd) sub1 -- sub command 1 sub2 -- sub command 2 sub3 -- sub command 3 zsh-completion 的机制相当复杂，比 fish 写起来困难特别多，因此在做自动生成前，最难的是手动写一份模板 zsh-completion 文件。\nzsh 的官方文档也是难得离谱，根本不说人话，社区的问题也没有什么热度而且回答并不实用，因此只能自己结合其他教程捣鼓了。（以及顾问 chatGPT）\n这篇文章只涉及该涉及的内容，无法完全覆盖 zsh-completion 的功能。\n完成目标 这篇文章的目标是给一个 zsh 下的 CLI mycmd 写一份 zsh-completion，支持多层的 options 和 subcommands，下面是各层的 help page。 （代码完全由 chatGPT 生成，让它帮我用 clap(Rust) 写个 CLI）\nmycmd 1 2 3 4 5 6 7 8 9 10 11 ✗ mycmd --help Usage: mycmd \u0026lt;COMMAND\u0026gt; Commands: sub1 sub command 1 sub2 sub command 2 help Print this message or the help of the given subcommand(s) Options: -h, --help Print help -V, --version Print version mycmd sub1 1 2 3 4 5 6 7 8 9 10 11 12 ✗ mycmd sub1 -h sub command 1 Usage: mycmd sub1 [COMMAND] Commands: subsub1 this is subsub 1 subsub2 this is subsub 2 help Print this message or the help of the given subcommand(s) Options: -h, --help Print help mycmd sub2 1 2 3 4 5 6 7 8 ✗ mycmd sub2 -h sub command 2 Usage: mycmd sub2 [OPTIONS] Options: --log-level \u0026lt;LOG_LEVEL\u0026gt; log level, debug/info/error -h, --help Print help mycmd sub1 subsub1 1 2 3 4 5 6 7 8 ✗ mycmd sub1 subsub1 -h this is subsub 1 Usage: mycmd sub1 subsub1 --num \u0026lt;NUM\u0026gt; Options: -n, --num \u0026lt;NUM\u0026gt; a number -h, --help Print help mycmd sub1 subsub2 1 2 3 4 5 6 7 8 ✗ mycmd sub1 subsub2 -h this is subsub 2 Usage: mycmd sub1 subsub2 --file \u0026lt;FILE\u0026gt; Options: -f, --file \u0026lt;FILE\u0026gt; path of a file -h, --help Print help 从别人的工作开始 按别人的写法，对一个 mycmd 的 CLI 补全应该这么写：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 #compdef _mycmd mycmd function _mycmd { local line _arguments -C \\ \u0026#34;-h[Show help information]\u0026#34; \\ \u0026#34;--h[Show help information]\u0026#34; \\ \u0026#34;1: :(sub1 sub2)\u0026#34; \\ \u0026#34;*::arg:-\u0026gt;args\u0026#34; case $line[1] in sub1) _mycmd_sub1 ;; sub2) _mycmd_sub2 ;; esac } function _mycmd_sub1 { _arguments \\ \u0026#34;--silent[Dont output anything]\u0026#34; } function _mycmd_sub2 { _arguments \\ \u0026#34;--repeat=[Repat the \u0026lt;message\u0026gt; any number of times]\u0026#34; } 保证在 zsh 的 $fpath 路径里有一个 _mycmd 的文件，以 #compdef _mycmd mycmd 特殊注释开头，zsh completion 语法（注意不是普通的 .zsh 的语法，在普通的 zsh 脚本里无法调用 _arguments 和 _values 这样的函数）\n这样在执行 mycmd 并按下 \u0026lt;TAB\u0026gt; 时就会执行到 _mycmd 函数，之后控制权完全交给你写的函数，就可以开发了。\n在上面的例子中，$line 是你在 terminal 的 buffer 输入的各个参数，case $line[1] 判断第一个参数是什么字符串，在上面可以是 sub1 或者 sub2，之后通过执行各自的函数来提供服务，里面调用的 _arguments 即是提供 options 补全支持的函数。\n在 _mycmd 里调用的 _arguments 相当于为当前输入的 mycmd 提供参数补全，如果 -h 和 \u0026ndash;help 都提供了相同的描述，在 zsh-completion 里就会被处理成同一个参数。\n至于之后两个复杂的项：\n1 2 3 _arguments \\ \u0026#34;1: :(sub1 sub2)\u0026#34; \\ \u0026#34;*::arg:-\u0026gt;args\u0026#34; 表示第一个参数会有 sub1, sub2 两个候选，而 * 表示在之后的参数将存入一个上下文变量 $arg，之后的 -\u0026gt;args 表示当前 buffer 的状态触及到了第一个参数后的参数，将一个内置的表示状态变量 $state 赋值为 args 字符串。\n看来自另一篇文章的写法：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 _dolt() { local line state _arguments -C \\ \u0026#34;1: :-\u0026gt;cmds\u0026#34; \\ \u0026#34;*::arg:-\u0026gt;args\u0026#34; case \u0026#34;$state\u0026#34; in cmds) _values \u0026#34;dolt command\u0026#34; \\ \u0026#34;init[Create an empty Dolt data repository.]\u0026#34; \\ \u0026#34;table[Commands for copying, renaming, deleting, and exporting tables.]\u0026#34; ;; args) case $line[1] in init) _dolt_init ;; table) _dolt_table ;; esac ;; esac } 里面判断逻辑就是：如果$state == \u0026quot;args\u0026quot;，那么已经认为 terminal 里输入的是 mycmd 以及其他一些什么参数或者子命令，而不是单纯的 mycmd，那么 _arguments 在这里的作用就是将当前 buffer 里输入的文本已经到了哪个阶段确定下来（是否除了 mycmd 还有其他参数），如果只输入了 mycmd ，那么 $state == \u0026quot;cmd\u0026quot;。\n之后调用的 _dolt_init 和 _dolt_table 其实都是这个 _dolt 的如法炮制，该作者成功解决了子命令的补全的问题。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 _dolt_table() { local line state _arguments -C \\ \u0026#34;1: :-\u0026gt;cmds\u0026#34; \\ \u0026#34;*::arg:-\u0026gt;args\u0026#34; case \u0026#34;$state\u0026#34; in cmds) _values \u0026#34;dolt_table command\u0026#34; \\ \u0026#34;import[Creates, overwrites, replaces, or updates a table from the data in a file.]\u0026#34; ;; args) case $line[1] in import) _dolt_table_import ;; esac ;; esac } 但是我觉得这样的脚本并不好看。在我在写 fish 支持的时候，我用了比较线性的方式，匹配当前输入的 buffer 是否满足某个”命令链“(command chain)，来对该链条做特定的补全支持，在生成阶段会更加容易。那我希望 zsh 也能用这种 cmd_chain 的方式来完成一个补全文件。\ncommand chain in zsh 因为 zsh 没法像 fish 一样，在 complete 里加条件去顶级地判断 cmd chain 来决定是否为后续项，因此思路还是只能类似 switch 语句去判断：\n1 2 3 4 5 6 7 8 9 10 11 case (get_cmd_chain $MY_INPUT) in \u0026#34;cmd\u0026#34;) # do ;; \u0026#34;cmd sub1\u0026#34;) # do ;; \u0026#34;cmd sub1 subsub1\u0026#34;) # do ;; esac get_cmd_chain 其实就是把当前输入的字符串，转成当前已经确定的命令调用链，不再需要提供其之前的候选提示，实现：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 function __get_cmd_chain() { local cmd_chain=() local chain_str=${1} local args=(${(s: :)chain_str}) for arg in $args; do if [[ $arg[1] == \u0026#34;-\u0026#34; ]]; then echo $cmd_chain return fi cmd_chain+=($arg) done # \u0026#34;cmd sub1\u0026#34; should be parsed \u0026#34;cmd\u0026#34; because the command chain may not finish # eg. \u0026#34;cmd su\u0026#34; would not work if it\u0026#39;s parsed to (\u0026#34;cmd\u0026#34; \u0026#34;su\u0026#34;) if [[ $chain_str[-1] == \u0026#34; \u0026#34; ]]; then echo $cmd_chain else echo $cmd_chain[1,-2] fi } 主旨是只保留 -o \u0026ndash;options 前的所有命令，如 cmd sub1 --option =\u0026gt; cmd sub。\nlocal args=(${(s: :)chain_str}) 表示把参数字符串分割，即 JS 里的 chain_str.split(' ')。 最后几行的判断，如果以空格结尾，说明当前已经结束了前面这个命令的输入，则将其视为 cmd chain 的一环，因为有可能这个命令输一半，比如 cmd su 如果被解析成 cmd su 的 cmd chain，那么此时按 \u0026lt;TAB\u0026gt; 无法提供正常的候选。 $cmd_chain[1, -2] 表示去掉最后一个元素 为了保证有效，这里很适合写单元测试：\n1 2 3 4 5 6 7 8 9 10 11 12 13 function should_succ() { local parsed=$(__get_cmd_chain ${1}) if [[ ! $parsed = ${2} ]]; then print -P \u0026#34;%F{red}Fail(should equal):\\n ${1} =\u0026gt; $parsed\\n ${2} %F{reset}\u0026#34; return 1 fi return 0 } should_succ \u0026#34;cmd sub1 subsub1 -f file\u0026#34; \u0026#34;cmd sub1 subsub1\u0026#34; should_succ \u0026#34;cmd sub1 subsub1 -f file\u0026#34; \u0026#34;cmd sub1 subsub1\u0026#34; should_succ \u0026#34;cmd -log \u0026#34; \u0026#34;cmd\u0026#34; should_succ \u0026#34;cmd sub1 sub2 -f\u0026#34; \u0026#34;cmd sub1 sub2\u0026#34; 解析完之后其实就可以 switch 了，直接写 _mycmd 函数本体\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 function _mycmd() { local parsed=$(__get_cmd_chain $BUFFER) case $parsed in \u0026#34;mycmd\u0026#34;) complete_mycmd ;; \u0026#34;mycmd sub1\u0026#34;) complete_mycmd_sub1 ;; \u0026#34;mycmd sub1 subsub1\u0026#34;) complete_mycmd_sub1_subsub1 ;; \u0026#34;mycmd sub1 subsub2\u0026#34;) complete_mycmd_sub1_subsub2 ;; \u0026#34;mycmd sub2\u0026#34;) complete_mycmd_sub2 ;; *) ;; esac } 其中各个函数都很简明，每个的内容无非 _arguments 或者 _values，来表达对当前 cmd chain 的补全支持。（_arguments -s）表示可以连着补全，比如 -h 再按 \u0026lt;TAB\u0026gt; 会变成 -hg\n1 2 3 4 5 6 7 8 9 10 11 function complete_mycmd() { _values \\ \u0026#34;cmd command\u0026#34; \\ \u0026#34;sub2[sub command 2]\u0026#34; \\ \u0026#34;sub3[sub command 3]\u0026#34; \\ \u0026#34;sub1[sub command 1]\u0026#34; \\ \u0026#34;help[Print help page(cmd)]\u0026#34; _arguments -s \\ \u0026#34;-h[Print help]\u0026#34; \\ \u0026#34;-g[great!]\u0026#34; \\ } 然后就开始跑，结果就出锅了：在 cmd 后按下 \u0026lt;TAB\u0026gt; 能正常提供提示，但是 cmd sub1 后却不能提供 options 的候选，而只有 values 。stackoverflow上也有这个问题的描述，然而并不太实用。\n控制变量发现其实是 _arguments 的问题，_arguments 的支持其实只能在出现 non-option 参数（比如子命令、其他参数）之前提供，就是说无法为子命令提供参数，上面 bolt 的作者解决这个问题其实靠的就是\n1 2 3 _arguments -C \\ \u0026#34;1: :-\u0026gt;cmds\u0026#34; \\ \u0026#34;*::arg:-\u0026gt;args\u0026#34; 在这串调用里，输入的上下文其实会被”吃掉“，调用之后，第一个非 non-option 参数会消失，后面的会往前补，因此又成了第一个参数，能够提供 options 的补全支持。这个具体原理确实没搞明白，但是知道怎么解决问题了……他的解决也是因为每层函数里都会调用一遍这串代码。\n然而 cmd chain 是单层的结构，因此需要手动去一次性执行 x 次调用。（我尝试过使用 \u0026ldquo;2: :-\u0026gt;cmds2\u0026rdquo; 之类的，但是并没有效果，不太能理解，所以还是选择多次调用相同的参数）。在 _mycmd() 中，解析完 $BUFFER 后加入执行 count - 1 次 _arguments 的代码，来将 cmd chain 最后一个子命令推到最前面，从而能支持 options 的补全。\n1 2 3 4 5 6 7 8 9 10 local parsed=$(__get_cmd_chain $BUFFER) # \u0026#34;eat\u0026#34; the previous arguments and options so that _arguments can work normally # while there is non-option args before the cursor local count=${#${(z)parsed}} # $count - 1 times for ((i=1; i\u0026lt;$count; i++)); do _arguments -C \\ \u0026#34;1: :-\u0026gt;cmds\u0026#34; \\ \u0026#34;*::arg:-\u0026gt;args\u0026#34; done 这样就能正常工作了！\n只要知道了整个 help page 的 tree，那么生成这样的文件就是一个线性的工作，生成出来可读性也高。\n结论 zsh completion 通过 _arguments 和 _values 函数提供候选支持 _arguments 只能在没有 non-option 参数的环境下工作，需要通过特殊处理来”吃掉“之前的参数使得支持子命令 zsh 的文档不是人读的，希望能被 fish 取代 XD，没有用过的建议试试 fish shell complish 的本意只是支持 fish，但后来觉得我确实挺喜欢这个工具，希望能推广到 bash 和 zsh，bash 的 completion 还需要再研究，不过和 zsh 是同一套语法我猜应该不会更难了。 最后的 _mycmd 文件 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 #compdef _mycmd mycmd function __get_cmd_chain() { local cmd_chain=() local chain_str=${1} local args=(${(s: :)chain_str}) for arg in $args; do if [[ $arg[1] == \u0026#34;-\u0026#34; ]]; then echo $cmd_chain return fi cmd_chain+=($arg) done # \u0026#34;cmd sub1\u0026#34; should be parsed \u0026#34;cmd\u0026#34; because the command chain may not finish # eg. \u0026#34;cmd su\u0026#34; would not work if it\u0026#39;s parsed to (\u0026#34;cmd\u0026#34; \u0026#34;su\u0026#34;) if [[ $chain_str[-1] == \u0026#34; \u0026#34; ]]; then echo $cmd_chain else echo $cmd_chain[1,-2] fi } function _mycmd() { local parsed=$(__get_cmd_chain $BUFFER) # print -P \u0026#34;%F{red} \\n $parsed \\n%F{reset}\u0026#34; # \u0026#34;eat\u0026#34; the previous arguments and options so that _arguments can work normally # while there is non-option args before the cursor local count=${#${(z)parsed}} # $count - 1 times for ((i=1; i\u0026lt;$count; i++)); do _arguments -C \\ \u0026#34;1: :-\u0026gt;cmds\u0026#34; \\ \u0026#34;*::arg:-\u0026gt;args\u0026#34; done case $parsed in \u0026#34;mycmd\u0026#34;) complete_mycmd ;; \u0026#34;mycmd sub1\u0026#34;) complete_mycmd_sub1 ;; \u0026#34;mycmd sub1 subsub1\u0026#34;) complete_mycmd_sub1_subsub1 ;; \u0026#34;mycmd sub1 subsub2\u0026#34;) complete_mycmd_sub1_subsub2 ;; \u0026#34;mycmd sub2\u0026#34;) complete_mycmd_sub2 ;; *) ;; esac } function complete_mycmd() { _values \\ \u0026#34;cmd command\u0026#34; \\ \u0026#34;sub2[sub command 2]\u0026#34; \\ \u0026#34;sub3[sub command 3]\u0026#34; \\ \u0026#34;sub1[sub command 1]\u0026#34; \\ \u0026#34;help[Print help page(cmd)]\u0026#34; _arguments -s \\ \u0026#34;-h[Print help]\u0026#34; \\ \u0026#34;-g[great!]\u0026#34; \\ } function complete_mycmd_sub1() { _values \\ \u0026#34;sub1 subcommand\u0026#34; \\ \u0026#34;subsub1[subsub command 1]\u0026#34; \\ \u0026#34;subsub2[subsub command 2]\u0026#34; \\ \u0026#34;help[Print help page(cmd)]\u0026#34; _arguments -s \\ \u0026#34;-h[Print help]\u0026#34; \\ \u0026#34;-g[great!!!]\u0026#34; \\ } function complete_mycmd_sub2() { _arguments -s \\ \u0026#34;--log-level[log level, debug/info/error]\u0026#34; \\ \u0026#34;-h[Print help for sub2]\u0026#34; \\ \u0026#34;--help[Print help for sub2]\u0026#34; } function complete_mycmd_sub1_subsub1() { _arguments -s \\ \u0026#34;-n[a number]\u0026#34; \\ \u0026#34;--num[a number]\u0026#34; \\ \u0026#34;-h[Print help]\u0026#34; } function complete_mycmd_sub1_subsub2() { _arguments -s \\ \u0026#34;-f[path of a file]\u0026#34; \\ \u0026#34;--file[path of a file]\u0026#34; \\ \u0026#34;-h[Print help]\u0026#34; } 参考 https://www.dolthub.com/blog/2021-11-15-zsh-completions-with-subcommands/ 给我帮助最多的教程，树状地解决了这个问题，但是我觉得不好生成，因此做了改进 https://blog.mads-hartmann.com/2017/08/06/writing-zsh-completion-scripts.html https://tylerthrailkill.com/2019-01-13/writing-zsh-completion-scripts/ https://github.com/zsh-users/zsh-completions/blob/master/zsh-completions-howto.org#intro ","date":"2023-03-21T14:21:18+08:00","image":"/p/write-zsh-completions-for-cli/cover_hu910981dd125385da1f7c837c3da6b847_228397_120x120_fill_box_smart1_3.png","permalink":"/p/write-zsh-completions-for-cli/","title":"Write zsh completions for CLI"},{"content":"应该是我至今亲眼所见的宏观环境最糟糕的一年，互联网的终点、层出不穷的倒车、无敌的 COVID-19。\n关于内卷焦虑 虽然去年年底就已经自称认清自己非常平庸的现实，但今年依然陷入了持续的内卷焦虑当中，曾经用“只是没找到喜欢的方向而不是自己菜”来忽悠自己，减少大学过得碌碌无为、没有建树的负罪感，但愈发察觉其实就是因为自己水平差，有一种创造力和注意力都在逐渐消散的无力感。\n应该说大三是很多朋友从输入转变为输出的阶段，我看到很多优秀的人即使不打算从事自己大学专业的工作，在自己专业上依然能表现得非常优秀，对我来说这就像是一种学习力的碾压，要说不羡慕那1000%是骗人的，我祝福他们前途顺利，却无论如何都难以祝福自己，因为发现自己就是没有那么厉害，而且活在“我很厉害”的预想中。\n我知道活在这个世界上不需要那么优秀也可以活得很快乐，不用当各种比赛、奖牌收割机也能找到体面的工作，然而难以说服我去放弃比别人厉害的幻想。\n明年的我能不能真正地放下身段，走跟自己比较的道路呢？\n关于润 我大概就是刚好一年前开始准备雅思，当初的设想就是去 HK 读个水硕，速通一个 master 学位，最后也几乎不会失败地拿到了 offer，可是无论如何却高兴不起来，可能因为得到没有难度的东西并不会带来快感吧。\n申请季花了几周时间认真思考了润这一件事，对申请欧陆学校也做了一些调研，在疯狂摇摆之间选择了不申，觉得自己终究不是当欧洲人的料，对欧洲的印象纯粹只有云观光客水平，没有爱好交集我想应该不可能融入他们的社会（人话：当现充），或许去日本还能活得更自在，然而自己又嫌弃日本的老化。其次就是他们 IT 发展水平属实一般，赚不了钱。\n我觉得一个群友说得很有道理，你还在摇摆润不润是因为你就是当前体制的受益者。\n没有足够大的压迫力确实难以让我有逃出国门的想法，根深蒂固的东亚文化圈已经刻入 DNA 了。在一亩三分地看世界公民的时候，注意到了其实大家并不怎么关心政治，不管是移民还是回国，考虑的大多是自己的发展，几乎就没有见到因为讨厌阿熊/向往自由而决定跑路的（见到的都是还没跑的（笑）），感觉这是个需要毕业后当了社畜才能理解的主题，皇帝是谁不重要。\n不知道愈演愈烈的倒车什么时候会有足够大的压力让人真的不跑不行呢\n关于工作 今年花了半年多的时间在实习上，我在正月初七就去了深圳，但是因为流程卡住了的原因直到待了一个月才成功入职，不到两个月内又接到了 HR 说微信冻结校招的电话，成了组里第一个毕业的人。在深圳单程通勤 1h 的日子是不好受的，感觉每天的生活很单调，好处是房子确实不贵，2k4 以内包水电解决，可惜是公寓单间，和同学没有找到理想的短租房。\n之后七月去了上海实习，我原本期待的二次元盛典（CP、方舟音乐会）一个都没有，挺令人失落的，但是居住体验却是相当不错，有生活爱好交集很大的室友，还有楼下繁华的生活供应，让我觉得“社会性的人类就应该这样生活”的感觉。这种公寓式建筑对年轻人来说，真的比安全系数高的小区生活质量高不少，主要是有够多够密集的居民来撑起商业，如果毕业后有机会，还是希望能有熟人朋友合租+住商业繁华的居民楼。\n今年也在不断地双开中进行，在深圳实习的同时应付学校，在上海实习的同时参加 rCore 夏令营，我好像很热衷于让自己变得很忙，代价是我失去了很多自由时间。\n说点好的 今年由一次很难忘的旅行开篇，第一次在冬天前往北方，而且还是西北大荒漠。\n跟远征的朋友横穿了腾格里沙漠，第一次见到那么漂亮的自然景观，给这个广东人大开眼界了。\n可惜这个冬天因为放开了而提前回家没有办法再参加一次活动。\n说点未来 我在大学很少提笔画画，但脑子里却从来没有放下过这个技能，幻想着哪天能重拾，每天疲于双开的我自然很少有这种精力了，希望休闲的大四能给我这个机会，目标是 23 年底能发 #2022年自分が選ぶ今年の4枚 的 tag。\n希望 23 年能过 N1，从大一开始报 N2，直到大四都没能够进入考场，令人感慨。\n希望 23 年能做出好玩又有实际用处的产品。\n希望 23 年不会那么焦虑了，多跟自己比较。\n","date":"2022-12-31T20:29:34+08:00","image":"/p/%E5%86%99%E5%9C%A82022%E5%B9%B4%E6%9C%AB/20221231225829_hu42dac3001980353f2005382bccb3c8c2_1201779_120x120_fill_box_smart1_3.png","permalink":"/p/%E5%86%99%E5%9C%A82022%E5%B9%B4%E6%9C%AB/","title":"写在2022年末"},{"content":"Iterative Algorithm 从更抽象的角度来审视我们的迭代算法，每个块（CFG 里的节点）都会有状态，那么整个程序里所有块能组成一个 k 维向量。\n迭代每个节点的时候其实就是对 Block 作函数转换。\n我们迭代的停止条件是【一次迭代后 tuple 没变】，其实就到达了不动点\n不动点：\n数学上不动点的定义： $$ X = F(X) $$\n为什么标题叫 foundation：domain 并不止之前学的三种，我们可以分析更多的代码性质\n三个问题，后面会得到解决：\niter algo 一定能找到不动点吗？（算法一定会停下吗？）\n我们针对前面三种 domain 分析过，会停 但是这是一个普遍的结论吗？对其他的 domain 呢 如果一定能停，一定有唯一的不动点吗？\n什么时候能到达不动点？\nPartial Order (偏序) poset 偏序集\n满足下面三个要求的就是合法的偏序关系\n自反 reflexivity\n反对称 antisymmetry\n传递 transitivity\n例子1：\n( integer, \u0026lt;= ) 是不是偏序集？\n性质都满足，是 例子2：\n( integer, \u0026lt; ) 是不是偏序集？\n不满足自反，不是 为什么叫偏序？不是全部元素都能比较\n（需要记住这个图，\u0026lt;abc, 包含关系\u0026gt; 组成的全格）\nUpper \u0026amp; Lower Bounds （上下界） x 不一定在 S 里 最小上界 lub =\u0026gt; join 最大下界 glb =\u0026gt; meet 不是所有偏序集都有 lub 或者 glb 如果 poset 有 lub 或者 glb，那么 lub 和 glb 一定是唯一的（用反对称性很容易证明：互相对同一个关系成立就一定是同一个） Lattice（格） poset 中每一对元素都存在最大下界和最小上界（大白话：两个元素都会 meet (∩) 和 join (∪) ）\n(integer, \u0026lt;=) 是不是 lattice？ 是，任意两个数可以 meet 和 join Semilattice（半格） P 里任意两个元素都有 lub 和 glb，就是半格 Complete Lattice（全格） 任意 P 的子集都会有 lub 和 glb 就是全格 (integer, \u0026lt;=) 是不是 compete lattice？ 否，整数集不符合（找不到最小的上界/最大的下界） 每个有穷的格一定是完全格 反命题为伪：{ [0,1]小数集, \u0026lt; } 完全且无穷：任意子集都能找到一个上下限 Product Lattice 每个 L 都是 complete，那么组成的 product lattice $L^n$ 也是 complete 的 Data Flow Analysis Framework via Lattice 其实是 semi，但是用 lattice 来表示更加方便\n定义一个 Data flow analysis 的框架：由 \u0026lt;方向、格、转换函数\u0026gt; 组成\n例子：\n顺序是反过来的（ Block 的执行流跟格的方向） {a, b, c} 用 bit vector 表示就是 111, {} 就是 000 Data flow analysis 的本质：在一个格上迭代一个 transfer、并不断 meet 和 join\n回答前面的问题：\n迭代算法一定能达到不动点吗 OUT never shrinks (monotonicity) 如果能，可能有多个不动点吗 可以 如果有多个不动点，能不能找到最好的（迭代次数最少） 可以 Monotonicity 不动点定理\n全格、单调、有限 =\u0026gt; 就能迭代出最优的不动点 complete 不一定 finite 求证:\n存在不动点 迭代得到的不动点最小 证明：\nfixed point exists least fixed point 数学归纳法: 假设 k 成立 + 证明初始成立 =\u0026gt; 证明 k + 1 成立 =\u0026gt; 定理成立\n证出来是 unique fixed point\nRelative between Iter Algo \u0026amp; Fixed Point Theorem 迭代算法能不能关联上不动点定理？能关联上才能说这个迭代算法能找到最优的不动点。\n直觉上的证明：\n单调：OUT 不会 shrink (gen - kill 单调) 有限：很显然，集合是有限的，集合的有限次幂也是 多少次迭代能到达不动点？\n最坏情况 k 个块 (nodes in CFG，在 example 的视角就是一个比特)、高度 h，最坏情况是 i = h * k 次迭代 May and Must Analysis, a Lattice View May 在 Reaching Definition Analysis 里，1 是能 reach，0 是不能 reach，即在程序终点这个地方，有哪些定义是可能被用到的。\n我们从空集去找，就是我们从敢说程序里所有的定义都不会被消费到，显然是不对的，我们从不安全的一个状态去找到安全的一个点。\n注意 bottom 是 Basic Blocks 的顶点，也就是程序的开始\n一定会找到最小不动点，前面证明过了\ntop 是最没用的（相当于整个程序里的定义全部都可能到达末尾，能到结束的定义都在里面，但是有部分并不会到，所以是安全的，做了一些多余的防范）\nMust May Analysis 是从错里面去改正，Must 是从对的里去找错，前者是 sound 的，后者是 complete 的。\nHow Precise is Our Solution 有些分支永远不会执行如 if (false) ，我们依然认为这条分支里的数据是有用的，这样就造成了失真\nMeet-Over-All-Paths Solution (MOP) 假设有个程序 P = Entry -\u0026gt; S1 -\u0026gt; S2 -\u0026gt; \u0026hellip; -\u0026gt; Si\n$$ MOP[S_i] = ∪/∩ F_p(OUT[Entry]) $$\nMOP 会计算 data-flow 的值，然后把他们 meet / join\n之前的迭代算法是 bfs，一边 meet/join 一边走，MOP 是 dfs，把 path 走完再 meet/join Iter Algo VS MOP 谁更准：MOP 什么时候等于？\nF 有可分配性 之前的三个分析都是可分配的 Constant Propagation 作业：\nV 集合有三种类型的值：\n未定义（Undefined） 某个具体值 非常量（Not A Constant） 在上面的例子里，显然 MOP 更准。肉眼可见 c 是个常量，只看结果\nWorklist Algorithm 是对 Iterative Algorithm 的优化\nIter Algo 的缺点：只要有一个 Block 发生变化，就要把全部都重新算一遍\n把发生变化的丢队列里，然后只计算需要更新的 ","date":"2022-11-08T22:26:17+08:00","permalink":"/p/note-data-flow-analysis-foundations/","title":"Note: Data Flow Analysis - Foundations"},{"content":"Preliminary 什么是 Input 和 Output States 程序是个状态机，在一个语句执行前后都应当有一个状态，保存着比如变量信息、上下文等等的内容，然后语句的执行其实就是状态机的一条边，改变了程序的状态\n对于一个 Basic Block 而言，执行流不过以下三种：1 to 1, 1 to n, n to 1\nReaching Definition Analysis rda 能确定一个在 program point p 时的定义 D 在 program point q 是否有效的，即这个 D 里定义的变量 v 能不能在 q 时被安全地使用。如果有一条 path 能让 D 能够 reach 到 q，那么在 q 点使用 v 是安全的（即能够用到在 p 点定义的 v）\n上图里，v 在 p -\u0026gt; q 的路径上被重新定义了，说明我们无法在 q 点之后消费到 p 点定义的 v，我们说 definition d 在 q 点是无效的\n应用：可以判断用于变量是否被初始化 Algorithm 使用 forward analysis，从头开始分析\n公式：\n$$ OUT[B] = gen[B] ∪ (IN[B] - kill[B])$$ $$ IN[B] = ∪ OUT[P] $$\n其中 P 是 B 的所有前驱块\ngen[B] 是在 B 中的定义，比如:\nB: D1: m = a; D2: n = b; 则 gen[B] == {D1, D2} kill[B] 是在其他块中会被 B 里定义所覆盖的定义，比如：\nB1: D1: m = a B2: D2: m = b 那么 kill[B1] == {D2} 算法伪代码如下：\n算法脑跑，要点：\n结束条件是所有 OUT 在上次迭代里不变 May Analysis，即 sound 的，可能误报但不会漏报，有可能被覆盖，但可能在某些 path 里并不会被覆盖 算法一定会停下：因为 OUT 的大小非减，而有明确的上界（即定义的全集，在 bit vector 里就是全 1），因此一定会收敛，停下的点叫不动点 (fixed point) Live Variables Analysis LVA 能判断 变量 v 能不能从程序点 p 开始沿着 CFG 路径被使用，如果能，说明 v 在 p 点是活着的，否则是死的。\n对于一个死变量，说明以后不会被 use 到，用于资源分配的优化：寄存器分配策略 =\u0026gt; 优先干死 dead value\n分析的是变量 要求 v 在被使用前不能被再次定义 Algorithm 使用 backward analysis 更方便，我们从程序结束的地方开始往前分析，得到变量在各个 program point 时的存活状态（即是否在 p 点后面会被使用）\n如上图，S 是 B 的后继块，即有 B -\u0026gt; S1, B -\u0026gt; S2 等等\nIN[B], OUT[B] 表示存活变量的集合，则有以下公式\n$$ OUT[B] = ∪ IN[S] $$ $$ IN[B] = use[B] ∪ (OUT[B] - def[B]) $$\n其中 use[B] 的元素是在 B 中（在定义前）被使用的变量，比如:\nB: m = k; n = j ，use[B] == {k, j} B: m = k; n = m - 1 ，use[B] == {k}，m 不算在里面，因为其是在 B 里定义后被使用的 def[B] 的元素是在 B 中被定义的变量，比如：\nB: m = k; n = j，def[B] == {m, n} 公式里的 OUT[B] 很好理解，在即将进入 S 块时还活着的，一定在离开 B 时也活着，所以取并。\n而 IN[B] 首先考虑的是在 B 里被使用的变量（不能是 B 里定义并使用）在进入 B 时一定活着；然后如果有一个变量在离开 B 时还活着，但是这个变量又不是在 B 里被定义的，那么一定是从上一个块传进来的，所以我们还要加上 OUT[B] - def[B]。\n算法自己脑跑一遍，一些要点：\n集合的表示方式使用 bit vector 的方式，给每个变量赋予一位的大小，1 表示存活，0 表示死亡。 LVA 是 May Analysis，即 sound 的，可能误报但不会漏报（对某条 path A，可能某个变量 a 一直不会用到，但是在 path B 里 a 被用到了，那么我们认为分叉到 A 和 B 前的交点 a 应该是活着的，尽管代码可能不跑 B） 结束条件是在上一次迭代里对所有 Basic Block B，IN[B] 都没变 Available Expression Analysis AEA 能判断一个表达式在 program point p 是不是有效的\nx op y 在 p 点有效的成立条件：\n从起点开始所有到 p 的 path 都要经过 x op y 的值 没有重新定义 x op y 里的变量（x 或者 y） AEA 关注的是 expression，可以用于优化：对所有 path，如果某个表达式一直出现而且没变，就可以直接复用之前的结果，节省计算\nAEA 使用的是 forward analysis，公式：\n$$ OUT[B] = gen[B] ∪ (IN[B] - kill[B]) $$ $$ IN[B] = ∩ OUT[P] $$\nP 是 B 的前驱，其中对 gen[B] 与 kill[B] 的计算方法如下： gen[B] 就是 B 里出现的 x op y 表达式的集合 kill[B] 是对 IN[B] 里表达式变量成员有做重定义的表达式的集合 注意 IN[B] 是对前驱块 OUT 的交集，因为要求所有 path 都经过（这样才能达到 safe 的要求） 再比如下图：\na 被重定义了，因此 kill[B] 就是 IN 中有变量被重定义的表达式，即 kill[B] == {a+b}，而 IN[B] - kill[B] == {}\nAlgorithm 下面的例子脑跑，要点：\nmust: 需要 safety，所以必须 under-approximation，不能误报 结束条件是 OUT 不变 entry 初始化为空，而其余的都初始化 All，因为要取交集，如果以空开局就全0了 Comparison 三种分析针对三种不同的集合（定义集合、变量集合、表达式集合） Transfer 核心其实都是一样的，只是 LVA 是 backward analysis，所以把 IN 反过来计算 ","date":"2022-11-07T22:41:10+08:00","permalink":"/p/note-data-flow-analysis-applications/","title":"Note: Data Flow Analysis - Applications"},{"content":"https://dtolnay.github.io/rust-quiz\n因为 Quiz 是乱序的，所以完成进度也是乱序的\nQuiz #5: https://dtolnay.github.io/rust-quiz/5\nWhat is the output of this Rust program?\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 trait Trait { fn p(self); } impl\u0026lt;T\u0026gt; Trait for fn(T) { fn p(self) { print!(\u0026#34;1\u0026#34;); } } impl\u0026lt;T\u0026gt; Trait for fn(\u0026amp;T) { fn p(self) { print!(\u0026#34;2\u0026#34;); } } fn f(_: u8) {} fn g(_: \u0026amp;u8) {} fn main() { let a: fn(_) = f; let b: fn(_) = g; let c: fn(\u0026amp;_) = g; a.p(); b.p(); c.p(); } 解答 输出 112\n其实难点就是 b 到底属于哪种类型，需要把第二个实现展开，impl\u0026lt;'a T\u0026gt; Trait for fn(\u0026amp;'a T)，b 我们会推断 _ = \u0026amp;'x u8，b 的类型应该是 fn(\u0026amp;'x u8)，签名按照 fn(T) 来。\nQuiz #10: 方法的覆盖 https://dtolnay.github.io/rust-quiz/10\nWhat is the output of this Rust program?\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 trait Trait { fn f(\u0026amp;self); } impl\u0026lt;\u0026#39;a\u0026gt; dyn Trait + \u0026#39;a { fn f(\u0026amp;self) { print!(\u0026#34;1\u0026#34;); } } impl Trait for bool { fn f(\u0026amp;self) { print!(\u0026#34;2\u0026#34;); } } fn main() { Trait::f(\u0026amp;true); Trait::f(\u0026amp;true as \u0026amp;dyn Trait); \u0026lt;_ as Trait\u0026gt;::f(\u0026amp;true); \u0026lt;_ as Trait\u0026gt;::f(\u0026amp;true as \u0026amp;dyn Trait); \u0026lt;bool as Trait\u0026gt;::f(\u0026amp;true); \u0026lt;dyn Trait as Trait\u0026gt;::f(\u0026amp;true as \u0026amp;dyn Trait); } 解答 输出 222222\n为 bool 实现的方法会覆盖（shadow）掉内在的方法（inherent method），也就是 dyn Trait 那个。\n而现在 Rust 还没有方法去调用那个 dyn Trait，如果按下面的方式调用会报错\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 error[E0034]: multiple applicable items in scope --\u0026gt; questions/010.rs:18:5 | 18 | \u0026lt;dyn Trait\u0026gt;::f(\u0026amp;true); | ^^^^^^^^^^^^^^ multiple `f` found | note: candidate #1 is defined in an impl for the type `dyn Trait` --\u0026gt; questions/010.rs:6:5 | 6 | fn f(\u0026amp;self) { | ^^^^^^^^^^^ note: candidate #2 is defined in the trait `Trait` --\u0026gt; questions/010.rs:2:5 | 2 | fn f(\u0026amp;self); | ^^^^^^^^^^^^ = help: to disambiguate the method call, write `Trait::f(...)` instead Quiz #19: drop https://dtolnay.github.io/rust-quiz/19\nWhat is the output of this Rust program?\n1 2 3 4 5 6 7 8 9 10 11 12 13 struct S; impl Drop for S { fn drop(\u0026amp;mut self) { print!(\u0026#34;1\u0026#34;); } } fn main() { let s = S; let _ = s; print!(\u0026#34;2\u0026#34;); } 解答 输出 21\n比较简单，两个 let 只有一个 S 被创建了，第二个只是转移了所有权，在生命周期结束时调用 drop。\nQuiz #22: 宏的参数 https://dtolnay.github.io/rust-quiz/22\nWhat is the output of this Rust program?\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 macro_rules! m { ($a:tt) =\u0026gt; { print!(\u0026#34;1\u0026#34;) }; ($a:tt $b:tt) =\u0026gt; { print!(\u0026#34;2\u0026#34;) }; ($a:tt $b:tt $c:tt) =\u0026gt; { print!(\u0026#34;3\u0026#34;) }; ($a:tt $b:tt $c:tt $d:tt) =\u0026gt; { print!(\u0026#34;4\u0026#34;) }; ($a:tt $b:tt $c:tt $d:tt $e:tt) =\u0026gt; { print!(\u0026#34;5\u0026#34;) }; ($a:tt $b:tt $c:tt $d:tt $e:tt $f:tt) =\u0026gt; { print!(\u0026#34;6\u0026#34;) }; ($a:tt $b:tt $c:tt $d:tt $e:tt $f:tt $g:tt) =\u0026gt; { print!(\u0026#34;7\u0026#34;) }; } fn main() { m!(-1); m!(-1.); m!(-1.0); m!(-1.0e1); m!(-1.0e-1); } 解答 输出 22222\ntt 表示 token，这个宏的功能是按传入的 token 数分类。\nRust 的编译器会把 - 单独看成一个负号，五个调用都是一个负号加一个数字。\nlet x = -2.pow(2) 会被解析成 -(2.pow(2)) 而不是 (-2).pow(2)\nQuiz #24: 关于宏的 \u0026lsquo;hygiene\u0026rsquo; https://dtolnay.github.io/rust-quiz/24\nWhat is the output of this Rust program?\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 fn main() { let x: u8 = 1; const K: u8 = 2; macro_rules! m { () =\u0026gt; { print!(\u0026#34;{}{}\u0026#34;, x, K); }; } { let x: u8 = 3; const K: u8 = 4; m!(); } } 解答 输出 14\n对于宏而言有一个概念叫 hygiene，中文是【卫生】的意思，由【宏如何处理外部变量】来区分是否 hygiene\n有一个 reddit 上对此的讨论，摘抄一个回答：\nFor example, if you declare a variable named x inside a macro and you happen to call that macro on an x from somewhere else, it won\u0026rsquo;t suddenly and magically cause things to break because the compiler will know that they\u0026rsquo;re two different things.\n(The gist is that macros in languages like C have some very surprising misbehaviours and \u0026ldquo;hygienic\u0026rdquo; macros will behave more like functions when it comes to things like variable scopes and order of operations.)\n如果编译器不处理出现在宏里的变量名，而是等着直接展开（如 C 语言），那么这个应该算作不卫生，因为可能会出现外部变量命名为 a，而宏内使用了 a 变量，使用结果会因为外部变量命名不同而有变化。\nRust 是门“部分卫生”的语言，会对一部分的外部变量进行处理。但是仅限本地变量，对 const 不会做处理（const 变量会被认为是个普通的单词而不是变量）。因此在这题里，Rust 会先把外边的 x 编进宏内，之后再进行展开，最终打印 14。\nhygiene 相关的笔记\nQuiz #33: RangeFull https://dtolnay.github.io/rust-quiz/33\nWhat is the output of this Rust program?\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 use std::ops::RangeFull; trait Trait { fn method(\u0026amp;self) -\u0026gt; fn(); } impl Trait for RangeFull { fn method(\u0026amp;self) -\u0026gt; fn() { print!(\u0026#34;1\u0026#34;); || print!(\u0026#34;3\u0026#34;) } } impl\u0026lt;F: FnOnce() -\u0026gt; T, T\u0026gt; Trait for F { fn method(\u0026amp;self) -\u0026gt; fn() { print!(\u0026#34;2\u0026#34;); || print!(\u0026#34;4\u0026#34;) } } fn main() { (|| .. .method())(); } 解答 输出24\nRangeFull 其实就是 ..，是可以单独使用的，如下：\n1 2 3 4 5 6 7 let arr = [0, 1, 2, 3, 4]; assert_eq!(arr[ .. ], [0, 1, 2, 3, 4]); // This is the `RangeFull` assert_eq!(arr[ .. 3], [0, 1, 2 ]); assert_eq!(arr[ ..=3], [0, 1, 2, 3 ]); assert_eq!(arr[1.. ], [ 1, 2, 3, 4]); assert_eq!(arr[1.. 3], [ 1, 2 ]); assert_eq!(arr[1..=3], [ 1, 2, 3 ]); 但不能直接用于循环 for i in ..\n这题只可能两种答案，1 或者 24，解析成 || ((..).method()) 就是 1，解析成 (|| ..).method() 就是 24\n","date":"2022-10-19T23:30:23+08:00","permalink":"/p/rust-quiz-%E8%AE%B0%E5%BD%95/","title":"Rust Quiz 记录"},{"content":"本文章内容：使用 TypeScript 实现 Rust 的部分模式匹配特性（match、Option、Result）\n标题可以理解为《 Rust 味的 TypeScript 》\n阅读须知：\n无需 Rust 基础知识，也与 Rust 最难的内存安全模型无关 包含对模式匹配的理解 包含一种实现的开源代码讲解 少量类型体操 模式匹配 (Pattern Matching) 是什么 函数式编程里的概念 模式匹配是检查给定记号序列中，是否存在某种模式的组成部分的行为。——维基\npattern matching is the act of checking a given sequence of tokens for the presence of the constituents of some pattern. —— Wikipedia\n模式可以理解为【规律】。定义听起来很抽象，举一点例子之后是很容易理解这个名字的。\nswitch、RegExp 是一种模式匹配 1 2 3 4 5 6 7 8 fn main() { let x = 1; match x { 1 =\u0026gt; println!(\u0026#34;one\u0026#34;), 2 =\u0026gt; println!(\u0026#34;two\u0026#34;), _ =\u0026gt; println!(\u0026#34;anything\u0026#34;), } } 最简单的使用就像一个 switch，但是除了能匹配出值，也能匹配出位置、甚至名字。\n对后面这句是不是有点想法？\n1 2 3 4 5 const { a, b } = { a: 1, b: 2 }; // a should be 1; b should be 2. const [ a, _, ...c ] = [ 1, 2, 3, 4, 5 ]; // a should be 1; c should be [3,4,5]. 其实js里的解构赋值就是一种模式匹配，除了【条件执行】以外，还有【提取】出想要的数据的功能。回过头看正则表达式，就能很容易理解这个概念，既可以test去测试是否匹配，又可以exec去捕获匹配到的数据。\nIn contrast to pattern recognition, the match usually has to be exact: \u0026ldquo;either it will or will not be a match.\u0026quot;—— Wikipedia\n在维基里还指出了模式匹配与模式识别（Pattern Recognition）的一个区别，就是前者一般来说是精确 的，要么会被匹配，要么不会被匹配（对于一个分支来说），不会有置信度多少的匹配情况。\n好处在哪 符合人类思考方式的设计 使用 if 并不是我们的第一思考方式 比如我们现在想要计算某一个规则二维图形的周长，这个图形可能是矩形、圆形或者三角形，那么我们写代码的时候可能会这样写：\n1 2 3 4 5 6 7 8 9 10 11 let c; if (shape == Rectangle) { let len, wide = shape.len, shape.wide; c = (len + wide) * 2; } else if (shape == Circle) { let r = shape.r; c = pi * r * 2; } else if (shape == Triangle) { let {side1, side2, side3} = shape; c = side1 + side2 + side3; } 这种代码与我们的思考方式有相悖的地方：\n我们辨识一个二维图形的时候并不是用排除法的，我们可以一眼看出来这是什么图形，不需要一步步排除 这种代码需要先假设一个周长未知（即变量c）的图形，之后再进行填充，风险就是可能直到最后的 else if 都没匹配上，这样 c 就成了一个未初始化的值（Uninitialized variable），众所周知这种情况常常导致 bug / undefined behavior 因此，我们希望有一种更加阳间的写法：\n1 2 3 4 5 let c = match shape { Rectangle {len, wide} =\u0026gt; (len+wide)*2, Circle {r} =\u0026gt; pi * r * 2, Triangle {side1, side2, side3} =\u0026gt; side1 + side2 + side3, }; 即使是没学过match语法的人应该也能看懂这样的写法，语义上可以理解为：\n我们想计算c，需要对它的类型进行一次匹配，而且我们可以看出是三种类型中的一种，然后我们将从对应的类型里提取出需要的参数并进行计算（看成一个解构赋值）。\n这里是否解决了上述可能导致ub的问题？答案是在编译器的帮助下，是可以的。在类型安全的规则下，我们应当知道shape的取值范围，如果有第四种图形，那么应当在某个地方（比如类型声明）上有所体现，如果不能匹配出结果，那么这条match表达式将不知道返回什么数据，应该抛出错误。\n虽然感觉例子有点小刻意，但我觉得对理解模式匹配的好处很有帮助。\n【条件执行】与【提取】的兼得 If 只能做到条件筛选，却不好做赋值 当然也可以用 if (a = 114514) 这样的混沌写法，但是在实践上一般是拒绝这种写法的，因为这并不是“有条件”地赋值，早已不被提倡\n在上面的例子中，我们在每个判断后加上一行赋值（不加也行，但是你的成员调用将会很啰嗦），实际上是不太有额外信息量的语句，我相信优雅流畅的代码应如自然语言一样好读\n在 Rust 里确实有带条件的赋值，请自行学习 if let 语法\n从语句到表达式 的转变 表达式提供了更灵活的写法 注意甄别语句和表达式（statement vs expression）\n接触过编译原理的话应该能记住区别，忘记了也不要紧，简单概括就是：\n语句是一个过程 表达式是一个值 比如箭头函数() =\u0026gt; 1，我们偶尔打顺手在1后多了个分号的时候，编译器往往会尝试纠正你，因为1;是语句，而不是表达式。 再比如我们写 jsx：\n1 2 3 4 // valid \u0026lt;div\u0026gt;{ condition ? \u0026#39;true\u0026#39;: \u0026#39;false\u0026#39; }\u0026lt;/div\u0026gt; // invalid \u0026lt;div\u0026gt; { if (condition) {\u0026#39;true\u0026#39;;} else { \u0026#39;false\u0026#39;; } } \u0026lt;/div\u0026gt; 我想上面两段想表达的是同一个语义：如果条件成立，那么渲染 \u0026lt;div\u0026gt;true\u0026lt;/div\u0026gt; ，否则渲染 \u0026lt;div\u0026gt;false\u0026lt;/div\u0026gt;\n但是显然下面的是非法的，因为它是一个 if 语句，而不是表达式，不具有值。\n从上面举过的图形周长的例子里，我们在match后可以直接赋值给c，因此match是一个表达式而不是值\n这也是跟switch的一个区别，因为switch也是一个语句而不是表达式。\n表达式有比语句更灵活的特点，因为expression是statement的组成，当表达式不赋值给变量的时候我们也可以当做一个只包含一个expression的statement，这种设计有助于更优雅地编程。\n性能有提升吗？ 实际上模式匹配带来的是抽象层面的升华，计算机总归无法像人类一样思考，因此在性能方面并不是其优势，底层实现就是一堆 if else。\n可以参考这个回答：How is match implemented in a language like Rust?\n其中的回答给了这个例子：\n1 2 3 4 5 6 7 8 9 10 11 enum Result { SingleResult(i32), TwoResults(i32, i32), Error } match someResult { Result::SingleResult(res) =\u0026gt; f(res), Result::TwoResults(res1, res2) =\u0026gt; g(res1, res2), Result::Error =\u0026gt; error() } 上面的 enum 是 Rust 里的枚举值，与大多语言不一样的是，Rust 的枚举值里是可以携带额外的信息的（可以是结构、数组、元组、基本类型等等）\n其实现后的C代码大概如下\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 struct Result { enum { SingleResult, TwoResults, Error } tag; union { struct { int arg1; } singleResult; struct { int arg1; int arg2; } twoResults; } value; }; switch(someResult.tag) { case SingleResult: { int res = someResult.value.singleResult.arg1; f(res); break; } case TwoResults: { int res1 = someResult.value.twoResults.arg1; int res2 = someResult.value.twoResults.arg2; g(res1, res2); break; } case Error: { error(); break; } } 上面的union在TypeScript里有更为优雅的表达（缺点是没把SingleResult与{arg1: number}绑定起来）：\n1 2 3 4 interface Result { tag: enum ResultTag { SingleResult, TwoResults, Error }, value: {arg1: number} | {arg1: number, arg2: number}, } 这个涉及代数数据类型（Algebraic Data Type），指可以进行代数运算的类型（比如 |，\u0026amp; 等），不是讲述重点，请自己查阅资料 Algebraic_data_type——wiki\nRust 的 Option, Result\u0026lt;T, E\u0026gt; 与 match Option 1 2 3 4 enum Option\u0026lt;T\u0026gt; { None, Some(T), } 尖括号很容易看出来是泛型的意思，而 Some(T) 代表一个 Some 中可以携带一个T类型的值，比如 Option 这个枚举类型包括了 None 或者 Some(i32) 两种枚举值，而 Some(114514) 就是一个Option类型。\n重新思考一下上面说的携带不同类型值的 enum 的底层实现，就是那个 union，就能理解“携带值的枚举值”这件事。\n一个 Option 类型的值代表其处于有值（Some）跟没值（None）的叠加态，对其进行观察（匹配）将坍塌到其中一个状态 XD\n如果解析出来这个值是Some，那么我们将可以类型安全地 访问到其里面的值。（意味着编译器可以帮助你规范行为，也可以帮你做好语法提示，访问里面的值一定是类型安全的，即不会在类型上翻车）\nResult\u0026lt;T, E\u0026gt; 1 2 3 4 enum Result\u0026lt;T, E\u0026gt; { Ok(T), Err(E), } 我认为上面讲过 Option 后，理解 Result 应该也很简单，一个 Result 类型的值处于成功与失败的叠加态，如果成功，就能类型安全地访问其中的 T 类型但无法访问 E 类型的值（union 只能同时存在一个对吧），如果失败，我们能安全地访问错误里的 E 类型，此时又无法访问 T 类型的值。\n很明显这个可以用在错误处理的领域，我觉得会很容易联想到大道至简的 go\n1 2 3 4 5 res, err := function() if err != nil { // handle the error } use(res) 偶尔能见到 gopher 管自己叫 if err != nil 工程师，因为一个可能发生错误的函数往往是这么返回数据的，通过校验是否有 err 来判断成功与否，这种处理方式的缺陷除了写起来很啰嗦外，还有一个缺陷，就是处理可能不到位。\n1 2 3 4 5 6 7 res, err := function() if err != nil { fmt.println(\u0026#34;some error|\u0026#34;, err) // forget to return! } // use an invalid res! use(res) 实际上，这种错误处理全凭自觉，我们将正确处理的结果与错误处理的失败原因一起返回，只能通过程序员自觉去处理这种关系，但偶尔可能在处理 err 后，忘记 return 了，而且也没对 res 进行再处理，导致执行流继续进行下去，访问了不该访问的res（此时无法知道是什么值），将会产生 ub。\n而 Result 是解决这个问题的利器，因为处于成功状态的结果无法访问失败状态的类型，而失败的结果无法访问成功时的数据，即使代码还没开始跑，你也知道肯定不会出错。\n常用的错误处理还有try catch系列，依然需要靠自觉，常有忘记在throwable的函数外加try，导致无法正常捕获到错误（Uncaught error）的事发生（比如对内层函数不了解的话就无法知道是否throwable，虽然常有兜底的最外层try，但是在抛出错误后却会中断执行流，无法返回到某个想回去的地方，灵活性比较低，而且写起来缩进确实不怎么好看。\n🤔Promise对象与上面提到的 Option、Result 源自同样的设计思想，先占坑，在运行时再确定这个坑里应当填入啥，不同的结果状态之间是隔离的，从而做到【编译期确定的】类型安全，同时也方便更直观的链式调用，在函数式编程中，这种概念叫 Monad（单子）。 wiki-Monad\nmatch 模式是 Rust 中特殊的语法，它用来匹配类型中的结构，无论类型是简单还是复杂。结合使用模式和 match 表达式以及其他结构可以提供更多对程序控制流的支配权。模式由如下一些内容组合而成：\n字面值 解构的数组、枚举、结构体或者元组 变量 通配符 占位符 通过以下代码来理解： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 enum Message { Quit, Move { x: i32, y: i32 }, Write(String), ChangeColor(i32, i32, i32), } fn main() { let msg = Message::ChangeColor(0, 160, 255); match msg { Message::Quit =\u0026gt; { println!(\u0026#34;The Quit variant has no data to destructure.\u0026#34;) } Message::Move =\u0026gt; { println!( \u0026#34;Move in the x direction {} and in the y direction {}\u0026#34;, x, y ); } Message::Write(text) =\u0026gt; println!(\u0026#34;Text message: {}\u0026#34;, text), Message::ChangeColor(r, g, b) =\u0026gt; println!( \u0026#34;Change the color to red {}, green {}, and blue {}\u0026#34;, r, g, b ), } } 代码来自 模式与模式匹配 - Rust 程序设计语言 简体中文版\n其实就是匹配成功后还能捕获其中的值。\nOption in TS 前面讲了非常非常多的铺垫，终于到正题了，如何在 TS 里实现上面讲了一大通的这些特征？ 下面的内容是对一个开源实现 oxide.ts 的源码解读 仓库地址，源码测试、文档全覆盖，堪称优雅的仓库，也很推荐阅读。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 // src/common.ts export const SymbolT = Symbol(\u0026#39;T\u0026#39;); export const SymbolVal = Symbol(\u0026#39;Val\u0026#39;); // src/option.ts export type Some\u0026lt;T\u0026gt; = OptionType\u0026lt;T\u0026gt; \u0026amp; { [SymbolT]: true }; export type None = OptionType\u0026lt;never\u0026gt; \u0026amp; { [SymbolT]: false }; class OptionType\u0026lt;T\u0026gt; { readonly [SymbolT]: boolean; readonly [SymbolVal]: T; constructor(val: T, some: boolean) { this[SymbolT] = some; this[SymbolVal] = val; } } Option 的核心是实现一个 OptionType，而 Some 与 None 均源自 OptionType。\nSymbolT 和 SymbolVal 是两个 Symbol 类型的值，意味着 OptionType 里其他的键不会与这俩发生冲突（js的类型因为使用字符串作成员名的缘故常有冲突发生的情况，比如 obj[\u0026rsquo;toString\u0026rsquo;] 就与某个内置方法冲突了）\n有了 Some 和 None 类型，如何创建一个这个类型的值？通过构造函数就行了\n1 2 3 4 5 6 7 8 export const None = Object.freeze( new OptionType\u0026lt;never\u0026gt;(undefined as never, false) ) as None; /// 使用 Some() export function Some\u0026lt;T\u0026gt;(val: T): Some\u0026lt;T\u0026gt; { return new OptionType(val, true) as Some\u0026lt;T\u0026gt;; } Tips: 变量名跟类型名是不冲突的，意味着下面的代码成立。\n1 2 3 4 type a = number; function a(): a { return 1; } Object.freeze 的作用是创建一个无法增删改字段的对象\n我们通过下面的方式分别创建变量\n分别打印a, b，可以得到以下结果\n基于Symbol(Val)和Symbol(T)这两个字段，我们可以构造出许多有用的方法，为了找一个无法静态编译期确定的例子（即运行后才知道成不成功），我先构造一个 Rusty （有 Rust 风格的）的处理函数在这。\n1 2 3 4 5 6 7 function rustyParseInt(str: string): Option\u0026lt;number\u0026gt; { const res = parseInt(str); if (isNaN(res)) { return None; } return Some(res); } 上述函数是对 parseInt的包装，原生 parseInt 在解析失败时会返回一个 NaN，我们将NaN改成None，解析成功则返回Some\n看下面的方法：\n1 2 3 4 5 6 7 8 9 10 11 /// Option必须是一个Some，否则抛出错误（在rust里是panic） expect(this: Option\u0026lt;T\u0026gt;, msg: string): T { if (this[SymbolT]) { return this[SymbolVal]; } else { throw new Error(msg); } } // example.ts const a: number = rustyParseInt(\u0026#39;would_fail\u0026#39;).expect(\u0026#39;fail_reason\u0026#39;); expect可以视为对【某个Option的实例应是Some】的断言，并返回其中的类型，如果不是Some将抛出错误。\n运行example.ts后将会抛出理由为fail_reason的错误\n由expect，又可以包装出多种方法\n1 2 3 unwrap(this: Option\u0026lt;T\u0026gt;): T; unwrapOr(this: Option\u0026lt;T\u0026gt;, def: T): T; unwrapOrElse(this: Option\u0026lt;T\u0026gt;, f: () =\u0026gt; T): T; 对原有 API 的安全封装 该库提供了 safe 函数，用于安全地 捕获一个同步/异步函数的结果为Option，而不会抛出错误或者引发reject。\n下面截图即safe的实现代码，vscode能在then里做出正确的类型推断。\n乍一看上面有三个safe，JS/TS 并不支持函数重载（Function Override），这是 TS 的 Function Overload 的特性，详见文档 functions overload。\n意思是，上面两个safe是实际使用时的应当约束的函数类型，最下面的safe是对上面两种签名的兼容性实现。\n1 2 3 4 5 6 7 8 9 10 11 12 13 function makeDate(timestamp: number): Date; function makeDate(m: number, d: number, y: number): Date; function makeDate(mOrTimestamp: number, d?: number, y?: number): Date { if (d !== undefined \u0026amp;\u0026amp; y !== undefined) { return new Date(y, mOrTimestamp, d); } else { return new Date(mOrTimestamp); } } const d1 = makeDate(12345678); const d2 = makeDate(5, 5, 5); const d3 = makeDate(1, 3); // No overload expects 2 arguments, but overloads do exist that expect either 1 or 3 arguments. 上面是官方的例子，看一下就懂了，d1, d2 都可以被正常编译，d3 则通过不了类型检查，尽管符合第三个makeDate的函数签名。\n回到上面 safe 的实现（与前面是同一张图，方便观看），第一个签名接受的是一个同步函数及该函数的参数，通过 PromiseLike 来约束是否异步函数，是则要求返回值为never类型，代表一个不会返回的函数（一定会throw，或是无限循环），既然无法返回也就不会需要safe包装返回值。\n一个 PromiseLike 接口要求实现 then(onfulfilled, onerjected)，具体看TS的官方文档 PromiseLike 接口文档\n第二个签名接受一个 Promise 对象作为参数，其实就是异步函数执行后的返回值。返回一个 Promise\u0026lt;Option\u0026gt;的结果，注意一个Option\u0026lt;Promise\u0026gt;的类型是没有实用意义的，因为不管resolve还是reject，都会得到一个Some结果，所以一个实用的包装应当是 Promise\u0026lt;Some\u0026gt;与Promise，对应了resolve与reject的结果。\n实现上很简单，把 throw、reject 包装成 None, 把 resolve 和正常执行包装为 Some 即可。\n其他的方法 Option 提供了一些其他的方法，实现都很简单，意义也清楚所以不详细介绍。\n1 2 3 isNone() isSome() map\u0026lt;U\u0026gt;(this: Option\u0026lt;T\u0026gt;, f: (val: T) =\u0026gt; U): Option\u0026lt;U\u0026gt; Result\u0026lt;T, E\u0026gt; in TS Result 跟 Option 的实现就没有太大差别了，除了 Result 在失败时可以携带错误信息\n1 2 3 4 5 6 7 8 9 10 11 export type Ok\u0026lt;T\u0026gt; = ResultType\u0026lt;T, never\u0026gt;; export type Err\u0026lt;E\u0026gt; = ResultType\u0026lt;never, E\u0026gt;; export class ResultType\u0026lt;T, E\u0026gt; { readonly [SymbolT]: boolean; readonly [SymbolVal]: T | E; constructor(val: T | E, ok: boolean) { this[SymbolVal] = val; this[SymbolT] = ok; } } Ok 与 Err 的构造方式也很简单\n1 2 3 4 5 6 export function Ok\u0026lt;T\u0026gt;(val: T): Ok\u0026lt;T\u0026gt; { return new ResultType\u0026lt;T, never\u0026gt;(val, true); } export function Err\u0026lt;E\u0026gt;(val: E): Err\u0026lt;E\u0026gt; { return new ResultType\u0026lt;never, E\u0026gt;(val, false); } match in TS oxide.ts 对 match 的实现应该是最好玩的地方，在看如何实现之前，先看实现了怎样的功能\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 // mapped matching const num = Option(10); const res = match(num, { Some: (n) =\u0026gt; n + 1, _: () =\u0026gt; 0, }); assert.equal(res, 11); // chained matching function matchArr(arr: number[]): string { return match(arr, [ [[1], \u0026#34;1\u0026#34;], [[2, (x) =\u0026gt; x \u0026gt; 10], \u0026#34;2, \u0026gt; 10\u0026#34;], [[_, 6, 9, _], (a) =\u0026gt; a.join(\u0026#34;, \u0026#34;)], () =\u0026gt; \u0026#34;other\u0026#34;, ]); } assert.equal(matchArr([1, 2, 3]), \u0026#34;1\u0026#34;); assert.equal(matchArr([2, 12, 6]), \u0026#34;2, \u0026gt; 10\u0026#34;); assert.equal(matchArr([2, 4, 6]), \u0026#34;other\u0026#34;); assert.equal(matchArr([3, 6, 9]), \u0026#34;other\u0026#34;); assert.equal(matchArr([3, 6, 9, 12]), \u0026#34;3, 6, 9, 12\u0026#34;); Mapped matching 实现了对 Option / Result 的匹配， Chained matching 实现了更加灵活、定制化的匹配，可以匹配具体的值、也可以使用规则去匹配 实现 Match 的相关实现长下面这样：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 export const Default: any = () =\u0026gt; { throw new Error(\u0026#34;Match failed (exhausted)\u0026#34;); }; export function match\u0026lt;T, U\u0026gt;( val: T, pattern: MappedBranches\u0026lt;T, U\u0026gt; | ChainedBranches\u0026lt;T, U\u0026gt; ): U { return matchDispatch(val, pattern, Default); } function matchDispatch\u0026lt;T, U\u0026gt;( val: T, pattern: ChainedBranches\u0026lt;T, U\u0026gt; | MappedBranches\u0026lt;T, U\u0026gt;, defaultBranch: DefaultBranch\u0026lt;U\u0026gt; ): U { if (Array.isArray(pattern)) { return matchChained(val, pattern, defaultBranch); } else if (isObjectLike(pattern)) { return matchMapped(val, pattern, defaultBranch); } throwInvalidPattern(); } match接收待匹配的值跟分支的模式作为参数，然后调用 matchDispatch。\n分支有mapped和chained两种，通过 isArray 和 isObjectLike 区分，然后分别进入 mapped 和 chained 的处理逻辑。\nmapped matchMapped 只支持对 Option 和 Result 进行匹配，然后对 pattern 中的项进行匹配。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 function matchMapped\u0026lt;T, U\u0026gt;( val: T, pattern: OptionMapped\u0026lt;any, U\u0026gt; \u0026amp; ResultMapped\u0026lt;any, any, U\u0026gt;, defaultBranch: DefaultBranch\u0026lt;U\u0026gt; ): U { if (Option.is(val)) { if (val[SymbolT]) { if (pattern.Some) { if (typeof pattern.Some === \u0026#34;function\u0026#34;) { // 对于 Some 类型，如果其匹配后跟的是 function，说明是对值的任意匹配 return pattern.Some(val[SymbolVal]); } else { // 不是function，说明可能有更进一步的匹配（具体的值、位置等等），则再次调用dispatch对值进行更细化的匹配，注意的是第三个参数defaultBranch，如果Some中提供了默认分支，那么进入，否则不进入该分支而是使用外层的默认分支（即最外层的 _: () =\u0026gt; something） return matchDispatch( val[SymbolVal], pattern.Some, typeof pattern._ === \u0026#34;function\u0026#34; ? pattern._ : defaultBranch ); } } } else if (typeof pattern.None === \u0026#34;function\u0026#34;) { // 对None匹配的处理 return pattern.None(); } } else if (Result.is(val)) { // 对Result分支的处理，跟Option基本相同 const Branch = val[SymbolT] ? pattern.Ok : pattern.Err; if (Branch) { if (typeof Branch === \u0026#34;function\u0026#34;) { return Branch(val[SymbolVal]); } else { // 既没在Option中匹配到也没在Result里匹配到，进入默认分支，如果提供了 _ 的匹配就执行自定义的默认分支，否则进入参数的defaultBranch // 最上面的 defaultBranch 传入了一个会抛出异常的函数Default，即代表没有分支能处理val，这是不可接受的 return matchDispatch( val[SymbolVal], Branch, typeof pattern._ === \u0026#34;function\u0026#34; ? pattern._ : defaultBranch ); } } } else { throwInvalidPattern(); } return typeof pattern._ === \u0026#34;function\u0026#34; ? pattern._() : defaultBranch(); } chained Chained mapping 支持更加灵活的模式匹配，下面展示部分匹配的方式\n1 2 3 4 5 6 7 8 9 10 const res = match(input, [ [1, \u0026#34;number\u0026#34;], // 匹配准确的值 [testObj, \u0026#34;object\u0026#34;], // 匹配准确的对象（浅，同一个对象才能匹配上） [\u0026#34;test\u0026#34;, (val) =\u0026gt; `string ${val}`], // 匹配准确的值，并使用函数作为Result，以捕获到 match 的 input 值 [(val) =\u0026gt; val === true, \u0026#34;true\u0026#34;], // 提供 filter 作为匹配条件 [(val) =\u0026gt; (val as number) \u0026gt; 5, (val) =\u0026gt; `num ${val}`], // 提供 filter 为匹配条件，并使用函数作为 Result 捕获 input [Fn(returnTrue), \u0026#34;fn true\u0026#34;], // 匹配一个函数 returnTrue，使用 Fn() 包装以跟 filter 区分开 [Fn(returnFalse), \u0026#34;fn false\u0026#34;], // 匹配一个函数 returnFalse，使用 Fn() 包装以跟 filter 区分开 () =\u0026gt; \u0026#34;default\u0026#34;, // 默认匹配，如果没法匹配到上述项将执行 ]); 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 type ChainedBranches\u0026lt;T, U\u0026gt; = | Branch\u0026lt;T, U\u0026gt;[] | [...Branch\u0026lt;T, U\u0026gt;[], DefaultBranch\u0026lt;U\u0026gt;]; function matchChained\u0026lt;T, U\u0026gt;( val: T, pattern: ChainedBranches\u0026lt;T, U\u0026gt;, defaultBranch: DefaultBranch\u0026lt;U\u0026gt; ): U { // 遍历 chianed branches，得到每个分支 for (const branch of pattern) { // 分支允许接受函数作为分支，限定为经过 `Fn\u0026lt;U\u0026gt;` wrap 过的函数以及默认的分支 () =\u0026gt; U if (typeof branch === \u0026#34;function\u0026#34;) { return (branch as Fn\u0026lt;U\u0026gt;)[FnVal] ? (branch as Fn\u0026lt;U\u0026gt;)[FnVal] : branch(); } else { const [cond, result] = branch; // 每个分支分为条件与结果，使用 matches 判断是否匹配上了，在匹配上的情况下： if (matches(cond, val, true)) { if (typeof result === \u0026#34;function\u0026#34;) { // 如果结果是 `Fn\u0026lt;U\u0026gt;` wrap 过的则返回函数本身 // 结果是普通函数就执行匹配结果 return (result as Fn\u0026lt;U\u0026gt;)[FnVal] ? (result as Fn\u0026lt;U\u0026gt;)[FnVal] : (result as (val: T) =\u0026gt; U)(val); } else { // 非函数就返回数值 return result; } } } } // 都不是则执行默认分支 return defaultBranch(); } 下面介绍下 Fn\u0026lt;U\u0026gt; 是做什么的：\n1 2 3 4 5 6 7 export const FnVal = Symbol(\u0026#34;FnVal\u0026#34;); export function Fn\u0026lt;T extends (...args: any) =\u0026gt; any\u0026gt;(fn: T): () =\u0026gt; T { const val: any = () =\u0026gt; throwFnCalled(); (val as any)[FnVal] = fn; return val; } export type Fn\u0026lt;T\u0026gt; = { (): never; [FnVal]: T }; Fn 是类型也是函数，作为类型的时候表示一个无法被执行（即返回never，在实现里，一定会throw 一个错误的函数），但是存储了函数（通过 FnVal 这个 Symbol 类型来索引）的对象。\nFn 的作用是将函数包装成一个可以被匹配、可以作为匹配结果的对象，而不是在匹配成功时执行、或是作为 filter 存在，如下：\n1 2 3 4 5 // 使用 Fn 作为分支，匹配成功将返回函数 match(Some(1), [ [Some(1), Fn(()=\u0026gt;\u0026#34;1\u0026#34;)], Fn(()=\u0026gt;\u0026#39;default\u0026#39;), ])() 下面介绍返回是否匹配条件的 matches 的实现：\n不过先看看什么样可以算一个合理的条件：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 type Branch\u0026lt;T, U\u0026gt; = [BranchCondition\u0026lt;T\u0026gt;, BranchResult\u0026lt;T, U\u0026gt;]; type BranchCondition\u0026lt;T\u0026gt; = | Mapped\u0026lt;T, boolean\u0026gt; | (T extends { [T]: boolean } ? MonadCondition\u0026lt;T\u0026gt; : Condition\u0026lt;T\u0026gt;); type Condition\u0026lt;T\u0026gt; = T extends object ? { [K in keyof T]?: BranchCondition\u0026lt;T[K]\u0026gt; } : T; type MonadCondition\u0026lt;T\u0026gt; = T extends Option\u0026lt;infer U\u0026gt; ? Some\u0026lt;MonadCondition\u0026lt;U\u0026gt;\u0026gt; | None : T extends Result\u0026lt;infer U, infer E\u0026gt; ? Ok\u0026lt;MonadCondition\u0026lt;U\u0026gt;\u0026gt; | Err\u0026lt;MonadCondition\u0026lt;E\u0026gt;\u0026gt; : Wide\u0026lt;T\u0026gt;; type MonadMapped\u0026lt;T, U\u0026gt; = | Mapped\u0026lt;T, U\u0026gt; | ChainedBranches\u0026lt;T, U\u0026gt; | MappedBranches\u0026lt;T, U\u0026gt;; type Mapped\u0026lt;T, U\u0026gt; = (val: T) =\u0026gt; U; type Wide\u0026lt;T\u0026gt; = T extends [...infer U] ? U[number][] : Partial\u0026lt;T\u0026gt;; 我们知道一个分支分成条件和结果，看 BranchCondition 即分支条件，可以是以下的情况\nMapped，表示被准确匹配的值，比如 Some(1) 这样的 根据是否有 [T] 成员来区分是否 Option/Result，注意这个 T 并不是类型，而是那个 Symbol 变量 有 [T] 的说明是 Option 或者 Result，进入 MonadCondition 分别通过匹配 Option 和 Result 来确定类型 都不是则进入 Wide 如果是数组就是对数组的匹配 如果不是数组就是对 T 部分字段的匹配 没有 [T] 进入普通的条件 Condition，通过变量是否对象来分类 是对象的话，那么类型需要进行筛选一下，只选出需要的字段及其类型，每个字段都是一个独立的分支条件（BranchCondition） 不是对象的话就直接匹配该值的类型即可 Monad（单子）是前面介绍过的一个概念，简单说代表一个占坑的变量，可以是几种状态的叠加 下面则是返回是否匹配条件的 matches 函数：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 function matches\u0026lt;T\u0026gt;( cond: BranchCondition\u0026lt;T\u0026gt;, val: T, evaluate: boolean ): boolean { if (cond === Default || cond === val) { // 如果直接匹配上了或者是默认分支则直接返回true return true; } if (typeof cond === \u0026#34;function\u0026#34;) { // 如果是被包装后的函数就判断是不是该函数， // 否则，只有在 evaluate 为 true （代表要判断其值）时执行条件函数 return (cond as Fn\u0026lt;T\u0026gt;)[FnVal] ? (cond as Fn\u0026lt;T\u0026gt;)[FnVal] === val : evaluate \u0026amp;\u0026amp; (cond as (val: T) =\u0026gt; boolean)(val); } // 如果是对象 if (isObjectLike(cond)) { if (T in cond) { // 如果 val 是条件的一部分，再深入判断（再次调用matches，字段级匹配） return ( (cond as any).isLike(val) \u0026amp;\u0026amp; matches((cond as any)[Val], (val as any)[Val], false) ); } if (isObjectLike(val) \u0026amp;\u0026amp; Array.isArray(cond) === Array.isArray(val)) { // 对数组匹配，元素级匹配 for (const key of Object.keys(cond)) { if ( !(key in val) || !matches((cond as any)[key], (val as any)[key], evaluate) ) { return false; } } return true; } } return false; } 小结 通过把类型一层一层抽象，实现类型安全的匹配 Chained 的匹配提供了比 mapped 更灵活的使用方式 题外 为什么只广泛在函数式编程流行 参考 Why-is-pattern-matching-prevalent-only-in-functional-programming-languages\n模式匹配实际上和一个强大的类型系统有很强的关系，那就是代数数据类型（Algebraic Data Type），在前面简单提到过，比如 | 为传统的 union 类型提供了更强大的表达能力，\u0026amp; 也比复杂的继承更好写。 因为 C 没有 在一些比较新的语言里（比如 TypeScript 和 Rust）强大的类型系统就为模式匹配提供了土壤。 现在的 OO 语言也在一些比较微观的层面上引入了一些函数式编程的概念，来提高程序的表达能力，比如 Python3.10 就引入了 match，C# 也引入了match。\nECMAScript 里的进展 GitHub - tc39/proposal-pattern-matching: Pattern matching syntax for ECMAScript\n还在 Proposal 阶段，提了好多年了似乎没什么进展，不过 star 还是很多的\n提案中提供了类似以下的匹配方式：\n1 2 3 4 5 6 7 8 9 10 match (res) { when ({ status: 200, body, ...rest }): handleData(body, rest) when ({ status, destination: url }) if (300 \u0026lt;= status \u0026amp;\u0026amp; status \u0026lt; 400): handleRedirect(url) when ({ status: 500 }) if (!this.hasRetried): do { retry(req); this.hasRetried = true; } default: throwSomething(); } 实际上感觉不如前面实现的那种那种好看\n总结 介绍了模式匹配的实现与好处： 符合思考方式 条件与赋值的兼得 语句到表达式的转变（表达能力的增强） Monad 式的类型安全错误处理 用 TS 实现 match：类型的一层层抽象 投入生产？原生的支持不够强大：编译器对分支覆盖的检查能力不足 参考 How is match implemented in a language like Rust? Why-is-pattern-matching-prevalent-only-in-functional-programming-languages Algebraic-data-type-wiki functions overload ","date":"2022-09-12T18:02:35+08:00","permalink":"/p/rusty-typescript--pattern-matching/","title":"Rusty Typescript -- Pattern Matching"},{"content":"rCoreCamp2022-lab4记录 Lab4 本体 lab地址\nLab4 的难度感觉比 Lab3 高了一档，因为之前在学校或者自己学 OS 的时候都基本都没学到文件系统，所以这一张属于是真的新学了。在理解上遇到了很大的障碍，代码也很难憋出来。\n0. 迁移代码 唯一的难点是，这章使用文件系统代替了loader，因此\u0008加载用户程序的方式从 get_app_by_name 从loader里取改成了用文件系统的api 去打开文件\n下面的代码片段摘自 sys_spawn，使用open_file 去获取 inode 进而创建新的 task\n1 2 3 4 5 6 7 8 if let Some(inode) = open_file(path.as_str(), OpenFlags::RDONLY) { let data = inode.read_all(); let task = current_task().unwrap(); let new_task = task.spawn(data.as_slice()); let pid = new_task.pid.0; add_task(new_task); pid as isize } 1. fstat 因为觉得 fstat 是最好做的所以从它最开始了\n获取 fstat 的核心是（ino**,** mode**,** nlink）三个数据，代表inode id，文件的模式（是文件还是目录），有几个引用，这部分实现在Inode 结构中，我们给 File trait 添加一个特征方法叫 fstat()，能够返回三个维度的数据\n注意 Stdin 和 Stdout 也是特殊的文件，但是懒得实现就直接在里面 panic 了。\n1 2 3 4 impl File { // ... read, write, readable, writable fn fstat(\u0026amp;self) -\u0026gt; (u64, StatMode, u32); } fstat 里最难的是得到 inode id，因为 Inode 中只提供了 get_inode_id_by_name，我们将该能力分配给 fs，由efs来帮忙实现从块信息中读取 inode 的id\n1 2 // impl Inode ==\u0026gt; get_inode_id fs.get_inode_id(self.block_id, self.block_offset) 1 2 3 4 5 6 7 8 9 10 impl EasyFileSystem { pub fn get_inode_id(\u0026amp;self, block_id: usize, block_offset: usize) -\u0026gt; usize { let inode_size = core::mem::size_of::\u0026lt;DiskInode\u0026gt;(); let inodes_per_block = (BLOCK_SZ / inode_size) as usize; // 目标 inode 处在 inode 区第n个 let nth_inode_block = block_id - self.inode_area_start_block as usize; // 目标 inode 所在区前有几个 inode， + 区里排第几个 inode return nth_inode_block * inodes_per_block + block_offset / inode_size; } } 2. linkat linkat 的功能实现在 Inode 里，代码需要模仿 Inode 中的 create 方法，实际上新建文件的过程也是创建一个硬连接\n具体思路就是：\n新旧文件名的校验 在 get_block_cache 里，通过从 fs 得到的 block 位置信息，新建一个文件 更新目录表，插入一个新的DirEntry 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 /// like `fn create` pub fn linkat(\u0026amp;self, old_name: \u0026amp;str, new_name: \u0026amp;str) -\u0026gt; isize { let mut fs = self.fs.lock(); let old_inode_id = self.read_disk_inode(|disk_inode| self.find_inode_id(old_name, disk_inode) ); // old_name should point to a valid file if old_inode_id == None { return -1; } // new_name should not point to an existing file if self.read_disk_inode(|disk_inode| self.find_inode_id(new_name, disk_inode)).is_some() { return -1; } let (block_id, block_offset) = fs.get_disk_inode_pos(old_inode_id.unwrap()); get_block_cache(block_id as usize, Arc::clone(\u0026amp;self.block_device)) .lock() .modify(block_offset, |new_inode: \u0026amp;mut DiskInode| { new_inode.initialize(DiskInodeType::File) }); // update dir table self.modify_disk_inode(|root_inode| { // add a new dir entry let file_count = (root_inode.size as usize) / DIRENT_SZ; let new_size = (file_count + 1) * DIRENT_SZ; self.increase_size(new_size as u32, root_inode, \u0026amp;mut fs); // write into the new dir entry let dirent = DirEntry::new(new_name, old_inode_id.unwrap()); root_inode.write_at(file_count * DIRENT_SZ, dirent.as_bytes(), \u0026amp;self.block_device); }); 0 } 3. unlinkat unlink 跟 link 还是比较像，思路是遍历根目录（使用modify_disk_inode），在 file_num 个文件里找到符合条件的文件，删除其目录项（将其赋为 DirEntry::empty()）。\n能这么写是因为 rCore 里的文件系统只有一层，根目录下全是文件\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 /// unlink pub fn unlink(\u0026amp;self, name: \u0026amp;str) -\u0026gt; isize { self.modify_disk_inode(|root_inode| { let file_num = (root_inode.size as usize) / DIRENT_SZ; // find the correct entry and modify it, else -1 for i in 0..file_num { let mut dirent = DirEntry::empty(); let readn = root_inode.read_at( i * DIRENT_SZ, dirent.as_bytes_mut(), \u0026amp;self.block_device ); // read size should == DIRENT_SZ if readn != DIRENT_SZ { continue; } if dirent.name() == name { let dirent = DirEntry::empty(); root_inode.write_at(i * DIRENT_SZ, dirent.as_bytes(), \u0026amp;self.block_device); return 0; } } -1 }) } 杂项 简答题 在我们的easy-fs中，root inode起着什么作用？如果root inode中的内容损坏了，会发生什么？ Answer: ROOT_INODE 代表根目录所对应的 Inode，也是整个文件系统（文件树）的起点，我们管理其他的文件都是在根目录下玩完成的，如果它坏了，那么整个文件系统就无法正常管理文件\n文件系统笔记 一个磁盘文件系统的组织结构 这一章的 MVP slide 我觉得是下图，一个 fs 分成了下面五块\nSuper Block：记录了后边几个分别占了多少块（磁盘的单位使用块来表示，类似内存的页帧） Inode Bitmap：记录 Inodes 块的使用情况，一个位可以表示一个 Inode 的使用与否，在分配 Inode 时起到重要作用 Data Bitmap：跟上一块差不多，记录的是数据块的使用情况 Inodes：是DiskInode（存储于磁盘上的文件管理单元）在内存里的形态，一个Inode代表管理了一个文件，通过访问 Inode 可以访问到数据，而其实这些数据就缓存在 Data Blocks 里，但是上层的抽象不需要感知到 DataBlock Data Blocks：真实的数据，通过 Inode 能够找到 下图则代表了目录项，就是上图的右上表，实现从文件名到文件Inode的映射（当然如果是目录，则映射到其下的一堆目录项）\n感想 文件系统对我来说过于陌生，所以在这花了非常多的时间，整整一周，到现在也不是彻底理解了这套系统，多亏了助教xushanpu 的笔记，用自上而下的视角去理解代码结构感觉比 camp 文档里的更好理解。\n对文件系统的理解主要就是第一张图那个视图\n左上是用户视角，文件系统就是一棵文件树\n右上是 OS 视角，一个文件是一个 Inode，中间是文件名到 Inode idx 的映射\n下面的结构是磁盘视角，一个fs分区就是这样的结构\n如果我们把一个磁盘分区，那么每个分区都是独立的 fs，因此都会有平行的那个结构 ","date":"2022-07-30T00:29:54+08:00","permalink":"/p/rcore-camp-2022-lab4-%E8%AE%B0%E5%BD%95/","title":"rCore Camp 2022 Lab4 记录"},{"content":"rCoreCamp2022-lab3记录 Lab3 本体 lab 地址\n0. 迁移通过以前的测试 get_time： 原本我给 TCB 加了一个 inner，这部分在第五章里官方加了这个结构，因此需要把 syscall_times 和 start_time 给迁移进去 get_task_info： 和 get_time 同理，不过需要注意的是代码更改了逻辑，原本由 TASK_MANAGER 负责管理的任务调度和任务执行部分，分成了 manager 和 processor 的工作，前者负责管理任务调度，后者负责操控当前任务 + 当前任务的切换，这二者都迁移进了 Processor 里 mmap \u0026amp; munmap：没什么变化，就是直接搬运 1. 实现 spawn 1 fn sys_spawn(path: *const u8) -\u0026gt; isize 平时我们会使用 fork() + exec() 来实现创建一个新的进程，但为什么要先复制状态机再重置状态机（状态机的理论见绿导师的南大 OS 课）？当然可以直接创建一个新的状态！\nman page 提供了 spawn 相关的说明\n实现不太难，就是在 fork 和 exec 上偷偷而已，\u0008具体代码就不放了\n1 2 3 4 5 6 7 8 9 impl TaskControlBlock { /// Spawn a new process without fork + exec pub fn spawn(self: \u0026amp;Arc\u0026lt;TaskControlBlock\u0026gt;, elf_data: \u0026amp;[u8]) -\u0026gt; Arc\u0026lt;TaskControlBlock\u0026gt; { // 1. 解析 elf 文件，得到 memory_set, user_sp, entry_point, 从 memory_set 里算出物理 trap_cx_ppn // 2. 新建 TCB，数据是新的（类似 exec 里的逻辑） // 3. 将新的 TCB 挂到当前 TCB 的 children 里 // 4. 修改新的 TCB 的 trap_cx 的值 } } 2. 实现 stride stride 意思是步伐，计算方式是 stride = BIG_STRIDE / priority，每次执行一个任务要 pass += stride，然后在调度时选择 pass 最小的执行。因为 priority 当了分母，所以越高的优先级的 stride 越小，每次就越早被调度。\n比如 priority = 5 的进程和 priority = 10 的进程，每次优先级为5的增加的 stride 是 10 的两倍，所以在相同时间里，次数大约会是优先级 10 的一半。\n下面的实现参考了助教 xushanpu123 的笔记， 维护一个 pass 单调递增的队列，每次从头取就行了。\n另外一种做法是队列不一定单调，但是每次取时靠遍历来找最小值\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 impl TaskManager { pub fn add(\u0026amp;mut self, task: Arc\u0026lt;TaskControlBlock\u0026gt;) { // insert the new task into a proper position let inner = task.inner_exclusive_access(); let pass = inner.pass; // let prio = inner.priority; // drop the ownership of inner drop(inner); let len = self.ready_queue.len(); for idx in 0..len { let queue_task = self.ready_queue.get_mut(idx).unwrap(); let pass1 = queue_task.inner_exclusive_access().pass; // keep the queue head owns the smallest pass if pass \u0026lt; pass1 { // println!(\u0026#34;new task priority: {}, pass: {}, inserted before idx {}\u0026#34;, prio, pass, idx); self.ready_queue.insert(idx, task); return } } self.ready_queue.push_back(task); } } 踩坑 会有 already borrowed: BorrowMutError 的 panic 报错，是在测试结束后调用最后一个 exit 时发生的\n定位：在函数前面加 #[trace_caller] 就能显示文件+行数 原因：在测试的时候，initproc 会被替换成各章的 ch_usertest ,所以是不会像普通的运行那样进入 initproc 然后运行 shell 的， usertest 退出的时候所有权会被借走，但是后面又借回来了导致错误（其实就是在 exit_current_and_run_next_task 里，将要退出的和下一个任务是同一个，而我们需要同时可变借用这两个） 解决方案：在拿到 current 后判断 pid，如果是 0（表示初进程）就调用 sbi 里的 shutdown() 直接关机 stride test 过不了，调度不符合公平性\n没找到原因，调度的过程应该是没错的，打印出来的统计数据没有错 解决：给 ci-user 里的 ch5_stridex 加了println!，使得执行速度大幅降低，然后居然就正常了… 2022.07.26更新：\n已经找到原因，是分时程序切换那里做的设置定时时钟中断出问题了，是sbi的故障，夏令营仓库在commit 70ae28ab2280f3e57d14b7a631e7508fe5b4bbaf 后就修复了，在sbi.rs中调用 ecall 前执行 \u0026ldquo;li x16, 0\u0026rdquo;\n杂项 问答题 stride 算法深入\nstride 算法原理非常简单，但是有一个比较大的问题。例如两个 stride = 10 的进程，使用 8bit 无符号整形储存 pass， p1.pass = 255, p2.pass = 250，在 p2 执行一个时间片后，理论上下一次应该 p1 执行。\n实际情况是轮到 p1 执行吗？为什么？ Answer: 并不，因为整型溢出了导致p2.pass更小\n我们之前要求进程优先级 \u0026gt;= 2 其实就是为了解决这个问题。可以证明， 在不考虑溢出的情况下 , 在进程优先级全部 \u0026gt;= 2 的情况下，如果严格按照算法执行，那么 PASS_MAX – PASS_MIN \u0026lt;= BigStride / 2。\n为什么？尝试简单说明（不要求严格证明）。 Answer: （没搞懂）\n已知以上结论， 考虑溢出的情况下 ，可以为 pass 设计特别的比较器，让 BinaryHeap 的 pop 方法能返回真正最小的 Pass。补全下列代码中的 partial_cmp 函数，假设两个 Pass 永远不会相等。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 use core::cmp::Ordering; struct Pass(u64); impl PartialOrdforPass{ fn partial_cmp(\u0026amp;self, other: \u0026amp;Self)-\u0026gt; Option\u0026lt;Ordering\u0026gt;{ // 口胡的代码 } } impl PartialEqforPass{ fn eq(\u0026amp;self, other: \u0026amp;Self)-\u0026gt; bool { false } } TIPS: 使用 8 bits 存储 pass, BigStride = 255, 则: (125 \u0026lt; 255) == false, (129 \u0026lt; 255) == true 第五章-进程管理笔记 [WIP]\n感想 感觉这章的 lab 任务不太难，spawn 其实就是把 fork 和 exec 缝合一下，不难实现 stride 算法的原理也很简单，但是实现了最基本的公平性调度，对我来说感觉还是挺新奇的 因为 sbi 的 bug 而导致卡了几天，很难受，幸好微信群有人解答，再次感受到了\u0008有人陪你一起写 lab 的重要性，一个人捣鼓的话遇到这种情况很可能要放弃了。感谢群友 ","date":"2022-07-23T00:29:54+08:00","permalink":"/p/rcore-camp-2022-lab3-%E8%AE%B0%E5%BD%95/","title":"rCore Camp 2022 Lab3 记录"},{"content":"rCoreCamp2022-lab2记录 Lab2 本体 lab地址\n1. 重写 sys_get_time 之前 sys_get_time 失效的原因是现在增加了虚拟内存的设定，而获取时间靠的是参数传入指针来赋值，这样 ts 不是真正的物理地址，因此会失效，因此需要新作的工作就是进行地址转换。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 // YOUR JOB: 引入虚地址后重写 sys_get_time // 核心代码 pub fn sys_get_time(ts: *mut TimeVal, _tz: usize) -\u0026gt; isize { let virt_addr = VirtAddr(ts as usize); if let Some(phys_addr) = virt2phys_addr(virt_addr) { let us = get_time_us(); let kernel_ts = phys_addr.0 as *mut TimeVal; unsafe { *kernel_ts = TimeVal { sec: us / 1_000_000, usec: us % 1_000_000, }; } 0 } else { -1 } } 地址转换就是查表而已。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 // 虚拟地址转换成物理地址 fn virt2phys_addr(virt_addr: VirtAddr) -\u0026gt; Option\u0026lt;PhysAddr\u0026gt; { let offset = virt_addr.page_offset(); let vpn = virt_addr.floor(); let ppn = PageTable::from_token(current_user_token()) .translate(vpn) .map(|entry| entry.ppn()); if let Some(ppn) = ppn { Some(PhysAddr::combine(ppn, offset)) } else { println!(\u0026#34;virt2phys_addr() fail\u0026#34;); None } } 2. 重写 sys_task_info 这个跟 1 几乎一模一样，额外工作只有添加地址转换\n1 2 3 4 5 6 7 8 9 // YOUR JOB: 引入虚地址后重写 sys_task_info pub fn sys_task_info(ti: *mut TaskInfo) -\u0026gt; isize { if let Some(phys_addr) = virt2phys_addr(VirtAddr(ti as usize)) { get_task_info(phys_addr.0 as *mut TaskInfo); 0 } else { -1 } } 花了两天解决了一个坑， TaskStatus::Running 在 ci 的时候变成了 TaskStatus::Ready ，github 上有一个 pr 解决了这个问题，是因为 ci 里的枚举值多了个 UnInit 值，导致解析错误（从整数解析成枚举）\n3. 实现 mmap 1 fn sys_mmap(start: usize, len: usize, port: usize) -\u0026gt; isize 一开始直接使用 frame_allocate() 去分配物理页，但是后面一直过不了，瞄了一下别人的代码，发现根本就设计错了，在抽象层面上，代码框架已经实现了 MemorySet，负责管理一个应用所获得的所有内存，因此我们要做的是往 MemorySet 里新加一个 MapArea，表示一段连续的内存。\n中间的校验、转换都不太难，要获取到当前任务的 memory_set，然后再往应用插页。\n核心方法集成在 TASK_MANAGER 中，通过 insert_framed_area 来插入页面。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 fn task_map(\u0026amp;self, start: usize, len: usize, port: usize) -\u0026gt; isize { if start \u0026amp; (PAGE_SIZE - 1) != 0 { println!( \u0026#34;expect the start address to be aligned with a page, but get an invalid start: {:#x}\u0026#34;, start ); return -1; } // port最低三位[x w r]，其他位必须为0 if port \u0026gt; 7usize || port == 0 { println!(\u0026#34;invalid port: {:#b}\u0026#34;, port); return -1; } let mut inner = self.inner.exclusive_access(); let task_id = inner.current_task; let current_task = \u0026amp;mut inner.tasks[task_id]; let memory_set = \u0026amp;mut current_task.memory_set; // check valid let start_vpn = VirtPageNum::from(VirtAddr(start)); let end_vpn = VirtPageNum::from(VirtAddr(start + len).ceil()); for vpn in start_vpn.0 .. end_vpn.0 { if let Some(pte) = memory_set.translate(VirtPageNum(vpn)) { if pte.is_valid() { println!(\u0026#34;vpn {} has been occupied!\u0026#34;, vpn); return -1; } } } // PTE_U 的语义是【用户能否访问该物理帧】 let permission = MapPermission::from_bits((port as u8) \u0026lt;\u0026lt; 1).unwrap() | MapPermission::U; memory_set.insert_framed_area(VirtAddr(start), VirtAddr(start+len), permission); 0 } 4. 实现 munmap 1 fn sys_munmap(start: usize, len: usize) -\u0026gt; isize 跟 3 差不多，注意要 unmap 的条件是页必须在使用，因此如果 pte 是不可用的，应该报错\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 fn task_munmap(\u0026amp;self, start: usize, len: usize) -\u0026gt; isize { if start \u0026amp; (PAGE_SIZE - 1) != 0 { println!( \u0026#34;expect the start address to be aligned with a page, but get an invalid start: {:#x}\u0026#34;, start ); return -1; } let mut inner = self.inner.exclusive_access(); let task_id = inner.current_task; let current_task = \u0026amp;mut inner.tasks[task_id]; let memory_set = \u0026amp;mut current_task.memory_set; // check valid let start_vpn = VirtPageNum::from(VirtAddr(start)); let end_vpn = VirtPageNum::from(VirtAddr(start + len).ceil()); for vpn in start_vpn.0 .. end_vpn.0 { if let Some(pte) = memory_set.translate(VirtPageNum(vpn)) { if !pte.is_valid() { println!(\u0026#34;vpn {} is not valid before unmap\u0026#34;, vpn); return -1; } } } let vpn_range = VPNRange::new(start_vpn, end_vpn); memory_set.munmap(vpn_range); 0 } 杂项 问答题 [WIP]\n缺页缺页指的是进程访问页面时页面不在页表中或在页表中无效的现象，此时 MMU 将会返回一个中断， 告知 os 进程内存访问出了问题。os 选择填补页表并重新执行异常指令或者杀死进程。\n请问哪些异常可能是缺页导致的？ 发生缺页时，描述相关重要寄存器的值，上次实验描述过的可以简略。 缺页有两个常见的原因，其一是 Lazy 策略，也就是直到内存页面被访问才实际进行页表操作。 比如，一个程序被执行时，进程的代码段理论上需要从磁盘加载到内存。但是 os 并不会马上这样做， 而是会保存 .text 段在磁盘的位置信息，在这些代码第一次被执行时才完成从磁盘的加载操作。\n这样做有哪些好处？ 其实，我们的 mmap 也可以采取 Lazy 策略，比如：一个用户进程先后申请了 10G 的内存空间， 然后用了其中 1M 就直接退出了。按照现在的做法，我们显然亏大了，进行了很多没有意义的页表操作。\n处理 10G 连续的内存页面，对应的 SV39 页表大致占用多少内存 (估算数量级即可)？ 请简单思考如何才能实现 Lazy 策略，缺页时又如何处理？描述合理即可，不需要考虑实现。 缺页的另一个常见原因是 swap 策略，也就是内存页面可能被换到磁盘上了，导致对应页面失效。\n此时页面失效如何表现在页表项(PTE)上？ 双页表与单页表\n为了防范侧信道攻击，我们的 os 使用了双页表。但是传统的设计一直是单页表的，也就是说， 用户线程和对应的内核线程共用同一张页表，只不过内核对应的地址只允许在内核态访问。 (备注：这里的单/双的说法仅为自创的通俗说法，并无这个名词概念，详情见 KPTI )\n在单页表情况下，如何更换页表？ 单页表情况下，如何控制用户态无法访问内核页面？（tips:看看上一题最后一问） 单页表有何优势？（回答合理即可） 双页表实现下，何时需要更换页表？假设你写一个单页表操作系统，你会选择何时更换页表（回答合理即可）？ 第四章-地址空间笔记 SV39 多级页表 下图是我觉得最能讲清 SV39 多级页表机制的，对我的理解有很大帮助\u0008，来自 2022春OS slides- lec5\n一个页表有512项，一项的size为usize，在RV64中就是8字节，因此一个页表刚好占一个物理页帧（4K），因此要找到某一个页表，只需要知道其PPN（offset为0即可）\n蓝色框框代表一个虚拟地址的组成，其中只有低12+9+9+9位排上了用场，高位都是没用的\n其中三个9位的分别对应该地址分别在三级页表中的偏移，而前一级页表项中就存着当前这个页表的物理地址 一个页表项的组成：\n左边保留无用 接着是PPN 还有2位的保留 最后是flags，标志着下一级的各种信息 问答作业 请列举 SV39 页表页表项的组成，描述其中的标志位有何作用\n我认为这张图很好地表达了 SV39 多级页表的结构，虚拟地址分成 EXT（没用），在三级页表中的偏移（or 索引），以及偏移地址。\n第一级页表的基址存在 satp 寄存器里，在切换任务的时候会切换 satp，实现了不同应用的地址隔离，因为不会访问到同一个页表。\n前两级页表分为 PPN 和 FLags 两部分，前者代表下一\u0008页表的基址（一个页表有 512 个 PTE ，\u0008一个 PTE 的长度为 usize，在 RV64 下为 64bit，因此一个页表刚好占一个物理页，4K ）。\n最终由三级页表的 PPN 跟 VA 的 Offset 组合成了物理地址。\n标志位如上图，言简意赅，需要注意的是 [10: 8] 被 RSW 占据，保留用而已，没有其他作用。\n缺页\n缺页指的是进程访问页面时页面不在页表中或在页表中无效的现象，此时 MMU 将会返回一个中断， 告知 os 进程内存访问出了问题。os 选择填补页表并重新执行异常指令或者杀死进程。\n请问哪些异常可能是缺页导致的？ 发生缺页时，描述相关重要寄存器的值，上次实验描述过的可以简略。 缺页有两个常见的原因，其一是 Lazy 策略，也就是直到内存页面被访问才实际进行页表操作。 比如，一个程序被执行时，进程的代码段理论上需要从磁盘加载到内存。但是 os 并不会马上这样做， 而是会保存 .text 段在磁盘的位置信息，在这些代码第一次被执行时才完成从磁盘的加载操作。\n这样做有哪些好处？ 其实，我们的 mmap 也可以采取 Lazy 策略，比如：一个用户进程先后申请了 10G 的内存空间， 然后用了其中 1M 就直接退出了。按照现在的做法，我们显然亏大了，进行了很多没有意义的页表操作。\n处理 10G 连续的内存页面，对应的 SV39 页表大致占用多少内存 (估算数量级即可)？ 请简单思考如何才能实现 Lazy 策略，缺页时又如何处理？描述合理即可，不需要考虑实现。 缺页的另一个常见原因是 swap 策略，也就是内存页面可能被换到磁盘上了，导致对应页面失效。\n此时页面失效如何表现在页表项(PTE)上？ 双页表与单页表\n为了防范侧信道攻击，我们的 os 使用了双页表。但是传统的设计一直是单页表的，也就是说， 用户线程和对应的内核线程共用同一张页表，只不过内核对应的地址只允许在内核态访问。 (备注：这里的单/双的说法仅为自创的通俗说法，并无这个名词概念，详情见 KPTI )\n在单页表情况下，如何更换页表？ 单页表情况下，如何控制用户态无法访问内核页面？（tips:看看上一题最后一问） 单页表有何优势？（回答合理即可） 双页表实现下，何时需要更换页表？假设你写一个单页表操作系统，你会选择何时更换页表（回答合理即可）？ ","date":"2022-07-18T00:29:54+08:00","permalink":"/p/rcore-camp-2022-lab2-%E8%AE%B0%E5%BD%95/","title":"rCore Camp 2022 Lab2 记录"},{"content":"rCoreCamp2022-lab1记录 Lab1本体 lab地址\n实现以下函数的功能\n1 2 3 4 5 6 fn sys_task_info(ti: *mut TaskInfo) -\u0026gt; isize struct TaskInfo { status: TaskStatus, syscall_times: [u32; MAX_SYSCALL_NUM], time: usize } 分解需求 让 TASK_MANAGER 有获取 task 状态的能力 让 TASK_MANAGER 有更新 task 状态的能力 实现 其实就是对 TASK_MANAGER 管理的每个 task 维护一个 TaskInfo 的对象，每次 syscall 的时候进行记录。\n因此我们给 Task 的对象加入一个新的 inner 字段，维护该任务开始时间和系统调用情况。\n之后给 TASK_MANAGER 加 set 和 get 的能力，都挺好懂的\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 // src/task/mod.rs fn set_syscall_times(\u0026amp;self, syscall_id: usize) { let mut inner = self.inner.exclusive_access(); let current_id = inner.current_task; inner.tasks[current_id].task_info_inner.syscall_times[syscall_id] += 1; } fn get_current_task_info(\u0026amp;self, ti: *mut TaskInfo) { let inner = self.inner.exclusive_access(); let current_id = inner.current_task; let TaskInfoInner {syscall_times, start_time} = inner.tasks[current_id].task_info_inner; unsafe { *ti = TaskInfo { status: TaskStatus::Running, syscall_times, time: get_time_ms() - start_time, }; } } 然后对外提供接口\n1 2 3 4 5 6 7 pub fn record_syscall(syscall_id: usize) { TASK_MANAGER.set_syscall_times(syscall_id); } pub fn get_task_info(ti: *mut TaskInfo) { TASK_MANAGER.get_current_task_info(ti); } 每次调用syscall的时候记录一下就行了。\n简答作业 正确进入 U 态后，程序的特征还应有：使用 S 态特权指令，访问 S 态寄存器后会报错。 请同学们可以自行测试这些内容 (运行 Rust 三个 bad 测例 (ch2b_bad_*.rs) ， 注意在编译时至少需要指定 LOG=ERROR 才能观察到内核的报错信息) ， 描述程序出错行为，同时注意注明你使用的 sbi 及其版本。\n深入理解 trap.S 中两个函数 __alltraps和__restore的作用，并回答如下问题:\nL40：刚进入 __restore 时，a0 代表了什么值。请指出 __restore 的两种使用情景。\n在L37有一行mv a0, sp的指令，这是addi a0, sp, 0的语法糖，其实就是mov，在__alltraps里是给参数赋值，但是在之后a0并没有再次出现过，结合trap_handler的参数和返回值，可以认为又被返回回去了，所以a0直到__restore时都是taskContext。\n__restore封装在goto_restore里，我们ctrl f全局找一下可以看到唯一引用的地方：TASK_MANAGER的初始化\n这个地方把每个应用的上下文（包括32个寄存器、sepc、sstatus值）存起来返回然后从supervisor返回到user\n其实所有从 supervisor =\u0026gt; user 都可以使用__restore，跟__alltraps是反过来的，对偶使用，另一种场景想不出来……。\nL46-L51：这几行汇编代码特殊处理了哪些寄存器？这些寄存器的的值对于进入用户态有何意义？请分别解释。\n1 2 3 4 5 6 ld t0, 32*8(sp) ld t1, 33*8(sp) ld t2, 2*8(sp) csrw sstatus, t0 csrw sepc, t1 csrw sscratch, t2 t0给了 sstatus，是 trap 发生前 cpu 特权级的信息（如S/U）\nt1给了 sepc，是 trap 发生前执行的最后一条指令的地址\nt2给了 sscratch，是原来 user stack 的 sp\n这仨都是用来恢复状态的（在进入supervisor的时候把原来信息存在这里面了）\nL53-L59：为何跳过了 x2 和 x4？\n问题2和3都在特权级交换这章里讲了，x2是 sp(stack pointer) ，x4 是 tp(thread pointer)\n跳过x2：用户栈的栈指针保存在 sscratch 中，必须通过 \u0026lt;span class=\u0026quot;pre\u0026quot;\u0026gt;csrr\u0026lt;/span\u0026gt; 指令读到通用寄存器中后才能使用，因此我们先考虑保存其它通用寄存器，腾出空间。\n跳过x4：非特殊情况不需要用到x4（存疑？）\nL63：该指令之后 sp 和 sscratch 中的值分别有什么意义？\n1 csrrw sp, sscratch, sp csrrw r1, r2, r3的意思是把 r2 写进 r1 ，把 r3 写进 r2 ，在上面就是交换 sp 和 sscratch 的意思。\nsp 原来是用户栈，sscratch 原来是内核栈，交换后 sp 指向 kernel stack， sscratch 指向 user stack\n__restore: 中发生状态切换在哪一条指令？为何该指令执行之后会进入用户态？\n我猜是csrw sstatus, t0，sstatus代表用户状态\nL13：该指令之后，sp 和 sscratch 中的值分别有什么意义？\n同4，反过来（怀疑上面L63是笔误\n从 U 态进入 S 态是哪一条指令发生的？\n看不出来……因为现场没有改变 sstatus 的。\n","date":"2022-07-14T01:20:44+08:00","permalink":"/p/rcore-camp-2022-lab1-%E8%AE%B0%E5%BD%95/","title":"rCore Camp 2022 Lab1 记录"},{"content":"chap 1. 计算机抽象及相关技术 八个伟大思想： 面向摩尔定律的设计\n设计芯片的时候要考虑未来工艺，需要超前点 使用抽象简化设计 加速经常性事件 通过并行提高性能 通过流水线提高性能 通过预测提高性能 存储层次\nMemory Hierarchy 通过冗余提高可靠性 chap2 指令 RV字段 R型（用于寄存器） funct7 rs2 rs1 funct3 rd opcode 总共 7位 5位 5位 3位 5位 7位 32位 opcode：指令基本操作 rd：目的操作数寄存器，存放结果 funct3：一个另外的操作码字段 rs1：第一个源操作数寄存器 rs2：第二个源操作数寄存器 funct7：一个另外的操作码字段 funct3和funct7用来表示opcode的附加字段（比如add和sub的opcode都是0110011，而add的funct7是0000000，sub的是0100000\nI型（用于带常数的算数指令和加载指令） immediate rs1 funct3 rd opcode 总共 7位 5位 3位 5位 7位 32位 immediate为补码，可以表示-2^11^ 到2^11^ - 1之间的整数，当I型格式用于加载指令时，immediate表示一个偏移量 ld指令的funct3为3 S型（用于Store） immediate[11:5] rs2 rs1 funct3 immediate[4:0] opcode 总共 7位 5位 5位 3位 5位 7位 32位 immediate设计成两个字段是因为想把rs2和rs1跟上面的处于同一位置，降低硬件复杂性，funct3和opcode也是同一位置 逻辑操作 RV里没有!的逻辑操作，可以使用xxx XOR 全FF实现\n移位操作是I型格式，因为只用到immediate的低6位字母（不能移超过63次），所以高6位被当做另外的操作码字段，即funct6\n调用约定 x10~x17：八个，用于传参/返回值\nx0：一定是常量0，如果试图更改会被直接丢弃\nx1：返回地址寄存器，用于返回到起始点\n跳转-链接指令（jal）：跳转到某个地址的同时将下一条指令的地址保存到目标寄存器rd\njal x1, ProcedureAddress：跳转到ProcedureAddress并把返回地址写入x1 RV中x2是栈指针（stack pointer/ sp）\nRV把19个寄存器分成两组：\nx5~x7以及x28~x31：临时寄存器，过程调用里不被【被调用者（callee）】保存 x8~x9以及x18~x27：保存寄存器，在过程调用里必须被保存 RV使用帧指针（frame pointer）来表示过程帧的第一个双字（类似x64的rbp）\n超过8个参数怎么办？跟x86的处理方式一样，额外的放stack上\n大立即数处理 lui指令（load upper immediate） 取立即数高位，将20位常数加载到寄存器的31到12位，并把31位复制填充到最左边32位，最右边12位用0填充。\n这条指令允许使用两条指令创建32位常量。lui的指令格式为U型，因为其他的不支持大常量。\n加载一个大常量的过程如lui x19, 12到31位的数; addi x19, x19, 低12位的数\n分支寻址 分支指令使用SB型指令，可以表示-4096到4094的分支地址，以2的倍数表示。\nSB型 比如bne x10, x11, 2000 // if x10 != x11, goto location 2000\n表示为\nimm[12] imm[10:5] rs2 rs1 funct3 imm[4:1] imm[11] opcode 0 111110 01011 01010 001 1000 0 1100111 opcode=1100111是条件分支的操作码，bne的funct3是001\n唯一使用UJ型的jal指令（无条件跳转-链接） 比如jal x0, 2000 // goto location 2000 = 0111 1101 0000\nimm[20] imm[10:1] imm[11] imm[19:12] rd opcode 0 11 1110 1000 0 0000 0000 0 0000 110 1111 但是20位的地址空间太小了，另一种方法使用寄存器+偏移的方式，能够扩大到2^64^\n使用哪个寄存器？\nSPEC基准测试里有一半的条件分支跳到小于16距离的位置\n因此如果用PC来当基址，那就很理想，这种叫PC相对寻址，RV对条件分支和无条件跳转使用PC相对寻址。在RV里PC相对偏倚表示分支和目标指令之间的半字数（2 bytes），jal里20位可以编码PC±2^19^个半字/ ±1MB的距离\n同步 atomic exchange原语 jyy讲过，拿1去对🔐变量不断交换，交换出来0说明拿到锁了，交换出来1说明没拿到（被占用）\n指令对 第二条指令返回一个值，表示该指令对是否被原子执行。\n这对指令指保留加载（load-reserved）双字的特殊加载指令（称为lr.d）和一个条件存储（sotre-conditional）双字的特殊存储指令（称为sc.d），如果加载的内容跟存储前探测到的内容不同，条件存储就会失败，不会写入内存。成功就会把另一个寄存器的值更改为0，如果失败就改成非0。\nsc.d指定了三个寄存器：保存地址、指示原子操作失败成功、如果成功就把指写入内存。\n上面的过程实现了在x20指定的内存上的原子交换，即atomic_exchange(x23, mem[x20]\n链接 三个工作步骤：\n将代码和数据模块按符号特征放入内存 决定数据和指令标签的地址 修正内部和外部引用 MIPS vs RISC-V 相同 不同 除了eq、neq外的条件分支。RV只提供分支指令来比较两个寄存器，而MIPS提供比较指令，把比较结果写入一个寄存器（0 or 1） MIPS只执行小于比较，存在有符号和无符号版本（slt和sltu） 完整的MIPS指令系统 \u0026raquo; RSIC-V 总结 讲了指令系统体系结构ISA（Instruction Set Architecture）的历史 RV的指令结构 实现同步 RV与x86、MIPS的比较 ","date":"2022-07-11T01:37:38+08:00","permalink":"/p/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E8%AE%BE%E8%AE%A1-%E8%BD%AF%E4%BB%B6%E7%A1%AC%E4%BB%B6%E6%8E%A5%E5%8F%A3-risc-v%E7%89%88%E7%AC%94%E8%AE%B0/","title":"计算机组成设计-软件硬件接口-RISC-V版笔记"},{"content":"这篇文是2021秋的一次联创web组内分享\nSourceMap是什么 发送到前端的代码往往不是写的时候的样子 为了方便调试，在SourceMap文件中规定了源文件和打包后的文件的映射。 1 2 3 4 5 6 // index.js function foo() { return getNum(); } // 只需要在改造后的代码最后加上这一行注释就会被解析 //# sourceMappingURL=http://example.com/index.map 1 2 3 4 5 // index.ts // ... function foo():number { return getNum(); } 1 2 3 4 5 6 7 8 9 // index.map(其实是一个json文件 // 正儿八经的SourceMap并不这么写 { \u0026#34;sources\u0026#34;: [\u0026#34;path/index.ts\u0026#34;], // 可以有很多个 \u0026#34;mappings\u0026#34;: \u0026#34;index.js第二行第一句映射到index.ts的第三行第一句, index.js第x行第y句映射到index.ts第i行第j句, CAAEA\u0026#34; } MDN的SourceMap使用demo https://mdn.github.io/devtools-examples/sourcemaps-in-console/index.html\nSourceMap的一些feature 只有在DevTools中打开enable source map才有效，因此注释里的链接是可以动态构造的 打开DevTools时才会加载Map 由于可以使用网络来获取SourceMap，因此一定可以发送网络请求(GET) 网络请求不会在DevTools的Network中展示（当然wireshark等是能抓到的） 传输是单向的（即不会解析response） SourceMap的非正经用法 悄悄发送请求 之前说可以动态构造链接，那么只要由脚本控制，可以随时发送get请求出去，而且不会留下明显的痕迹。（可以随时remove\n1 2 3 4 5 6 7 const report = (url, data) =\u0026gt; { const script = document.createElement(\u0026#39;script\u0026#39;); script.textContent = `//# sourceMappingURL=${url}?data=${data}`; document.head.appendChild(script); script.remove(); } report(\u0026#39;/report\u0026#39;, \u0026#39;value\u0026#39;); 监听DevTools的打开事件 之前说没法解析response？如何做到双向沟通？ 有没有办法不用解析response也能将状态保留到本地的方式？ Set-Cookie \u0026amp;\u0026amp; document.cookie (我们认为网站的前端是😈，因此httpOnly的header由😈把控，可以设置为false，这样js就能够获取该cookie） 监听这个能干嘛？ 比如你有怪浪怪浪的😈代码，在调试人员打开devtools的时候就可以删除该部分代码或者修改成人畜无害的👼代码，这样就达到了Anti-debugging的目的。 比如最极端的你可以 document.body.innerHTML = \u0026quot;\u0026quot;;\n鉴于其操作的高灵活性，即使不是做坏事也可以玩出一些花来，可以用于跟用户开玩笑。\n绕过内容安全策略(Content Security Policy) 内容安全策略是浏览器用于保护服务器的一种安全限制，可以由服务端设置安全策略，可以防止许多XSS的注入。\nEg: 服务端返回时带上了以下header，只允许来自向同源域名发送请求（或者说这个页面下的所有资源都应当来自同源域名），不符合要求的请求将会被浏览器拦截 Content-Security-Policy: default-src \u0026lsquo;self\u0026rsquo;\n但是用sourceMappingUrl可以绕过这个限制，就是说我们可以 sourceMappingUrl = http://others.com 而不受影响\nSum up 一个有意思的trick，提供了一种在前端做小动作而不会在DevTools里暴露的方法，比如：\n悄悄地发送一些请求 在有开发人员打开调试界面的时候可以将以前的手脚删除以达到Anti-Debugging的效果，在调试过程中会发现整个代码人畜无害。 用来实现【监听DevTools启动】这样一个浏览器中没有提供的事件。 不过缺点也很明显：\n毕竟报文发送出去了，wireshark/sniffers都是能抓到包的，同时sourcemap相关代码也无法完全隐藏起来，无法完全做到隐身 需要浏览器打开SourceMap功能才能正常工作（不过似乎现在浏览器都默认打开的？未证实 DevTools打开时才能够加载SourceMap，如果是想做监控显然不够全面，因为绝大多数人打开网页后不会去按F12 因此还是作为一个JavaScript Anti-Debugging的一个trick，而不是无敌的存在。 参考资料 主要的内容来源于这一篇blog： https://weizman.github.io/?javascript-anti-debugging-some-next-level-shit-part-1 JavaScript Source Map 详解 - 阮一峰的网络日志 使用 source map - Firefox 开发者工具 | MDN 内容安全策略( CSP ) - HTTP | MDN 微型demo ","date":"2021-10-28T18:40:44+08:00","permalink":"/p/sourcemap%E4%B8%8Ejs%E5%8F%8D%E8%B0%83%E8%AF%95/","title":"SourceMap与JS反调试"}]