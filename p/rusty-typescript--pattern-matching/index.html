<!DOCTYPE html>
<html lang="" dir="ltr">
    <head><meta charset='utf-8'>
<meta name='viewport' content='width=device-width, initial-scale=1'><meta name='description' content='如何用 ts 实现 rust 的 Option、Result、match 特性'>
<title>Rusty Typescript -- Pattern Matching</title>

<link rel='canonical' href='/p/rusty-typescript--pattern-matching/'>

<link rel="stylesheet" href="/scss/style.min.8191399262444ab68b72a18c97392f5349be20a1615d77445be51e974c144cff.css"><meta property='og:title' content='Rusty Typescript -- Pattern Matching'>
<meta property='og:description' content='如何用 ts 实现 rust 的 Option、Result、match 特性'>
<meta property='og:url' content='/p/rusty-typescript--pattern-matching/'>
<meta property='og:site_name' content='秘密'>
<meta property='og:type' content='article'><meta property='article:section' content='Post' /><meta property='article:tag' content='TypeScript' /><meta property='article:tag' content='Rust' /><meta property='article:published_time' content='2022-09-12T18:02:35&#43;08:00'/><meta property='article:modified_time' content='2022-09-12T18:02:35&#43;08:00'/>
<meta name="twitter:title" content="Rusty Typescript -- Pattern Matching">
<meta name="twitter:description" content="如何用 ts 实现 rust 的 Option、Result、match 特性">
    <link rel="shortcut icon" href="https://s3.bmp.ovh/imgs/2022/05/28/7745084c66c1e1de.png" />

    </head>
    <body class="
    article-page
    ">
    <script>
        (function() {
            const colorSchemeKey = 'StackColorScheme';
            if(!localStorage.getItem(colorSchemeKey)){
                localStorage.setItem(colorSchemeKey, "auto");
            }
        })();
    </script><script>
    (function() {
        const colorSchemeKey = 'StackColorScheme';
        const colorSchemeItem = localStorage.getItem(colorSchemeKey);
        const supportDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches === true;

        if (colorSchemeItem == 'dark' || colorSchemeItem === 'auto' && supportDarkMode) {
            

            document.documentElement.dataset.scheme = 'dark';
        } else {
            document.documentElement.dataset.scheme = 'light';
        }
    })();
</script>
<div class="container main-container flex on-phone--column extended"><aside class="sidebar left-sidebar sticky ">
    <button class="hamburger hamburger--spin" type="button" id="toggle-menu" aria-label="切换菜单">
        <span class="hamburger-box">
            <span class="hamburger-inner"></span>
        </span>
    </button>

    <header>
        
            
            <figure class="site-avatar">
                <a href="/">
                
                    <img src="https://s3.bmp.ovh/imgs/2022/05/28/7745084c66c1e1de.png" width="300" height="300" class="site-logo" loading="lazy" alt="Avatar">
                
                </a>
                
                    <span class="emoji">🐅</span>
                
            </figure>
            
        
        
        <div class="site-meta">
            <h1 class="site-name"><a href="/">秘密</a></h1>
            <h2 class="site-description">Web Developer</h2>
        </div>
    </header><ol class="social-menu">
            
                <li>
                    <a 
                        href='https://github.com/werifu'
                        target="_blank"
                        title="GitHub"
                        rel="me"
                    >
                        
                        
                            <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-brand-github" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
  <path d="M9 19c-4.3 1.4 -4.3 -2.5 -6 -3m12 5v-3.5c0 -1 .1 -1.4 -.5 -2c2.8 -.3 5.5 -1.4 5.5 -6a4.6 4.6 0 0 0 -1.3 -3.2a4.2 4.2 0 0 0 -.1 -3.2s-1.1 -.3 -3.5 1.3a12.3 12.3 0 0 0 -6.2 0c-2.4 -1.6 -3.5 -1.3 -3.5 -1.3a4.2 4.2 0 0 0 -.1 3.2a4.6 4.6 0 0 0 -1.3 3.2c0 4.6 2.7 5.7 5.5 6c-.6 .6 -.6 1.2 -.5 2v3.5" />
</svg>



                        
                    </a>
                </li>
            
                <li>
                    <a 
                        href='mailto:wohu1363195380@outlook.com'
                        target="_blank"
                        title="Mail"
                        rel="me"
                    >
                        
                        
                            <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-mail" width="44" height="44" viewBox="0 0 24 24" stroke-width="1.5" stroke="#2c3e50" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
  <rect x="3" y="5" width="18" height="14" rx="2" />
  <polyline points="3 7 12 13 21 7" />
</svg>
                        
                    </a>
                </li>
            
                <li>
                    <a 
                        href='https://www.pixiv.net/users/12187732'
                        target="_blank"
                        title="Pixiv"
                        rel="me"
                    >
                        
                        
                            <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-letter-p" width="44" height="44" viewBox="0 0 24 24" stroke-width="1.5" stroke="#ff2825" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
  <path d="M7 20v-16h5.5a4 4 0 0 1 0 9h-5.5" />
</svg>
                        
                    </a>
                </li>
            
                <li>
                    <a 
                        href='https://twitter.com/werifu_'
                        target="_blank"
                        title="Twitter"
                        rel="me"
                    >
                        
                        
                            <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-brand-twitter" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
  <path d="M22 4.01c-1 .49 -1.98 .689 -3 .99c-1.121 -1.265 -2.783 -1.335 -4.38 -.737s-2.643 2.06 -2.62 3.737v1c-3.245 .083 -6.135 -1.395 -8 -4c0 0 -4.182 7.433 4 11c-1.872 1.247 -3.739 2.088 -6 2c3.308 1.803 6.913 2.423 10.034 1.517c3.58 -1.04 6.522 -3.723 7.651 -7.742a13.84 13.84 0 0 0 .497 -3.753c-.002 -.249 1.51 -2.772 1.818 -4.013z" />
</svg>



                        
                    </a>
                </li>
            
        </ol><ol class="menu" id="main-menu">
        
        
        

        <li >
            <a href='/' >
                
                
                
                    <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-home" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <polyline points="5 12 3 12 12 3 21 12 19 12" />
  <path d="M5 12v7a2 2 0 0 0 2 2h10a2 2 0 0 0 2 -2v-7" />
  <path d="M9 21v-6a2 2 0 0 1 2 -2h2a2 2 0 0 1 2 2v6" />
</svg>



                
                <span>Home</span>
            </a>
        </li>
        
        

        <li >
            <a href='/about/' >
                
                
                
                    <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-user" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <circle cx="12" cy="7" r="4" />
  <path d="M6 21v-2a4 4 0 0 1 4 -4h4a4 4 0 0 1 4 4v2" />
</svg>



                
                <span>About</span>
            </a>
        </li>
        
        

        <li >
            <a href='/archives/' >
                
                
                
                    <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-archive" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <rect x="3" y="4" width="18" height="4" rx="2" />
  <path d="M5 8v10a2 2 0 0 0 2 2h10a2 2 0 0 0 2 -2v-10" />
  <line x1="10" y1="12" x2="14" y2="12" />
</svg>



                
                <span>Archives</span>
            </a>
        </li>
        
        

        <li >
            <a href='/search/' >
                
                
                
                    <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-search" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <circle cx="10" cy="10" r="7" />
  <line x1="21" y1="21" x2="15" y2="15" />
</svg>



                
                <span>Search</span>
            </a>
        </li>
        
        

        <li >
            <a href='/links/' >
                
                
                
                    <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-link" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <path d="M10 14a3.5 3.5 0 0 0 5 0l4 -4a3.5 3.5 0 0 0 -5 -5l-.5 .5" />
  <path d="M14 10a3.5 3.5 0 0 0 -5 0l-4 4a3.5 3.5 0 0 0 5 5l.5 -.5" />
</svg>



                
                <span>Links</span>
            </a>
        </li>
        
        

        <li >
            <a href='/gallery/' >
                
                
                
                    <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-infinity" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <path d="M9.828 9.172a4 4 0 1 0 0 5.656 a10 10 0 0 0 2.172 -2.828a10 10 0 0 1 2.172 -2.828 a4 4 0 1 1 0 5.656a10 10 0 0 1 -2.172 -2.828a10 10 0 0 0 -2.172 -2.828" />
</svg>



                
                <span>Gallery</span>
            </a>
        </li>
        

        <div class="menu-bottom-section">
            
            
                <li id="dark-mode-toggle">
                    <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-toggle-left" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <circle cx="8" cy="12" r="2" />
  <rect x="2" y="6" width="20" height="12" rx="6" />
</svg>



                    <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-toggle-right" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <circle cx="16" cy="12" r="2" />
  <rect x="2" y="6" width="20" height="12" rx="6" />
</svg>



                    <span>暗色模式</span>
                </li>
            
        </div>
    </ol>
</aside>

    

            <main class="main full-width">
    <article class="main-article">
    <header class="article-header">

    <div class="article-details">
    

    <div class="article-title-wrapper">
        <h2 class="article-title">
            <a href="/p/rusty-typescript--pattern-matching/">Rusty Typescript -- Pattern Matching</a>
        </h2>
    
        
        <h3 class="article-subtitle">
            如何用 ts 实现 rust 的 Option、Result、match 特性
        </h3>
        
    </div>

    
    
    
    
    <footer class="article-time">
        
            <div>
                <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-calendar-time" width="56" height="56" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <path d="M11.795 21h-6.795a2 2 0 0 1 -2 -2v-12a2 2 0 0 1 2 -2h12a2 2 0 0 1 2 2v4" />
  <circle cx="18" cy="18" r="4" />
  <path d="M15 3v4" />
  <path d="M7 3v4" />
  <path d="M3 11h16" />
  <path d="M18 16.496v1.504l1 1" />
</svg>
                <time class="article-time--published">Sep 12, 2022</time>
            </div>
        

        
            <div>
                <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-clock" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <circle cx="12" cy="12" r="9" />
  <polyline points="12 7 12 12 15 15" />
</svg>



                <time class="article-time--reading">
                    阅读时长: 17 分钟
                </time>
            </div>
        
    </footer>
    

    
</div>

</header>

    <section class="article-content">
    
    
    <p>本文章内容：使用 TypeScript 实现 Rust 的部分模式匹配特性（match、Option、Result）</p>
<p>标题可以理解为《 Rust 味的 TypeScript 》</p>
<blockquote>
<p>阅读须知：</p>
<ol>
<li>无需 Rust 基础知识，也与 Rust 最难的内存安全模型无关</li>
<li>包含对模式匹配的理解</li>
<li>包含一种实现的开源代码讲解</li>
<li>少量类型体操</li>
</ol>
</blockquote>
<h2 id="模式匹配-pattern-matching">模式匹配 (Pattern Matching)</h2>
<h3 id="是什么">是什么</h3>
<ul>
<li>函数式编程里的概念</li>
</ul>
<blockquote>
<p>模式匹配是检查给定记号序列中，是否存在某种模式的组成部分的行为。——维基</p>
<p>pattern matching is the act of checking a given sequence of tokens for the presence of the constituents of some pattern. —— Wikipedia</p>
</blockquote>
<p>模式可以理解为【规律】。定义听起来很抽象，举一点例子之后是很容易理解这个名字的。</p>
<ul>
<li>switch、RegExp 是一种模式匹配</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-rust" data-lang="rust"><span class="line"><span class="cl"><span class="k">fn</span> <span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="k">match</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="mi">1</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="fm">println!</span><span class="p">(</span><span class="s">&#34;one&#34;</span><span class="p">),</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="mi">2</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="fm">println!</span><span class="p">(</span><span class="s">&#34;two&#34;</span><span class="p">),</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="n">_</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="fm">println!</span><span class="p">(</span><span class="s">&#34;anything&#34;</span><span class="p">),</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>最简单的使用就像一个 switch，但是除了能匹配出值，也能匹配出位置、甚至名字。</p>
<p>对后面这句是不是有点想法？</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kr">const</span> <span class="p">{</span> <span class="nx">a</span><span class="p">,</span> <span class="nx">b</span> <span class="p">}</span> <span class="o">=</span> <span class="p">{</span> <span class="nx">a</span><span class="o">:</span> <span class="mi">1</span><span class="p">,</span> <span class="nx">b</span><span class="o">:</span> <span class="mi">2</span> <span class="p">};</span>
</span></span><span class="line"><span class="cl"><span class="c1">// a should be 1; b should be 2.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="kr">const</span> <span class="p">[</span> <span class="nx">a</span><span class="p">,</span> <span class="nx">_</span><span class="p">,</span> <span class="p">...</span><span class="nx">c</span> <span class="p">]</span> <span class="o">=</span> <span class="p">[</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span> <span class="p">];</span>
</span></span><span class="line"><span class="cl"><span class="c1">// a should be 1; c should be [3,4,5].
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>其实js里的解构赋值就是一种模式匹配，除了【条件执行】以外，还有【提取】出想要的数据的功能。回过头看正则表达式，就能很容易理解这个概念，既可以test去测试是否匹配，又可以exec去捕获匹配到的数据。</p>
<blockquote>
<p>In contrast to pattern recognition, the match usually has to be exact: &ldquo;either it will or will not be a match.&quot;—— Wikipedia</p>
</blockquote>
<p>在维基里还指出了模式匹配与模式识别（Pattern Recognition）的一个区别，就是前者一般来说是精确 的，要么会被匹配，要么不会被匹配（对于一个分支来说），不会有置信度多少的匹配情况。</p>
<h3 id="好处在哪">好处在哪</h3>
<h4 id="符合人类思考方式的设计">符合人类思考方式的设计</h4>
<ul>
<li>使用 if 并不是我们的第一思考方式</li>
</ul>
<p>比如我们现在想要计算某一个规则二维图形的周长，这个图形可能是矩形、圆形或者三角形，那么我们写代码的时候可能会这样写：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-rust" data-lang="rust"><span class="line"><span class="cl"><span class="kd">let</span><span class="w"> </span><span class="n">c</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">shape</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">Rectangle</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">len</span><span class="p">,</span><span class="w"> </span><span class="n">wide</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">shape</span><span class="p">.</span><span class="n">len</span><span class="p">,</span><span class="w"> </span><span class="n">shape</span><span class="p">.</span><span class="n">wide</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="n">c</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">len</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">wide</span><span class="p">)</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mi">2</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">shape</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">Circle</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">r</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">shape</span><span class="p">.</span><span class="n">r</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="n">c</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">pi</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">r</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mi">2</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">shape</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">Triangle</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="p">{</span><span class="n">side1</span><span class="p">,</span><span class="w"> </span><span class="n">side2</span><span class="p">,</span><span class="w"> </span><span class="n">side3</span><span class="p">}</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">shape</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="n">c</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">side1</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">side2</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">side3</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>这种代码与我们的思考方式有相悖的地方：</p>
<ol>
<li>我们辨识一个二维图形的时候并不是用排除法的，我们可以一眼看出来这是什么图形，不需要一步步排除</li>
<li>这种代码需要先假设一个周长未知（即变量c）的图形，之后再进行填充，风险就是可能直到最后的 else if 都没匹配上，这样 c 就成了一个未初始化的值（Uninitialized variable），众所周知这种情况常常导致 bug / undefined behavior</li>
</ol>
<p>因此，我们希望有一种更加阳间的写法：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-rust" data-lang="rust"><span class="line"><span class="cl"><span class="kd">let</span><span class="w"> </span><span class="n">c</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">match</span><span class="w"> </span><span class="n">shape</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="n">Rectangle</span><span class="w"> </span><span class="p">{</span><span class="n">len</span><span class="p">,</span><span class="w"> </span><span class="n">wide</span><span class="p">}</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="p">(</span><span class="n">len</span><span class="o">+</span><span class="n">wide</span><span class="p">)</span><span class="o">*</span><span class="mi">2</span><span class="p">,</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="n">Circle</span><span class="w"> </span><span class="p">{</span><span class="n">r</span><span class="p">}</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="n">pi</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">r</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="n">Triangle</span><span class="w"> </span><span class="p">{</span><span class="n">side1</span><span class="p">,</span><span class="w"> </span><span class="n">side2</span><span class="p">,</span><span class="w"> </span><span class="n">side3</span><span class="p">}</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="n">side1</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">side2</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">side3</span><span class="p">,</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">};</span><span class="w">
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>即使是没学过match语法的人应该也能看懂这样的写法，语义上可以理解为：</p>
<p>我们想计算c，需要对它的类型进行一次匹配，而且我们可以看出是三种类型中的一种，然后我们将从对应的类型里提取出需要的参数并进行计算（看成一个解构赋值）。</p>
<p>这里是否解决了上述可能导致ub的问题？答案是在编译器的帮助下，是可以的。在类型安全的规则下，我们应当知道shape的取值范围，如果有第四种图形，那么应当在某个地方（比如类型声明）上有所体现，如果不能匹配出结果，那么这条match表达式将不知道返回什么数据，应该抛出错误。</p>
<p>虽然感觉例子有点小刻意，但我觉得对理解模式匹配的好处很有帮助。</p>
<h4 id="条件执行与提取的兼得">【条件执行】与【提取】的兼得</h4>
<ul>
<li>If 只能做到条件筛选，却不好做赋值</li>
</ul>
<blockquote>
<p>当然也可以用 if (a = 114514) 这样的混沌写法，但是在实践上一般是拒绝这种写法的，因为这并不是“有条件”地赋值，早已不被提倡</p>
</blockquote>
<p>在上面的例子中，我们在每个判断后加上一行赋值（不加也行，但是你的成员调用将会很啰嗦），实际上是不太有额外信息量的语句，<em>我相信优雅流畅的代码应如自然语言一样好读</em></p>
<blockquote>
<p>在 Rust 里确实有带条件的赋值，请自行学习 if let 语法</p>
</blockquote>
<h4 id="从语句到表达式-的转变">从语句到表达式 的转变</h4>
<ul>
<li>表达式提供了更灵活的写法</li>
</ul>
<p>注意甄别语句和表达式（statement vs expression）</p>
<p>接触过编译原理的话应该能记住区别，忘记了也不要紧，简单概括就是：</p>
<ol>
<li>语句是一个过程</li>
<li>表达式是一个值</li>
</ol>
<p>比如箭头函数() =&gt; 1，我们偶尔打顺手在1后多了个分号的时候，编译器往往会尝试纠正你，因为1;是语句，而不是表达式。
再比如我们写 jsx：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-jsx" data-lang="jsx"><span class="line"><span class="cl"><span class="c1">// valid
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">&lt;</span><span class="nt">div</span><span class="p">&gt;{</span> <span class="nx">condition</span> <span class="o">?</span> <span class="s1">&#39;true&#39;</span><span class="o">:</span> <span class="s1">&#39;false&#39;</span> <span class="p">}&lt;/</span><span class="nt">div</span><span class="p">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="c1">// invalid
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">&lt;</span><span class="nt">div</span><span class="p">&gt;</span> <span class="p">{</span> <span class="k">if</span> <span class="p">(</span><span class="nx">condition</span><span class="p">)</span> <span class="p">{</span><span class="s1">&#39;true&#39;</span><span class="p">;}</span> <span class="k">else</span> <span class="p">{</span> <span class="s1">&#39;false&#39;</span><span class="p">;</span> <span class="p">}</span> <span class="p">}</span> <span class="p">&lt;/</span><span class="nt">div</span><span class="p">&gt;</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>我想上面两段想表达的是同一个语义：如果条件成立，那么渲染 <code>&lt;div&gt;true&lt;/div&gt;</code> ，否则渲染 <code>&lt;div&gt;false&lt;/div&gt;</code></p>
<p>但是显然下面的是非法的，因为它是一个 if 语句，而不是表达式，不具有值。</p>
<p>从上面举过的图形周长的例子里，我们在match后可以直接赋值给c，因此match是一个表达式而不是值</p>
<p>这也是跟switch的一个区别，因为switch也是一个语句而不是表达式。</p>
<p>表达式有比语句更灵活的特点，因为expression是statement的组成，当表达式不赋值给变量的时候我们也可以当做一个只包含一个expression的statement，这种设计有助于更优雅地编程。</p>
<h3 id="性能有提升吗">性能有提升吗？</h3>
<p>实际上模式匹配带来的是抽象层面的升华，计算机总归无法像人类一样思考，因此在性能方面并不是其优势，底层实现就是一堆 if else。</p>
<p>可以参考这个回答：How is match implemented in a language like Rust?</p>
<p>其中的回答给了这个例子：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-rust" data-lang="rust"><span class="line"><span class="cl"><span class="k">enum</span> <span class="nb">Result</span> <span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="n">SingleResult</span><span class="p">(</span><span class="kt">i32</span><span class="p">),</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="n">TwoResults</span><span class="p">(</span><span class="kt">i32</span><span class="p">,</span><span class="w"> </span><span class="kt">i32</span><span class="p">),</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="n">Error</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">match</span><span class="w"> </span><span class="n">someResult</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="nb">Result</span>::<span class="n">SingleResult</span><span class="p">(</span><span class="n">res</span><span class="p">)</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="n">f</span><span class="p">(</span><span class="n">res</span><span class="p">),</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="nb">Result</span>::<span class="n">TwoResults</span><span class="p">(</span><span class="n">res1</span><span class="p">,</span><span class="w"> </span><span class="n">res2</span><span class="p">)</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="n">g</span><span class="p">(</span><span class="n">res1</span><span class="p">,</span><span class="w"> </span><span class="n">res2</span><span class="p">),</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="nb">Result</span>::<span class="n">Error</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="n">error</span><span class="p">()</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>上面的 enum 是 Rust 里的枚举值，与大多语言不一样的是，Rust 的枚举值里是可以携带额外的信息的（可以是结构、数组、元组、基本类型等等）</p>
<p>其实现后的C代码大概如下</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="k">struct</span> <span class="n">Result</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">enum</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">SingleResult</span><span class="p">,</span> <span class="n">TwoResults</span><span class="p">,</span> <span class="n">Error</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span> <span class="n">tag</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="k">union</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">struct</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="kt">int</span> <span class="n">arg1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span> <span class="n">singleResult</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">struct</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="kt">int</span> <span class="n">arg1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">      <span class="kt">int</span> <span class="n">arg2</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span> <span class="n">twoResults</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span> <span class="n">value</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">switch</span><span class="p">(</span><span class="n">someResult</span><span class="p">.</span><span class="n">tag</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">case</span> <span class="nl">SingleResult</span><span class="p">:</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">res</span> <span class="o">=</span> <span class="n">someResult</span><span class="p">.</span><span class="n">value</span><span class="p">.</span><span class="n">singleResult</span><span class="p">.</span><span class="n">arg1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">f</span><span class="p">(</span><span class="n">res</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">break</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="k">case</span> <span class="nl">TwoResults</span><span class="p">:</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">res1</span> <span class="o">=</span> <span class="n">someResult</span><span class="p">.</span><span class="n">value</span><span class="p">.</span><span class="n">twoResults</span><span class="p">.</span><span class="n">arg1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">res2</span> <span class="o">=</span> <span class="n">someResult</span><span class="p">.</span><span class="n">value</span><span class="p">.</span><span class="n">twoResults</span><span class="p">.</span><span class="n">arg2</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">g</span><span class="p">(</span><span class="n">res1</span><span class="p">,</span> <span class="n">res2</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">break</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="k">case</span> <span class="nl">Error</span><span class="p">:</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">error</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="k">break</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>上面的union在TypeScript里有更为优雅的表达（缺点是没把SingleResult与{arg1: number}绑定起来）：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-typescript" data-lang="typescript"><span class="line"><span class="cl"><span class="kr">interface</span> <span class="nx">Result</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nx">tag</span>: <span class="kt">enum</span> <span class="nx">ResultTag</span> <span class="p">{</span> <span class="nx">SingleResult</span><span class="p">,</span> <span class="nx">TwoResults</span><span class="p">,</span> <span class="nb">Error</span> <span class="p">},</span>
</span></span><span class="line"><span class="cl">    <span class="nx">value</span><span class="o">:</span> <span class="p">{</span><span class="nx">arg1</span>: <span class="kt">number</span><span class="p">}</span> <span class="o">|</span> <span class="p">{</span><span class="nx">arg1</span>: <span class="kt">number</span><span class="p">,</span> <span class="nx">arg2</span>: <span class="kt">number</span><span class="p">},</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>这个涉及代数数据类型（Algebraic Data Type），指可以进行代数运算的类型（比如 |，&amp; 等），不是讲述重点，请自己查阅资料 <a class="link" href="https://en.wikipedia.org/wiki/Algebraic_data_type"  target="_blank" rel="noopener"
    >Algebraic_data_type——wiki</a></p>
<h2 id="rust-的-optiont-resultt-e-与-match">Rust 的 Option<!-- raw HTML omitted -->, Result&lt;T, E&gt; 与 match</h2>
<h3 id="optiont">Option<!-- raw HTML omitted --></h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-rust" data-lang="rust"><span class="line"><span class="cl"><span class="k">enum</span> <span class="nb">Option</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="nb">None</span><span class="p">,</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="nb">Some</span><span class="p">(</span><span class="n">T</span><span class="p">),</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>尖括号很容易看出来是泛型的意思，而 Some(T) 代表一个 Some 中可以携带一个T类型的值，比如 Option<!-- raw HTML omitted --> 这个枚举类型包括了 None 或者 Some(i32) 两种枚举值，而 Some(114514) 就是一个Option<!-- raw HTML omitted -->类型。</p>
<p>重新思考一下上面说的携带不同类型值的 enum 的底层实现，就是那个 union，就能理解“携带值的枚举值”这件事。</p>
<p>一个 Option 类型的值代表其处于有值（Some）跟没值（None）的叠加态，对其进行观察（匹配）将坍塌到其中一个状态 XD</p>
<p>如果解析出来这个值是Some，那么我们将可以类型安全地 访问到其里面的值。（意味着编译器可以帮助你规范行为，也可以帮你做好语法提示，访问里面的值一定是类型安全的，即不会在类型上翻车）</p>
<h3 id="resultt-e">Result&lt;T, E&gt;</h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-rust" data-lang="rust"><span class="line"><span class="cl"><span class="k">enum</span> <span class="nb">Result</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span><span class="w"> </span><span class="n">E</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="nb">Ok</span><span class="p">(</span><span class="n">T</span><span class="p">),</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="nb">Err</span><span class="p">(</span><span class="n">E</span><span class="p">),</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"> </span><span class="p">}</span><span class="w">
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>我认为上面讲过 Option 后，理解 Result 应该也很简单，一个 Result 类型的值处于成功与失败的叠加态，如果成功，就能类型安全地访问其中的 T 类型但无法访问 E 类型的值（union 只能同时存在一个对吧），如果失败，我们能安全地访问错误里的 E 类型，此时又无法访问 T 类型的值。</p>
<p>很明显这个可以用在错误处理的领域，我觉得会很容易联想到大道至简的 go</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="nx">res</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nf">function</span><span class="p">()</span>
</span></span><span class="line"><span class="cl"><span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// handle the error
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="nf">use</span><span class="p">(</span><span class="nx">res</span><span class="p">)</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>偶尔能见到 gopher 管自己叫 if err != nil 工程师，因为一个可能发生错误的函数往往是这么返回数据的，通过校验是否有 err 来判断成功与否，这种处理方式的缺陷除了写起来很啰嗦外，还有一个缺陷，就是处理可能不到位。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="nx">res</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nf">function</span><span class="p">()</span>
</span></span><span class="line"><span class="cl"><span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nx">fmt</span><span class="p">.</span><span class="nb">println</span><span class="p">(</span><span class="s">&#34;some error|&#34;</span><span class="p">,</span> <span class="nx">err</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// forget to return!
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="c1">// use an invalid res!
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nf">use</span><span class="p">(</span><span class="nx">res</span><span class="p">)</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>实际上，这种错误处理全凭自觉，我们将正确处理的结果与错误处理的失败原因一起返回，只能通过程序员自觉去处理这种关系，但偶尔可能在处理 err 后，忘记 return 了，而且也没对 res 进行再处理，导致执行流继续进行下去，访问了不该访问的res（此时无法知道是什么值），将会产生 ub。</p>
<p>而 Result 是解决这个问题的利器，因为处于成功状态的结果无法访问失败状态的类型，而失败的结果无法访问成功时的数据，即使代码还没开始跑，你也知道肯定不会出错。</p>
<p>常用的错误处理还有try catch系列，依然需要靠自觉，常有忘记在throwable的函数外加try，导致无法正常捕获到错误（Uncaught error）的事发生（比如对内层函数不了解的话就无法知道是否throwable，虽然常有兜底的最外层try，但是在抛出错误后却会中断执行流，无法返回到某个想回去的地方，灵活性比较低，而且写起来缩进确实不怎么好看。</p>
<blockquote>
<p>🤔Promise对象与上面提到的 Option、Result 源自同样的设计思想，先占坑，在运行时再确定这个坑里应当填入啥，不同的结果状态之间是隔离的，从而做到【编译期确定的】类型安全，同时也方便更直观的链式调用，在函数式编程中，这种概念叫 Monad（单子）。
<a class="link" href="https://zh.wikipedia.org/wiki/%E5%8D%95%E5%AD%90_%28%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B%29#%E8%AF%AD%E6%B3%95%E7%B3%96do%E8%A1%A8%E7%A4%BA%E6%B3%95"  target="_blank" rel="noopener"
    >wiki-Monad</a></p>
</blockquote>
<h3 id="match">match</h3>
<p>模式是 Rust 中特殊的语法，它用来匹配类型中的结构，无论类型是简单还是复杂。结合使用模式和 match 表达式以及其他结构可以提供更多对程序控制流的支配权。模式由如下一些内容组合而成：</p>
<ul>
<li>字面值</li>
<li>解构的数组、枚举、结构体或者元组</li>
<li>变量</li>
<li>通配符</li>
<li>占位符
通过以下代码来理解：</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-rust" data-lang="rust"><span class="line"><span class="cl"><span class="k">enum</span> <span class="nc">Message</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="n">Quit</span><span class="p">,</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="n">Move</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">x</span>: <span class="kt">i32</span><span class="p">,</span><span class="w"> </span><span class="n">y</span>: <span class="kt">i32</span> <span class="p">},</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="n">Write</span><span class="p">(</span><span class="nb">String</span><span class="p">),</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="n">ChangeColor</span><span class="p">(</span><span class="kt">i32</span><span class="p">,</span><span class="w"> </span><span class="kt">i32</span><span class="p">,</span><span class="w"> </span><span class="kt">i32</span><span class="p">),</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">fn</span> <span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">msg</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Message</span>::<span class="n">ChangeColor</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">160</span><span class="p">,</span><span class="w"> </span><span class="mi">255</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="k">match</span><span class="w"> </span><span class="n">msg</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="n">Message</span>::<span class="n">Quit</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="fm">println!</span><span class="p">(</span><span class="s">&#34;The Quit variant has no data to destructure.&#34;</span><span class="p">)</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="n">Message</span>::<span class="n">Move</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="fm">println!</span><span class="p">(</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                </span><span class="s">&#34;Move in the x direction {} and in the y direction {}&#34;</span><span class="p">,</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                </span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="n">y</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="n">Message</span>::<span class="n">Write</span><span class="p">(</span><span class="n">text</span><span class="p">)</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="fm">println!</span><span class="p">(</span><span class="s">&#34;Text message: {}&#34;</span><span class="p">,</span><span class="w"> </span><span class="n">text</span><span class="p">),</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="n">Message</span>::<span class="n">ChangeColor</span><span class="p">(</span><span class="n">r</span><span class="p">,</span><span class="w"> </span><span class="n">g</span><span class="p">,</span><span class="w"> </span><span class="n">b</span><span class="p">)</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="fm">println!</span><span class="p">(</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="s">&#34;Change the color to red {}, green {}, and blue {}&#34;</span><span class="p">,</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="n">r</span><span class="p">,</span><span class="w"> </span><span class="n">g</span><span class="p">,</span><span class="w"> </span><span class="n">b</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="p">),</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>代码来自 <a class="link" href="https://kaisery.github.io/trpl-zh-cn/ch18-00-patterns.html"  target="_blank" rel="noopener"
    >模式与模式匹配 - Rust 程序设计语言 简体中文版</a></p>
<p>其实就是匹配成功后还能捕获其中的值。</p>
<h2 id="optiont-in-ts">Option<!-- raw HTML omitted --> in TS</h2>
<p>前面讲了非常非常多的铺垫，终于到正题了，如何在 TS 里实现上面讲了一大通的这些特征？
下面的内容是对一个开源实现 oxide.ts 的源码解读 <a class="link" href="https://github.com/traverse1984/oxide.ts"  target="_blank" rel="noopener"
    >仓库地址</a>，源码测试、文档全覆盖，堪称优雅的仓库，也很推荐阅读。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-ts" data-lang="ts"><span class="line"><span class="cl"><span class="c1">// src/common.ts
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kr">export</span> <span class="kr">const</span> <span class="nx">SymbolT</span> <span class="o">=</span> <span class="nx">Symbol</span><span class="p">(</span><span class="s1">&#39;T&#39;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="kr">export</span> <span class="kr">const</span> <span class="nx">SymbolVal</span> <span class="o">=</span> <span class="nx">Symbol</span><span class="p">(</span><span class="s1">&#39;Val&#39;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// src/option.ts
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kr">export</span> <span class="kr">type</span> <span class="nx">Some</span><span class="p">&lt;</span><span class="nt">T</span><span class="p">&gt;</span> <span class="o">=</span> <span class="nx">OptionType</span><span class="p">&lt;</span><span class="nt">T</span><span class="p">&gt;</span> <span class="o">&amp;</span> <span class="p">{</span> <span class="p">[</span><span class="nx">SymbolT</span><span class="p">]</span><span class="o">:</span> <span class="kc">true</span> <span class="p">};</span>
</span></span><span class="line"><span class="cl"><span class="kr">export</span> <span class="kr">type</span> <span class="nx">None</span> <span class="o">=</span> <span class="nx">OptionType</span><span class="p">&lt;</span><span class="nt">never</span><span class="p">&gt;</span> <span class="o">&amp;</span> <span class="p">{</span> <span class="p">[</span><span class="nx">SymbolT</span><span class="p">]</span><span class="o">:</span> <span class="kc">false</span> <span class="p">};</span>
</span></span><span class="line"><span class="cl"><span class="kr">class</span> <span class="nx">OptionType</span><span class="p">&lt;</span><span class="nt">T</span><span class="p">&gt;</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">   <span class="kr">readonly</span> <span class="p">[</span><span class="nx">SymbolT</span><span class="p">]</span><span class="o">:</span> <span class="kr">boolean</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">   <span class="kr">readonly</span> <span class="p">[</span><span class="nx">SymbolVal</span><span class="p">]</span><span class="o">:</span> <span class="nx">T</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">   <span class="kr">constructor</span><span class="p">(</span><span class="nx">val</span>: <span class="kt">T</span><span class="p">,</span> <span class="nx">some</span>: <span class="kt">boolean</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="k">this</span><span class="p">[</span><span class="nx">SymbolT</span><span class="p">]</span> <span class="o">=</span> <span class="nx">some</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">      <span class="k">this</span><span class="p">[</span><span class="nx">SymbolVal</span><span class="p">]</span> <span class="o">=</span> <span class="nx">val</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">   <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>Option 的核心是实现一个 OptionType<!-- raw HTML omitted -->，而 Some<!-- raw HTML omitted --> 与 None 均源自 OptionType。</p>
<p>SymbolT 和 SymbolVal 是两个 Symbol 类型的值，意味着 OptionType 里其他的键不会与这俩发生冲突（js的类型因为使用字符串作成员名的缘故常有冲突发生的情况，比如 obj[&rsquo;toString&rsquo;] 就与某个内置方法冲突了）</p>
<p>有了 Some<!-- raw HTML omitted --> 和 None 类型，如何创建一个这个类型的值？通过构造函数就行了</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-ts" data-lang="ts"><span class="line"><span class="cl"><span class="kr">export</span> <span class="kr">const</span> <span class="nx">None</span> <span class="o">=</span> <span class="nb">Object</span><span class="p">.</span><span class="nx">freeze</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">   <span class="k">new</span> <span class="nx">OptionType</span><span class="p">&lt;</span><span class="nt">never</span><span class="p">&gt;(</span><span class="kc">undefined</span> <span class="kr">as</span> <span class="kt">never</span><span class="p">,</span> <span class="kc">false</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">)</span> <span class="kr">as</span> <span class="nx">None</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">/// 使用 Some()
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kr">export</span> <span class="kd">function</span> <span class="nx">Some</span><span class="p">&lt;</span><span class="nt">T</span><span class="p">&gt;(</span><span class="nx">val</span>: <span class="kt">T</span><span class="p">)</span><span class="o">:</span> <span class="nx">Some</span><span class="p">&lt;</span><span class="nt">T</span><span class="p">&gt;</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">   <span class="k">return</span> <span class="k">new</span> <span class="nx">OptionType</span><span class="p">(</span><span class="nx">val</span><span class="p">,</span> <span class="kc">true</span><span class="p">)</span> <span class="kr">as</span> <span class="nx">Some</span><span class="p">&lt;</span><span class="nt">T</span><span class="p">&gt;;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>Tips: 变量名跟类型名是不冲突的，意味着下面的代码成立。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-ts" data-lang="ts"><span class="line"><span class="cl"><span class="kr">type</span> <span class="nx">a</span> <span class="o">=</span> <span class="kt">number</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="kd">function</span> <span class="nx">a</span><span class="p">()</span><span class="o">:</span> <span class="nx">a</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">   <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>Object.freeze 的作用是创建一个无法增删改字段的对象</p>
<p>我们通过下面的方式分别创建变量</p>
<p><img src="https://s3.bmp.ovh/imgs/2022/09/12/4b434da806866e36.png"
	
	
	
	loading="lazy"
	
	
></p>
<p>分别打印a, b，可以得到以下结果</p>
<p><img src="https://s3.bmp.ovh/imgs/2022/09/12/6f77ad5dce7924d8.png"
	
	
	
	loading="lazy"
	
	
></p>
<p>基于Symbol(Val)和Symbol(T)这两个字段，我们可以构造出许多有用的方法，为了找一个无法静态编译期确定的例子（即运行后才知道成不成功），我先构造一个 Rusty （有 Rust 风格的）的处理函数在这。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-ts" data-lang="ts"><span class="line"><span class="cl"><span class="kd">function</span> <span class="nx">rustyParseInt</span><span class="p">(</span><span class="nx">str</span>: <span class="kt">string</span><span class="p">)</span><span class="o">:</span> <span class="nx">Option</span><span class="p">&lt;</span><span class="nt">number</span><span class="p">&gt;</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="kr">const</span> <span class="nx">res</span> <span class="o">=</span> <span class="nb">parseInt</span><span class="p">(</span><span class="nx">str</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="k">if</span> <span class="p">(</span><span class="nb">isNaN</span><span class="p">(</span><span class="nx">res</span><span class="p">))</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="nx">None</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="k">return</span> <span class="nx">Some</span><span class="p">(</span><span class="nx">res</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>上述函数是对 parseInt的包装，原生 parseInt 在解析失败时会返回一个 NaN，我们将NaN改成None，解析成功则返回Some</p>
<p>看下面的方法：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-ts" data-lang="ts"><span class="line"><span class="cl"><span class="c1">/// Option必须是一个Some，否则抛出错误（在rust里是panic）
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nx">expect</span><span class="p">(</span><span class="k">this</span><span class="o">:</span> <span class="nx">Option</span><span class="p">&lt;</span><span class="nt">T</span><span class="p">&gt;,</span> <span class="nx">msg</span>: <span class="kt">string</span><span class="p">)</span><span class="o">:</span> <span class="nx">T</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">   <span class="k">if</span> <span class="p">(</span><span class="k">this</span><span class="p">[</span><span class="nx">SymbolT</span><span class="p">])</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="k">return</span> <span class="k">this</span><span class="p">[</span><span class="nx">SymbolVal</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">   <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="k">throw</span> <span class="k">new</span> <span class="nb">Error</span><span class="p">(</span><span class="nx">msg</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">   <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// example.ts
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kr">const</span> <span class="nx">a</span>: <span class="kt">number</span> <span class="o">=</span> <span class="nx">rustyParseInt</span><span class="p">(</span><span class="s1">&#39;would_fail&#39;</span><span class="p">).</span><span class="nx">expect</span><span class="p">(</span><span class="s1">&#39;fail_reason&#39;</span><span class="p">);</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>expect可以视为对【某个Option的实例应是Some】的断言，并返回其中的类型，如果不是Some将抛出错误。</p>
<p>运行example.ts后将会抛出理由为fail_reason的错误</p>
<p><img src="https://s3.bmp.ovh/imgs/2022/09/12/776e341a4281694e.png"
	
	
	
	loading="lazy"
	
	
></p>
<p>由expect，又可以包装出多种方法</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-ts" data-lang="ts"><span class="line"><span class="cl"><span class="nx">unwrap</span><span class="p">(</span><span class="k">this</span><span class="o">:</span> <span class="nx">Option</span><span class="p">&lt;</span><span class="nt">T</span><span class="p">&gt;)</span><span class="o">:</span> <span class="nx">T</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="nx">unwrapOr</span><span class="p">(</span><span class="k">this</span><span class="o">:</span> <span class="nx">Option</span><span class="p">&lt;</span><span class="nt">T</span><span class="p">&gt;,</span> <span class="nx">def</span>: <span class="kt">T</span><span class="p">)</span><span class="o">:</span> <span class="nx">T</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="nx">unwrapOrElse</span><span class="p">(</span><span class="k">this</span><span class="o">:</span> <span class="nx">Option</span><span class="p">&lt;</span><span class="nt">T</span><span class="p">&gt;,</span> <span class="nx">f</span><span class="o">:</span> <span class="p">()</span> <span class="o">=&gt;</span> <span class="nx">T</span><span class="p">)</span><span class="o">:</span> <span class="nx">T</span><span class="p">;</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="对原有-api-的安全封装">对原有 API 的安全封装</h3>
<p>该库提供了 safe 函数，用于安全地 捕获一个同步/异步函数的结果为Option<!-- raw HTML omitted -->，而不会抛出错误或者引发reject。</p>
<p>下面截图即safe的实现代码，vscode能在then里做出正确的类型推断。</p>
<p><img src="https://s3.bmp.ovh/imgs/2022/09/12/46bb13f5b5e1e01e.png"
	
	
	
	loading="lazy"
	
	
></p>
<p>乍一看上面有三个safe，JS/TS 并不支持函数重载（Function Override），这是 TS 的 Function Overload 的特性，详见文档 functions overload。</p>
<p>意思是，上面两个safe是实际使用时的应当约束的函数类型，最下面的safe是对上面两种签名的兼容性实现。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-ts" data-lang="ts"><span class="line"><span class="cl"><span class="kd">function</span> <span class="nx">makeDate</span><span class="p">(</span><span class="nx">timestamp</span>: <span class="kt">number</span><span class="p">)</span><span class="o">:</span> <span class="nb">Date</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="kd">function</span> <span class="nx">makeDate</span><span class="p">(</span><span class="nx">m</span>: <span class="kt">number</span><span class="p">,</span> <span class="nx">d</span>: <span class="kt">number</span><span class="p">,</span> <span class="nx">y</span>: <span class="kt">number</span><span class="p">)</span><span class="o">:</span> <span class="nb">Date</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="kd">function</span> <span class="nx">makeDate</span><span class="p">(</span><span class="nx">mOrTimestamp</span>: <span class="kt">number</span><span class="p">,</span> <span class="nx">d?</span>: <span class="kt">number</span><span class="p">,</span> <span class="nx">y?</span>: <span class="kt">number</span><span class="p">)</span><span class="o">:</span> <span class="nb">Date</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">if</span> <span class="p">(</span><span class="nx">d</span> <span class="o">!==</span> <span class="kc">undefined</span> <span class="o">&amp;&amp;</span> <span class="nx">y</span> <span class="o">!==</span> <span class="kc">undefined</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="k">new</span> <span class="nb">Date</span><span class="p">(</span><span class="nx">y</span><span class="p">,</span> <span class="nx">mOrTimestamp</span><span class="p">,</span> <span class="nx">d</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="k">new</span> <span class="nb">Date</span><span class="p">(</span><span class="nx">mOrTimestamp</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">d1</span> <span class="o">=</span> <span class="nx">makeDate</span><span class="p">(</span><span class="mi">12345678</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">d2</span> <span class="o">=</span> <span class="nx">makeDate</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">5</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">d3</span> <span class="o">=</span> <span class="nx">makeDate</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="c1">// No overload expects 2 arguments, but overloads do exist that expect either 1 or 3 arguments.
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>上面是官方的例子，看一下就懂了，d1, d2 都可以被正常编译，d3 则通过不了类型检查，尽管符合第三个makeDate的函数签名。</p>
<p><img src="https://s3.bmp.ovh/imgs/2022/09/12/46bb13f5b5e1e01e.png"
	
	
	
	loading="lazy"
	
	
></p>
<p>回到上面 safe 的实现（与前面是同一张图，方便观看），第一个签名接受的是一个同步函数及该函数的参数，通过 PromiseLike 来约束是否异步函数，是则要求返回值为never类型，代表一个不会返回的函数（一定会throw，或是无限循环），既然无法返回也就不会需要safe包装返回值。</p>
<p>一个 PromiseLike 接口要求实现 then(onfulfilled, onerjected)，具体看TS的官方文档 <a class="link" href="https://microsoft.github.io/PowerBI-JavaScript/interfaces/_node_modules_typedoc_node_modules_typescript_lib_lib_es5_d_.promiselike.html"  target="_blank" rel="noopener"
    >PromiseLike 接口文档</a></p>
<p>第二个签名接受一个 Promise 对象作为参数，其实就是异步函数执行后的返回值。返回一个 Promise&lt;Option<!-- raw HTML omitted -->&gt;的结果，注意一个Option&lt;Promise<!-- raw HTML omitted -->&gt;的类型是没有实用意义的，因为不管resolve还是reject，都会得到一个Some结果，所以一个实用的包装应当是 Promise&lt;Some<!-- raw HTML omitted -->&gt;与Promise<!-- raw HTML omitted -->，对应了resolve与reject的结果。</p>
<p>实现上很简单，把 throw、reject 包装成 None, 把 resolve 和正常执行包装为 Some 即可。</p>
<h3 id="其他的方法">其他的方法</h3>
<p>Option 提供了一些其他的方法，实现都很简单，意义也清楚所以不详细介绍。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-ts" data-lang="ts"><span class="line"><span class="cl"><span class="nx">isNone</span><span class="p">()</span>
</span></span><span class="line"><span class="cl"><span class="nx">isSome</span><span class="p">()</span>
</span></span><span class="line"><span class="cl"><span class="nx">map</span><span class="p">&lt;</span><span class="nt">U</span><span class="p">&gt;(</span><span class="k">this</span><span class="o">:</span> <span class="nx">Option</span><span class="p">&lt;</span><span class="nt">T</span><span class="p">&gt;,</span> <span class="nx">f</span><span class="o">:</span> <span class="p">(</span><span class="nx">val</span>: <span class="kt">T</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="nx">U</span><span class="p">)</span><span class="o">:</span> <span class="nx">Option</span><span class="p">&lt;</span><span class="nt">U</span><span class="p">&gt;</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h2 id="resultt-e-in-ts">Result&lt;T, E&gt; in TS</h2>
<p>Result 跟 Option 的实现就没有太大差别了，除了 Result 在失败时可以携带错误信息</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-ts" data-lang="ts"><span class="line"><span class="cl"><span class="kr">export</span> <span class="kr">type</span> <span class="nx">Ok</span><span class="p">&lt;</span><span class="nt">T</span><span class="p">&gt;</span> <span class="o">=</span> <span class="nx">ResultType</span><span class="p">&lt;</span><span class="nt">T</span><span class="err">,</span> <span class="na">never</span><span class="p">&gt;;</span>
</span></span><span class="line"><span class="cl"><span class="kr">export</span> <span class="kr">type</span> <span class="nx">Err</span><span class="p">&lt;</span><span class="nt">E</span><span class="p">&gt;</span> <span class="o">=</span> <span class="nx">ResultType</span><span class="p">&lt;</span><span class="nt">never</span><span class="err">,</span> <span class="na">E</span><span class="p">&gt;;</span>
</span></span><span class="line"><span class="cl"><span class="kr">export</span> <span class="kr">class</span> <span class="nx">ResultType</span><span class="p">&lt;</span><span class="nt">T</span><span class="err">,</span> <span class="na">E</span><span class="p">&gt;</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">   <span class="kr">readonly</span> <span class="p">[</span><span class="nx">SymbolT</span><span class="p">]</span><span class="o">:</span> <span class="kr">boolean</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">   <span class="kr">readonly</span> <span class="p">[</span><span class="nx">SymbolVal</span><span class="p">]</span><span class="o">:</span> <span class="nx">T</span> <span class="o">|</span> <span class="nx">E</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">   <span class="kr">constructor</span><span class="p">(</span><span class="nx">val</span>: <span class="kt">T</span> <span class="o">|</span> <span class="nx">E</span><span class="p">,</span> <span class="nx">ok</span>: <span class="kt">boolean</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="k">this</span><span class="p">[</span><span class="nx">SymbolVal</span><span class="p">]</span> <span class="o">=</span> <span class="nx">val</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">      <span class="k">this</span><span class="p">[</span><span class="nx">SymbolT</span><span class="p">]</span> <span class="o">=</span> <span class="nx">ok</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">   <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>Ok 与 Err 的构造方式也很简单</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-ts" data-lang="ts"><span class="line"><span class="cl"><span class="kr">export</span> <span class="kd">function</span> <span class="nx">Ok</span><span class="p">&lt;</span><span class="nt">T</span><span class="p">&gt;(</span><span class="nx">val</span>: <span class="kt">T</span><span class="p">)</span><span class="o">:</span> <span class="nx">Ok</span><span class="p">&lt;</span><span class="nt">T</span><span class="p">&gt;</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">   <span class="k">return</span> <span class="k">new</span> <span class="nx">ResultType</span><span class="p">&lt;</span><span class="nt">T</span><span class="err">,</span> <span class="na">never</span><span class="p">&gt;(</span><span class="nx">val</span><span class="p">,</span> <span class="kc">true</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="kr">export</span> <span class="kd">function</span> <span class="nx">Err</span><span class="p">&lt;</span><span class="nt">E</span><span class="p">&gt;(</span><span class="nx">val</span>: <span class="kt">E</span><span class="p">)</span><span class="o">:</span> <span class="nx">Err</span><span class="p">&lt;</span><span class="nt">E</span><span class="p">&gt;</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">   <span class="k">return</span> <span class="k">new</span> <span class="nx">ResultType</span><span class="p">&lt;</span><span class="nt">never</span><span class="err">,</span> <span class="na">E</span><span class="p">&gt;(</span><span class="nx">val</span><span class="p">,</span> <span class="kc">false</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h2 id="match-in-ts">match in TS</h2>
<p>oxide.ts 对 match 的实现应该是最好玩的地方，在看如何实现之前，先看实现了怎样的功能</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-ts" data-lang="ts"><span class="line"><span class="cl"><span class="c1">// mapped matching
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kr">const</span> <span class="nx">num</span> <span class="o">=</span> <span class="nx">Option</span><span class="p">(</span><span class="mi">10</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">res</span> <span class="o">=</span> <span class="nx">match</span><span class="p">(</span><span class="nx">num</span><span class="p">,</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">   <span class="nx">Some</span><span class="o">:</span> <span class="p">(</span><span class="nx">n</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="nx">n</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">   <span class="nx">_</span><span class="o">:</span> <span class="p">()</span> <span class="o">=&gt;</span> <span class="mi">0</span><span class="p">,</span>
</span></span><span class="line"><span class="cl"><span class="p">});</span>
</span></span><span class="line"><span class="cl"><span class="nx">assert</span><span class="p">.</span><span class="nx">equal</span><span class="p">(</span><span class="nx">res</span><span class="p">,</span> <span class="mi">11</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// chained matching
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">function</span> <span class="nx">matchArr</span><span class="p">(</span><span class="nx">arr</span>: <span class="kt">number</span><span class="p">[])</span><span class="o">:</span> <span class="kt">string</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">   <span class="k">return</span> <span class="nx">match</span><span class="p">(</span><span class="nx">arr</span><span class="p">,</span> <span class="p">[</span>
</span></span><span class="line"><span class="cl">      <span class="p">[[</span><span class="mi">1</span><span class="p">],</span> <span class="s2">&#34;1&#34;</span><span class="p">],</span>
</span></span><span class="line"><span class="cl">      <span class="p">[[</span><span class="mi">2</span><span class="p">,</span> <span class="p">(</span><span class="nx">x</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="nx">x</span> <span class="o">&gt;</span> <span class="mi">10</span><span class="p">],</span> <span class="s2">&#34;2, &gt; 10&#34;</span><span class="p">],</span>
</span></span><span class="line"><span class="cl">      <span class="p">[[</span><span class="nx">_</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">9</span><span class="p">,</span> <span class="nx">_</span><span class="p">],</span> <span class="p">(</span><span class="nx">a</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="nx">a</span><span class="p">.</span><span class="nx">join</span><span class="p">(</span><span class="s2">&#34;, &#34;</span><span class="p">)],</span>
</span></span><span class="line"><span class="cl">      <span class="p">()</span> <span class="o">=&gt;</span> <span class="s2">&#34;other&#34;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">   <span class="p">]);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="nx">assert</span><span class="p">.</span><span class="nx">equal</span><span class="p">(</span><span class="nx">matchArr</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">]),</span> <span class="s2">&#34;1&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="nx">assert</span><span class="p">.</span><span class="nx">equal</span><span class="p">(</span><span class="nx">matchArr</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span> <span class="mi">12</span><span class="p">,</span> <span class="mi">6</span><span class="p">]),</span> <span class="s2">&#34;2, &gt; 10&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="nx">assert</span><span class="p">.</span><span class="nx">equal</span><span class="p">(</span><span class="nx">matchArr</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">6</span><span class="p">]),</span> <span class="s2">&#34;other&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="nx">assert</span><span class="p">.</span><span class="nx">equal</span><span class="p">(</span><span class="nx">matchArr</span><span class="p">([</span><span class="mi">3</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">9</span><span class="p">]),</span> <span class="s2">&#34;other&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="nx">assert</span><span class="p">.</span><span class="nx">equal</span><span class="p">(</span><span class="nx">matchArr</span><span class="p">([</span><span class="mi">3</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">9</span><span class="p">,</span> <span class="mi">12</span><span class="p">]),</span> <span class="s2">&#34;3, 6, 9, 12&#34;</span><span class="p">);</span>
</span></span></code></pre></td></tr></table>
</div>
</div><ol>
<li>Mapped matching 实现了对 Option / Result 的匹配，</li>
<li>Chained matching 实现了更加灵活、定制化的匹配，可以匹配具体的值、也可以使用规则去匹配</li>
</ol>
<h3 id="实现">实现</h3>
<p>Match 的相关实现长下面这样：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-ts" data-lang="ts"><span class="line"><span class="cl"><span class="kr">export</span> <span class="kr">const</span> <span class="nx">Default</span>: <span class="kt">any</span> <span class="o">=</span> <span class="p">()</span> <span class="o">=&gt;</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">   <span class="k">throw</span> <span class="k">new</span> <span class="nb">Error</span><span class="p">(</span><span class="s2">&#34;Match failed (exhausted)&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl"><span class="kr">export</span> <span class="kd">function</span> <span class="nx">match</span><span class="p">&lt;</span><span class="nt">T</span><span class="err">,</span> <span class="na">U</span><span class="p">&gt;(</span>
</span></span><span class="line"><span class="cl">   <span class="nx">val</span>: <span class="kt">T</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">   <span class="nx">pattern</span>: <span class="kt">MappedBranches</span><span class="p">&lt;</span><span class="nt">T</span><span class="err">,</span> <span class="na">U</span><span class="p">&gt;</span> <span class="o">|</span> <span class="nx">ChainedBranches</span><span class="p">&lt;</span><span class="nt">T</span><span class="err">,</span> <span class="na">U</span><span class="p">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="p">)</span><span class="o">:</span> <span class="nx">U</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">   <span class="k">return</span> <span class="nx">matchDispatch</span><span class="p">(</span><span class="nx">val</span><span class="p">,</span> <span class="nx">pattern</span><span class="p">,</span> <span class="nx">Default</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">function</span> <span class="nx">matchDispatch</span><span class="p">&lt;</span><span class="nt">T</span><span class="err">,</span> <span class="na">U</span><span class="p">&gt;(</span>
</span></span><span class="line"><span class="cl">   <span class="nx">val</span>: <span class="kt">T</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">   <span class="nx">pattern</span>: <span class="kt">ChainedBranches</span><span class="p">&lt;</span><span class="nt">T</span><span class="err">,</span> <span class="na">U</span><span class="p">&gt;</span> <span class="o">|</span> <span class="nx">MappedBranches</span><span class="p">&lt;</span><span class="nt">T</span><span class="err">,</span> <span class="na">U</span><span class="p">&gt;,</span>
</span></span><span class="line"><span class="cl">   <span class="nx">defaultBranch</span>: <span class="kt">DefaultBranch</span><span class="p">&lt;</span><span class="nt">U</span><span class="p">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="p">)</span><span class="o">:</span> <span class="nx">U</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">   <span class="k">if</span> <span class="p">(</span><span class="nb">Array</span><span class="p">.</span><span class="nx">isArray</span><span class="p">(</span><span class="nx">pattern</span><span class="p">))</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="k">return</span> <span class="nx">matchChained</span><span class="p">(</span><span class="nx">val</span><span class="p">,</span> <span class="nx">pattern</span><span class="p">,</span> <span class="nx">defaultBranch</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">   <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="nx">isObjectLike</span><span class="p">(</span><span class="nx">pattern</span><span class="p">))</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="k">return</span> <span class="nx">matchMapped</span><span class="p">(</span><span class="nx">val</span><span class="p">,</span> <span class="nx">pattern</span><span class="p">,</span> <span class="nx">defaultBranch</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">   <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">   <span class="nx">throwInvalidPattern</span><span class="p">();</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>match接收待匹配的值跟分支的模式作为参数，然后调用 matchDispatch。</p>
<p>分支有mapped和chained两种，通过 isArray 和 isObjectLike 区分，然后分别进入 mapped 和 chained 的处理逻辑。</p>
<h4 id="mapped">mapped</h4>
<p>matchMapped 只支持对 Option 和 Result 进行匹配，然后对 pattern 中的项进行匹配。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-ts" data-lang="ts"><span class="line"><span class="cl"><span class="kd">function</span> <span class="nx">matchMapped</span><span class="p">&lt;</span><span class="nt">T</span><span class="err">,</span> <span class="na">U</span><span class="p">&gt;(</span>
</span></span><span class="line"><span class="cl">   <span class="nx">val</span>: <span class="kt">T</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">   <span class="nx">pattern</span>: <span class="kt">OptionMapped</span><span class="p">&lt;</span><span class="nt">any</span><span class="err">,</span> <span class="na">U</span><span class="p">&gt;</span> <span class="o">&amp;</span> <span class="nx">ResultMapped</span><span class="p">&lt;</span><span class="nt">any</span><span class="err">,</span> <span class="na">any</span><span class="err">,</span> <span class="na">U</span><span class="p">&gt;,</span>
</span></span><span class="line"><span class="cl">   <span class="nx">defaultBranch</span>: <span class="kt">DefaultBranch</span><span class="p">&lt;</span><span class="nt">U</span><span class="p">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="p">)</span><span class="o">:</span> <span class="nx">U</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">   <span class="k">if</span> <span class="p">(</span><span class="nx">Option</span><span class="p">.</span><span class="k">is</span><span class="p">(</span><span class="nx">val</span><span class="p">))</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="k">if</span> <span class="p">(</span><span class="nx">val</span><span class="p">[</span><span class="nx">SymbolT</span><span class="p">])</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">         <span class="k">if</span> <span class="p">(</span><span class="nx">pattern</span><span class="p">.</span><span class="nx">Some</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="k">if</span> <span class="p">(</span><span class="k">typeof</span> <span class="nx">pattern</span><span class="p">.</span><span class="nx">Some</span> <span class="o">===</span> <span class="s2">&#34;function&#34;</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">               <span class="c1">// 对于 Some 类型，如果其匹配后跟的是 function，说明是对值的任意匹配
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>               <span class="k">return</span> <span class="nx">pattern</span><span class="p">.</span><span class="nx">Some</span><span class="p">(</span><span class="nx">val</span><span class="p">[</span><span class="nx">SymbolVal</span><span class="p">]);</span>
</span></span><span class="line"><span class="cl">            <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">               <span class="c1">// 不是function，说明可能有更进一步的匹配（具体的值、位置等等），则再次调用dispatch对值进行更细化的匹配，注意的是第三个参数defaultBranch，如果Some中提供了默认分支，那么进入，否则不进入该分支而是使用外层的默认分支（即最外层的 _: () =&gt; something）
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>               <span class="k">return</span> <span class="nx">matchDispatch</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">                  <span class="nx">val</span><span class="p">[</span><span class="nx">SymbolVal</span><span class="p">],</span>
</span></span><span class="line"><span class="cl">                  <span class="nx">pattern</span><span class="p">.</span><span class="nx">Some</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">                  <span class="k">typeof</span> <span class="nx">pattern</span><span class="p">.</span><span class="nx">_</span> <span class="o">===</span> <span class="s2">&#34;function&#34;</span> <span class="o">?</span> <span class="nx">pattern._</span> : <span class="kt">defaultBranch</span>
</span></span><span class="line"><span class="cl">               <span class="p">);</span>
</span></span><span class="line"><span class="cl">            <span class="p">}</span>
</span></span><span class="line"><span class="cl">         <span class="p">}</span>
</span></span><span class="line"><span class="cl">      <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="k">typeof</span> <span class="nx">pattern</span><span class="p">.</span><span class="nx">None</span> <span class="o">===</span> <span class="s2">&#34;function&#34;</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">         <span class="c1">// 对None匹配的处理
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>         <span class="k">return</span> <span class="nx">pattern</span><span class="p">.</span><span class="nx">None</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">      <span class="p">}</span>
</span></span><span class="line"><span class="cl">   <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="nx">Result</span><span class="p">.</span><span class="k">is</span><span class="p">(</span><span class="nx">val</span><span class="p">))</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="c1">// 对Result分支的处理，跟Option基本相同
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>      <span class="kr">const</span> <span class="nx">Branch</span> <span class="o">=</span> <span class="nx">val</span><span class="p">[</span><span class="nx">SymbolT</span><span class="p">]</span> <span class="o">?</span> <span class="nx">pattern.Ok</span> : <span class="kt">pattern.Err</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">      <span class="k">if</span> <span class="p">(</span><span class="nx">Branch</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">         <span class="k">if</span> <span class="p">(</span><span class="k">typeof</span> <span class="nx">Branch</span> <span class="o">===</span> <span class="s2">&#34;function&#34;</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="k">return</span> <span class="nx">Branch</span><span class="p">(</span><span class="nx">val</span><span class="p">[</span><span class="nx">SymbolVal</span><span class="p">]);</span>
</span></span><span class="line"><span class="cl">         <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="c1">// 既没在Option中匹配到也没在Result里匹配到，进入默认分支，如果提供了 _ 的匹配就执行自定义的默认分支，否则进入参数的defaultBranch
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="c1">// 最上面的 defaultBranch 传入了一个会抛出异常的函数Default，即代表没有分支能处理val，这是不可接受的
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="k">return</span> <span class="nx">matchDispatch</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">               <span class="nx">val</span><span class="p">[</span><span class="nx">SymbolVal</span><span class="p">],</span>
</span></span><span class="line"><span class="cl">               <span class="nx">Branch</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">               <span class="k">typeof</span> <span class="nx">pattern</span><span class="p">.</span><span class="nx">_</span> <span class="o">===</span> <span class="s2">&#34;function&#34;</span> <span class="o">?</span> <span class="nx">pattern._</span> : <span class="kt">defaultBranch</span>
</span></span><span class="line"><span class="cl">            <span class="p">);</span>
</span></span><span class="line"><span class="cl">         <span class="p">}</span>
</span></span><span class="line"><span class="cl">      <span class="p">}</span>
</span></span><span class="line"><span class="cl">   <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="nx">throwInvalidPattern</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">   <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">   <span class="k">return</span> <span class="k">typeof</span> <span class="nx">pattern</span><span class="p">.</span><span class="nx">_</span> <span class="o">===</span> <span class="s2">&#34;function&#34;</span> <span class="o">?</span> <span class="nx">pattern</span><span class="p">.</span><span class="nx">_</span><span class="p">()</span> <span class="o">:</span> <span class="nx">defaultBranch</span><span class="p">();</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h4 id="chained">chained</h4>
<p>Chained mapping 支持更加灵活的模式匹配，下面展示部分匹配的方式</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-ts" data-lang="ts"><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">res</span> <span class="o">=</span> <span class="nx">match</span><span class="p">(</span><span class="nx">input</span><span class="p">,</span> <span class="p">[</span>
</span></span><span class="line"><span class="cl">   <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="s2">&#34;number&#34;</span><span class="p">],</span> <span class="c1">// 匹配准确的值
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>   <span class="p">[</span><span class="nx">testObj</span><span class="p">,</span> <span class="s2">&#34;object&#34;</span><span class="p">],</span> <span class="c1">// 匹配准确的对象（浅，同一个对象才能匹配上）
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>   <span class="p">[</span><span class="s2">&#34;test&#34;</span><span class="p">,</span> <span class="p">(</span><span class="nx">val</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="sb">`string </span><span class="si">${</span><span class="nx">val</span><span class="si">}</span><span class="sb">`</span><span class="p">],</span> <span class="c1">// 匹配准确的值，并使用函数作为Result，以捕获到 match 的 input 值
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>   <span class="p">[(</span><span class="nx">val</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="nx">val</span> <span class="o">===</span> <span class="kc">true</span><span class="p">,</span> <span class="s2">&#34;true&#34;</span><span class="p">],</span> <span class="c1">// 提供 filter 作为匹配条件
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>   <span class="p">[(</span><span class="nx">val</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">(</span><span class="nx">val</span> <span class="kr">as</span> <span class="kt">number</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">5</span><span class="p">,</span> <span class="p">(</span><span class="nx">val</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="sb">`num </span><span class="si">${</span><span class="nx">val</span><span class="si">}</span><span class="sb">`</span><span class="p">],</span> <span class="c1">// 提供 filter 为匹配条件，并使用函数作为 Result 捕获 input
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>   <span class="p">[</span><span class="nx">Fn</span><span class="p">(</span><span class="nx">returnTrue</span><span class="p">),</span> <span class="s2">&#34;fn true&#34;</span><span class="p">],</span> <span class="c1">// 匹配一个函数 returnTrue，使用 Fn() 包装以跟 filter 区分开
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>   <span class="p">[</span><span class="nx">Fn</span><span class="p">(</span><span class="nx">returnFalse</span><span class="p">),</span> <span class="s2">&#34;fn false&#34;</span><span class="p">],</span> <span class="c1">// 匹配一个函数 returnFalse，使用 Fn() 包装以跟 filter 区分开
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>   <span class="p">()</span> <span class="o">=&gt;</span> <span class="s2">&#34;default&#34;</span><span class="p">,</span> <span class="c1">// 默认匹配，如果没法匹配到上述项将执行
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">]);</span>
</span></span></code></pre></td></tr></table>
</div>
</div><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-ts" data-lang="ts"><span class="line"><span class="cl"><span class="kr">type</span> <span class="nx">ChainedBranches</span><span class="p">&lt;</span><span class="nt">T</span><span class="err">,</span> <span class="na">U</span><span class="p">&gt;</span> <span class="o">=</span>
</span></span><span class="line"><span class="cl">   <span class="o">|</span> <span class="nx">Branch</span><span class="p">&lt;</span><span class="nt">T</span><span class="err">,</span> <span class="na">U</span><span class="p">&gt;[]</span>
</span></span><span class="line"><span class="cl">   <span class="o">|</span> <span class="p">[...</span><span class="nx">Branch</span><span class="p">&lt;</span><span class="nt">T</span><span class="err">,</span> <span class="na">U</span><span class="p">&gt;[],</span> <span class="nx">DefaultBranch</span><span class="p">&lt;</span><span class="nt">U</span><span class="p">&gt;];</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">function</span> <span class="nx">matchChained</span><span class="p">&lt;</span><span class="nt">T</span><span class="err">,</span> <span class="na">U</span><span class="p">&gt;(</span>
</span></span><span class="line"><span class="cl">   <span class="nx">val</span>: <span class="kt">T</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">   <span class="nx">pattern</span>: <span class="kt">ChainedBranches</span><span class="p">&lt;</span><span class="nt">T</span><span class="err">,</span> <span class="na">U</span><span class="p">&gt;,</span>
</span></span><span class="line"><span class="cl">   <span class="nx">defaultBranch</span>: <span class="kt">DefaultBranch</span><span class="p">&lt;</span><span class="nt">U</span><span class="p">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="p">)</span><span class="o">:</span> <span class="nx">U</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">   <span class="c1">// 遍历 chianed branches，得到每个分支
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>   <span class="k">for</span> <span class="p">(</span><span class="kr">const</span> <span class="nx">branch</span> <span class="k">of</span> <span class="nx">pattern</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="c1">// 分支允许接受函数作为分支，限定为经过 `Fn&lt;U&gt;` wrap 过的函数以及默认的分支 () =&gt; U
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>      <span class="k">if</span> <span class="p">(</span><span class="k">typeof</span> <span class="nx">branch</span> <span class="o">===</span> <span class="s2">&#34;function&#34;</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">         <span class="k">return</span> <span class="p">(</span><span class="nx">branch</span> <span class="kr">as</span> <span class="nx">Fn</span><span class="p">&lt;</span><span class="nt">U</span><span class="p">&gt;)[</span><span class="nx">FnVal</span><span class="p">]</span> <span class="o">?</span> <span class="p">(</span><span class="nx">branch</span> <span class="kr">as</span> <span class="nx">Fn</span><span class="p">&lt;</span><span class="nt">U</span><span class="p">&gt;)[</span><span class="nx">FnVal</span><span class="p">]</span> <span class="o">:</span> <span class="nx">branch</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">      <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">         <span class="kr">const</span> <span class="p">[</span><span class="nx">cond</span><span class="p">,</span> <span class="nx">result</span><span class="p">]</span> <span class="o">=</span> <span class="nx">branch</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">         <span class="c1">// 每个分支分为条件与结果，使用 matches 判断是否匹配上了，在匹配上的情况下：
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>         <span class="k">if</span> <span class="p">(</span><span class="nx">matches</span><span class="p">(</span><span class="nx">cond</span><span class="p">,</span> <span class="nx">val</span><span class="p">,</span> <span class="kc">true</span><span class="p">))</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="k">if</span> <span class="p">(</span><span class="k">typeof</span> <span class="nx">result</span> <span class="o">===</span> <span class="s2">&#34;function&#34;</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">               <span class="c1">// 如果结果是 `Fn&lt;U&gt;` wrap 过的则返回函数本身
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>               <span class="c1">// 结果是普通函数就执行匹配结果
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>               <span class="k">return</span> <span class="p">(</span><span class="nx">result</span> <span class="kr">as</span> <span class="nx">Fn</span><span class="p">&lt;</span><span class="nt">U</span><span class="p">&gt;)[</span><span class="nx">FnVal</span><span class="p">]</span>
</span></span><span class="line"><span class="cl">                  <span class="o">?</span> <span class="p">(</span><span class="nx">result</span> <span class="kr">as</span> <span class="nx">Fn</span><span class="p">&lt;</span><span class="nt">U</span><span class="p">&gt;)[</span><span class="nx">FnVal</span><span class="p">]</span>
</span></span><span class="line"><span class="cl">                  <span class="o">:</span> <span class="p">(</span><span class="nx">result</span> <span class="kr">as</span> <span class="p">(</span><span class="nx">val</span>: <span class="kt">T</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="nx">U</span><span class="p">)(</span><span class="nx">val</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">            <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">               <span class="c1">// 非函数就返回数值
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>               <span class="k">return</span> <span class="nx">result</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">            <span class="p">}</span>
</span></span><span class="line"><span class="cl">         <span class="p">}</span>
</span></span><span class="line"><span class="cl">      <span class="p">}</span>
</span></span><span class="line"><span class="cl">   <span class="p">}</span>
</span></span><span class="line"><span class="cl">   <span class="c1">// 都不是则执行默认分支
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>   <span class="k">return</span> <span class="nx">defaultBranch</span><span class="p">();</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>下面介绍下 <code>Fn&lt;U&gt;</code> 是做什么的：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-ts" data-lang="ts"><span class="line"><span class="cl"><span class="kr">export</span> <span class="kr">const</span> <span class="nx">FnVal</span> <span class="o">=</span> <span class="nx">Symbol</span><span class="p">(</span><span class="s2">&#34;FnVal&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="kr">export</span> <span class="kd">function</span> <span class="nx">Fn</span><span class="p">&lt;</span><span class="nt">T</span> <span class="na">extends</span> <span class="err">(</span><span class="na">...args</span><span class="err">:</span> <span class="na">any</span><span class="err">)</span> <span class="err">=</span><span class="p">&gt;</span> <span class="kt">any</span><span class="o">&gt;</span><span class="p">(</span><span class="nx">fn</span>: <span class="kt">T</span><span class="p">)</span><span class="o">:</span> <span class="p">()</span> <span class="o">=&gt;</span> <span class="nx">T</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">   <span class="kr">const</span> <span class="nx">val</span>: <span class="kt">any</span> <span class="o">=</span> <span class="p">()</span> <span class="o">=&gt;</span> <span class="nx">throwFnCalled</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">   <span class="p">(</span><span class="nx">val</span> <span class="kr">as</span> <span class="kt">any</span><span class="p">)[</span><span class="nx">FnVal</span><span class="p">]</span> <span class="o">=</span> <span class="nx">fn</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">   <span class="k">return</span> <span class="nx">val</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="kr">export</span> <span class="kr">type</span> <span class="nx">Fn</span><span class="p">&lt;</span><span class="nt">T</span><span class="p">&gt;</span> <span class="o">=</span> <span class="p">{</span> <span class="p">()</span><span class="o">:</span> <span class="kt">never</span><span class="p">;</span> <span class="p">[</span><span class="nx">FnVal</span><span class="p">]</span><span class="o">:</span> <span class="nx">T</span> <span class="p">};</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>Fn 是类型也是函数，作为类型的时候表示一个无法被执行（即返回never，在实现里，一定会throw 一个错误的函数），但是存储了函数（通过 FnVal 这个 Symbol 类型来索引）的对象。</p>
<p>Fn 的作用是将函数包装成一个可以被匹配、可以作为匹配结果的对象，而不是在匹配成功时执行、或是作为 filter 存在，如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-ts" data-lang="ts"><span class="line"><span class="cl"><span class="c1">// 使用 Fn 作为分支，匹配成功将返回函数
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nx">match</span><span class="p">(</span><span class="nx">Some</span><span class="p">(</span><span class="mi">1</span><span class="p">),</span> <span class="p">[</span>
</span></span><span class="line"><span class="cl">   <span class="p">[</span><span class="nx">Some</span><span class="p">(</span><span class="mi">1</span><span class="p">),</span> <span class="nx">Fn</span><span class="p">(()</span><span class="o">=&gt;</span><span class="s2">&#34;1&#34;</span><span class="p">)],</span>
</span></span><span class="line"><span class="cl">   <span class="nx">Fn</span><span class="p">(()</span><span class="o">=&gt;</span><span class="s1">&#39;default&#39;</span><span class="p">),</span>
</span></span><span class="line"><span class="cl"><span class="p">])()</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>下面介绍返回是否匹配条件的 matches 的实现：</p>
<p>不过先看看什么样可以算一个合理的条件：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-ts" data-lang="ts"><span class="line"><span class="cl"><span class="kr">type</span> <span class="nx">Branch</span><span class="p">&lt;</span><span class="nt">T</span><span class="err">,</span> <span class="na">U</span><span class="p">&gt;</span> <span class="o">=</span> <span class="p">[</span><span class="nx">BranchCondition</span><span class="p">&lt;</span><span class="nt">T</span><span class="p">&gt;,</span> <span class="nx">BranchResult</span><span class="p">&lt;</span><span class="nt">T</span><span class="err">,</span> <span class="na">U</span><span class="p">&gt;];</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kr">type</span> <span class="nx">BranchCondition</span><span class="p">&lt;</span><span class="nt">T</span><span class="p">&gt;</span> <span class="o">=</span>
</span></span><span class="line"><span class="cl">   <span class="o">|</span> <span class="nx">Mapped</span><span class="p">&lt;</span><span class="nt">T</span><span class="err">,</span> <span class="na">boolean</span><span class="p">&gt;</span>
</span></span><span class="line"><span class="cl">   <span class="o">|</span> <span class="p">(</span><span class="nx">T</span> <span class="kr">extends</span> <span class="p">{</span> <span class="p">[</span><span class="nx">T</span><span class="p">]</span><span class="o">:</span> <span class="kr">boolean</span> <span class="p">}</span> <span class="o">?</span> <span class="nx">MonadCondition</span><span class="p">&lt;</span><span class="nt">T</span><span class="p">&gt;</span> <span class="o">:</span> <span class="nx">Condition</span><span class="p">&lt;</span><span class="nt">T</span><span class="p">&gt;);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kr">type</span> <span class="nx">Condition</span><span class="p">&lt;</span><span class="nt">T</span><span class="p">&gt;</span> <span class="o">=</span> <span class="nx">T</span> <span class="kr">extends</span> <span class="kt">object</span>
</span></span><span class="line"><span class="cl">   <span class="o">?</span> <span class="p">{</span> <span class="p">[</span><span class="nx">K</span> <span class="k">in</span> <span class="k">keyof</span> <span class="nx">T</span><span class="p">]</span><span class="o">?:</span> <span class="nx">BranchCondition</span><span class="p">&lt;</span><span class="nt">T</span><span class="err">[</span><span class="na">K</span><span class="err">]</span><span class="p">&gt;</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl">   <span class="o">:</span> <span class="nx">T</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kr">type</span> <span class="nx">MonadCondition</span><span class="p">&lt;</span><span class="nt">T</span><span class="p">&gt;</span> <span class="o">=</span> <span class="nx">T</span> <span class="kr">extends</span> <span class="nx">Option</span><span class="p">&lt;</span><span class="nt">infer</span> <span class="na">U</span><span class="p">&gt;</span>
</span></span><span class="line"><span class="cl">   <span class="o">?</span> <span class="nx">Some</span><span class="p">&lt;</span><span class="nt">MonadCondition</span><span class="err">&lt;</span><span class="na">U</span><span class="p">&gt;</span><span class="o">&gt;</span> <span class="o">|</span> <span class="nx">None</span>
</span></span><span class="line"><span class="cl">   : <span class="kt">T</span> <span class="kr">extends</span> <span class="nx">Result</span><span class="p">&lt;</span><span class="nt">infer</span> <span class="na">U</span><span class="err">,</span> <span class="na">infer</span> <span class="na">E</span><span class="p">&gt;</span>
</span></span><span class="line"><span class="cl">   <span class="o">?</span> <span class="nx">Ok</span><span class="p">&lt;</span><span class="nt">MonadCondition</span><span class="err">&lt;</span><span class="na">U</span><span class="p">&gt;</span><span class="o">&gt;</span> <span class="o">|</span> <span class="nx">Err</span><span class="p">&lt;</span><span class="nt">MonadCondition</span><span class="err">&lt;</span><span class="na">E</span><span class="p">&gt;</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl">   <span class="o">:</span> <span class="nx">Wide</span><span class="p">&lt;</span><span class="nt">T</span><span class="p">&gt;;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kr">type</span> <span class="nx">MonadMapped</span><span class="p">&lt;</span><span class="nt">T</span><span class="err">,</span> <span class="na">U</span><span class="p">&gt;</span> <span class="o">=</span>
</span></span><span class="line"><span class="cl">   <span class="o">|</span> <span class="nx">Mapped</span><span class="p">&lt;</span><span class="nt">T</span><span class="err">,</span> <span class="na">U</span><span class="p">&gt;</span>
</span></span><span class="line"><span class="cl">   <span class="o">|</span> <span class="nx">ChainedBranches</span><span class="p">&lt;</span><span class="nt">T</span><span class="err">,</span> <span class="na">U</span><span class="p">&gt;</span>
</span></span><span class="line"><span class="cl">   <span class="o">|</span> <span class="nx">MappedBranches</span><span class="p">&lt;</span><span class="nt">T</span><span class="err">,</span> <span class="na">U</span><span class="p">&gt;;</span>
</span></span><span class="line"><span class="cl"> 
</span></span><span class="line"><span class="cl"><span class="kr">type</span> <span class="nx">Mapped</span><span class="p">&lt;</span><span class="nt">T</span><span class="err">,</span> <span class="na">U</span><span class="p">&gt;</span> <span class="o">=</span> <span class="p">(</span><span class="nx">val</span>: <span class="kt">T</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="nx">U</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="kr">type</span> <span class="nx">Wide</span><span class="p">&lt;</span><span class="nt">T</span><span class="p">&gt;</span> <span class="o">=</span> <span class="nx">T</span> <span class="kr">extends</span> <span class="p">[...</span><span class="k">infer</span> <span class="nx">U</span><span class="p">]</span> <span class="o">?</span> <span class="nx">U</span><span class="p">[</span><span class="kt">number</span><span class="p">][]</span> <span class="o">:</span> <span class="nx">Partial</span><span class="p">&lt;</span><span class="nt">T</span><span class="p">&gt;;</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>我们知道一个分支分成条件和结果，看 BranchCondition 即分支条件，可以是以下的情况</p>
<ul>
<li>Mapped，表示被准确匹配的值，比如 Some(1) 这样的</li>
<li>根据是否有 [T] 成员来区分是否 Option/Result，注意这个 T 并不是类型，而是那个 Symbol 变量
<ul>
<li>有 [T] 的说明是 Option 或者 Result，进入 MonadCondition
<ul>
<li>分别通过匹配 Option 和 Result 来确定类型</li>
<li>都不是则进入 Wide
<ul>
<li>如果是数组就是对数组的匹配</li>
<li>如果不是数组就是对 T 部分字段的匹配</li>
</ul>
</li>
</ul>
</li>
<li>没有 [T] 进入普通的条件 Condition，通过变量是否对象来分类
<ul>
<li>是对象的话，那么类型需要进行筛选一下，只选出需要的字段及其类型，每个字段都是一个独立的分支条件（BranchCondition）</li>
<li>不是对象的话就直接匹配该值的类型即可
Monad（单子）是前面介绍过的一个概念，简单说代表一个占坑的变量，可以是几种状态的叠加</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>下面则是返回是否匹配条件的 matches 函数：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-ts" data-lang="ts"><span class="line"><span class="cl"><span class="kd">function</span> <span class="nx">matches</span><span class="p">&lt;</span><span class="nt">T</span><span class="p">&gt;(</span>
</span></span><span class="line"><span class="cl">   <span class="nx">cond</span>: <span class="kt">BranchCondition</span><span class="p">&lt;</span><span class="nt">T</span><span class="p">&gt;,</span>
</span></span><span class="line"><span class="cl">   <span class="nx">val</span>: <span class="kt">T</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">   <span class="nx">evaluate</span>: <span class="kt">boolean</span>
</span></span><span class="line"><span class="cl"><span class="p">)</span><span class="o">:</span> <span class="kr">boolean</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">   <span class="k">if</span> <span class="p">(</span><span class="nx">cond</span> <span class="o">===</span> <span class="nx">Default</span> <span class="o">||</span> <span class="nx">cond</span> <span class="o">===</span> <span class="nx">val</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="c1">// 如果直接匹配上了或者是默认分支则直接返回true
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>      <span class="k">return</span> <span class="kc">true</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">   <span class="p">}</span>
</span></span><span class="line"><span class="cl">   <span class="k">if</span> <span class="p">(</span><span class="k">typeof</span> <span class="nx">cond</span> <span class="o">===</span> <span class="s2">&#34;function&#34;</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="c1">// 如果是被包装后的函数就判断是不是该函数，
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>      <span class="c1">// 否则，只有在 evaluate 为 true （代表要判断其值）时执行条件函数
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>      <span class="k">return</span> <span class="p">(</span><span class="nx">cond</span> <span class="kr">as</span> <span class="nx">Fn</span><span class="p">&lt;</span><span class="nt">T</span><span class="p">&gt;)[</span><span class="nx">FnVal</span><span class="p">]</span>
</span></span><span class="line"><span class="cl">         <span class="o">?</span> <span class="p">(</span><span class="nx">cond</span> <span class="kr">as</span> <span class="nx">Fn</span><span class="p">&lt;</span><span class="nt">T</span><span class="p">&gt;)[</span><span class="nx">FnVal</span><span class="p">]</span> <span class="o">===</span> <span class="nx">val</span>
</span></span><span class="line"><span class="cl">         : <span class="kt">evaluate</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="nx">cond</span> <span class="kr">as</span> <span class="p">(</span><span class="nx">val</span>: <span class="kt">T</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="kr">boolean</span><span class="p">)(</span><span class="nx">val</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">   <span class="p">}</span>
</span></span><span class="line"><span class="cl">   <span class="c1">// 如果是对象
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>   <span class="k">if</span> <span class="p">(</span><span class="nx">isObjectLike</span><span class="p">(</span><span class="nx">cond</span><span class="p">))</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="k">if</span> <span class="p">(</span><span class="nx">T</span> <span class="k">in</span> <span class="nx">cond</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">         <span class="c1">// 如果 val 是条件的一部分，再深入判断（再次调用matches，字段级匹配）
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>         <span class="k">return</span> <span class="p">(</span>
</span></span><span class="line"><span class="cl">            <span class="p">(</span><span class="nx">cond</span> <span class="kr">as</span> <span class="kt">any</span><span class="p">).</span><span class="nx">isLike</span><span class="p">(</span><span class="nx">val</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
</span></span><span class="line"><span class="cl">            <span class="nx">matches</span><span class="p">((</span><span class="nx">cond</span> <span class="kr">as</span> <span class="kt">any</span><span class="p">)[</span><span class="nx">Val</span><span class="p">],</span> <span class="p">(</span><span class="nx">val</span> <span class="kr">as</span> <span class="kt">any</span><span class="p">)[</span><span class="nx">Val</span><span class="p">],</span> <span class="kc">false</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">         <span class="p">);</span>
</span></span><span class="line"><span class="cl">      <span class="p">}</span>
</span></span><span class="line"><span class="cl">      <span class="k">if</span> <span class="p">(</span><span class="nx">isObjectLike</span><span class="p">(</span><span class="nx">val</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="nb">Array</span><span class="p">.</span><span class="nx">isArray</span><span class="p">(</span><span class="nx">cond</span><span class="p">)</span> <span class="o">===</span> <span class="nb">Array</span><span class="p">.</span><span class="nx">isArray</span><span class="p">(</span><span class="nx">val</span><span class="p">))</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">         <span class="c1">// 对数组匹配，元素级匹配
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>         <span class="k">for</span> <span class="p">(</span><span class="kr">const</span> <span class="nx">key</span> <span class="k">of</span> <span class="nb">Object</span><span class="p">.</span><span class="nx">keys</span><span class="p">(</span><span class="nx">cond</span><span class="p">))</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="k">if</span> <span class="p">(</span>
</span></span><span class="line"><span class="cl">               <span class="o">!</span><span class="p">(</span><span class="nx">key</span> <span class="k">in</span> <span class="nx">val</span><span class="p">)</span> <span class="o">||</span>
</span></span><span class="line"><span class="cl">               <span class="o">!</span><span class="nx">matches</span><span class="p">((</span><span class="nx">cond</span> <span class="kr">as</span> <span class="kt">any</span><span class="p">)[</span><span class="nx">key</span><span class="p">],</span> <span class="p">(</span><span class="nx">val</span> <span class="kr">as</span> <span class="kt">any</span><span class="p">)[</span><span class="nx">key</span><span class="p">],</span> <span class="nx">evaluate</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">            <span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">               <span class="k">return</span> <span class="kc">false</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">            <span class="p">}</span>
</span></span><span class="line"><span class="cl">         <span class="p">}</span>
</span></span><span class="line"><span class="cl">         <span class="k">return</span> <span class="kc">true</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">      <span class="p">}</span>
</span></span><span class="line"><span class="cl">   <span class="p">}</span>
</span></span><span class="line"><span class="cl">   <span class="k">return</span> <span class="kc">false</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h4 id="小结">小结</h4>
<ul>
<li>通过把类型一层一层抽象，实现类型安全的匹配</li>
<li>Chained 的匹配提供了比 mapped 更灵活的使用方式</li>
</ul>
<h2 id="题外">题外</h2>
<h3 id="为什么只广泛在函数式编程流行">为什么只广泛在函数式编程流行</h3>
<p>参考 <a class="link" href="https://www.quora.com/Why-is-pattern-matching-prevalent-only-in-functional-programming-languages"  target="_blank" rel="noopener"
    >Why-is-pattern-matching-prevalent-only-in-functional-programming-languages</a></p>
<ul>
<li>模式匹配实际上和一个强大的类型系统有很强的关系，那就是代数数据类型（Algebraic Data Type），在前面简单提到过，比如 | 为传统的 union 类型提供了更强大的表达能力，&amp; 也比复杂的继承更好写。</li>
<li>因为 C 没有</li>
<li>在一些比较新的语言里（比如 TypeScript 和 Rust）强大的类型系统就为模式匹配提供了土壤。</li>
</ul>
<p>现在的 OO 语言也在一些比较微观的层面上引入了一些函数式编程的概念，来提高程序的表达能力，比如 Python3.10 就引入了 match，C# 也引入了match。</p>
<h3 id="ecmascript-里的进展">ECMAScript 里的进展</h3>
<p><a class="link" href="https://github.com/tc39/proposal-pattern-matching"  target="_blank" rel="noopener"
    >GitHub - tc39/proposal-pattern-matching: Pattern matching syntax for ECMAScript</a></p>
<p>还在 Proposal 阶段，提了好多年了似乎没什么进展，不过 star 还是很多的</p>
<p>提案中提供了类似以下的匹配方式：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="nx">match</span> <span class="p">(</span><span class="nx">res</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="nx">when</span> <span class="p">({</span> <span class="nx">status</span><span class="o">:</span> <span class="mi">200</span><span class="p">,</span> <span class="nx">body</span><span class="p">,</span> <span class="p">...</span><span class="nx">rest</span> <span class="p">})</span><span class="o">:</span> <span class="nx">handleData</span><span class="p">(</span><span class="nx">body</span><span class="p">,</span> <span class="nx">rest</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">  <span class="nx">when</span> <span class="p">({</span> <span class="nx">status</span><span class="p">,</span> <span class="nx">destination</span><span class="o">:</span> <span class="nx">url</span> <span class="p">})</span> <span class="k">if</span> <span class="p">(</span><span class="mi">300</span> <span class="o">&lt;=</span> <span class="nx">status</span> <span class="o">&amp;&amp;</span> <span class="nx">status</span> <span class="o">&lt;</span> <span class="mi">400</span><span class="p">)</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">    <span class="nx">handleRedirect</span><span class="p">(</span><span class="nx">url</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">  <span class="nx">when</span> <span class="p">({</span> <span class="nx">status</span><span class="o">:</span> <span class="mi">500</span> <span class="p">})</span> <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="k">this</span><span class="p">.</span><span class="nx">hasRetried</span><span class="p">)</span><span class="o">:</span> <span class="k">do</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nx">retry</span><span class="p">(</span><span class="nx">req</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">this</span><span class="p">.</span><span class="nx">hasRetried</span> <span class="o">=</span> <span class="kc">true</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="k">default</span><span class="o">:</span> <span class="nx">throwSomething</span><span class="p">();</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>实际上感觉不如前面实现的那种那种好看</p>
<h2 id="总结">总结</h2>
<ol>
<li>介绍了模式匹配的实现与好处：
<ol>
<li>符合思考方式</li>
<li>条件与赋值的兼得</li>
<li>语句到表达式的转变（表达能力的增强）</li>
</ol>
</li>
<li>Monad 式的类型安全错误处理</li>
<li>用 TS 实现 match：类型的一层层抽象</li>
<li>投入生产？原生的支持不够强大：编译器对分支覆盖的检查能力不足</li>
</ol>
<h2 id="参考">参考</h2>
<ul>
<li><a class="link" href="https://stackoverflow.com/questions/36920427/how-is-match-implemented-in-a-language-like-rust"  target="_blank" rel="noopener"
    >How is match implemented in a language like Rust?</a></li>
<li><a class="link" href="https://www.quora.com/Why-is-pattern-matching-prevalent-only-in-functional-programming-languages"  target="_blank" rel="noopener"
    >Why-is-pattern-matching-prevalent-only-in-functional-programming-languages</a></li>
<li><a class="link" href="https://en.wikipedia.org/wiki/Algebraic_data_type"  target="_blank" rel="noopener"
    >Algebraic-data-type-wiki</a></li>
<li><a class="link" href="https://www.typescriptlang.org/docs/handbook/2/functions.html#function-overloads"  target="_blank" rel="noopener"
    >functions overload</a></li>
</ul>

</section>


    <footer class="article-footer">
    
    <section class="article-tags">
        
            <a href="/tags/typescript/">TypeScript</a>
        
            <a href="/tags/rust/">Rust</a>
        
    </section>


    
    <section class="article-copyright">
        <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-copyright" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <circle cx="12" cy="12" r="9" />
  <path d="M14.5 9a3.5 4 0 1 0 0 6" />
</svg>



        <span>Licensed under CC BY-NC-SA 4.0</span>
    </section>
    </footer>


    
        <link 
                rel="stylesheet" 
                href="https://cdn.jsdelivr.net/npm/katex@0.15.6/dist/katex.min.css"integrity="sha256-J&#43;iAE0sgH8QSz9hpcDxXIftnj65JEZgNhGcgReTTK9s="crossorigin="anonymous"
            ><script 
                src="https://cdn.jsdelivr.net/npm/katex@0.15.6/dist/katex.min.js"integrity="sha256-InsNdER1b2xUewP&#43;pKCUJpkhiqwHgqiPXDlIk7GzBu4="crossorigin="anonymous"
                defer
                >
            </script><script 
                src="https://cdn.jsdelivr.net/npm/katex@0.15.6/dist/contrib/auto-render.min.js"integrity="sha256-y39Mpg7V3D4lhBX4x6O0bUqTV4pSrfgwEfGKfxkOdgI="crossorigin="anonymous"
                defer
                >
            </script><script>
    window.addEventListener("DOMContentLoaded", () => {
        renderMathInElement(document.querySelector(`.article-content`), {
            delimiters: [
                { left: "$$", right: "$$", display: true },
                { left: "$", right: "$", display: false },
                { left: "\\(", right: "\\)", display: false },
                { left: "\\[", right: "\\]", display: true }
            ]
        });})
</script>
    
</article>

    

    

     
    
        
    <script src="https://utteranc.es/client.js" 
        repo="werifu/werifu.github.io"
        issue-term="pathname"
        
        crossorigin="anonymous"
        async
        >
</script>

<style>
    .utterances {
        max-width: unset;
    }
</style>

<script>
    function setUtterancesTheme(theme) {
        let utterances = document.querySelector('.utterances iframe');
        if (utterances) {
            utterances.contentWindow.postMessage(
                {
                    type: 'set-theme',
                    theme: `github-${theme}`
                },
                'https://utteranc.es'
            );
        }
    }

    addEventListener('message', event => {
        if (event.origin !== 'https://utteranc.es') return;
        setUtterancesTheme(document.documentElement.dataset.scheme)
    });

    window.addEventListener('onColorSchemeChange', (e) => {
        setUtterancesTheme(e.detail)
    })
</script>


    

    <footer class="site-footer">
    <section class="copyright">
        &copy; 
        
            2020 - 
        
        2023 秘密
    </section>
    
    <section class="powerby">
        Built with <a href="https://gohugo.io/" target="_blank" rel="noopener">Hugo</a> <br />
        主题 <b><a href="https://github.com/CaiJimmy/hugo-theme-stack" target="_blank" rel="noopener" data-version="3.16.0">Stack</a></b> 由 <a href="https://jimmycai.com" target="_blank" rel="noopener">Jimmy</a> 设计
    </section>
</footer>


    
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    
    <div class="pswp__bg"></div>

    
    <div class="pswp__scroll-wrap">

        
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>

        
        <div class="pswp__ui pswp__ui--hidden">

            <div class="pswp__top-bar">

                

                <div class="pswp__counter"></div>

                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

                <button class="pswp__button pswp__button--share" title="Share"></button>

                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

                
                
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                        <div class="pswp__preloader__cut">
                            <div class="pswp__preloader__donut"></div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div>
            </div>

            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>

            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>

            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>

        </div>

    </div>

</div><script 
                src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.js"integrity="sha256-ePwmChbbvXbsO02lbM3HoHbSHTHFAeChekF1xKJdleo="crossorigin="anonymous"
                defer
                >
            </script><script 
                src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe-ui-default.min.js"integrity="sha256-UKkzOn/w1mBxRmLLGrSeyB4e1xbrp4xylgAWb3M42pU="crossorigin="anonymous"
                defer
                >
            </script><link 
                rel="stylesheet" 
                href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/default-skin/default-skin.min.css"crossorigin="anonymous"
            ><link 
                rel="stylesheet" 
                href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.css"crossorigin="anonymous"
            >

            </main>
        </div>
        <script 
                src="https://cdn.jsdelivr.net/npm/node-vibrant@3.1.6/dist/vibrant.min.js"integrity="sha256-awcR2jno4kI5X0zL8ex0vi2z&#43;KMkF24hUW8WePSA9HM="crossorigin="anonymous"
                
                >
            </script><script type="text/javascript" src="/ts/main.js" defer></script>
<script>
    (function () {
        const customFont = document.createElement('link');
        customFont.href = "https://fonts.googleapis.com/css2?family=Lato:wght@300;400;700&display=swap";

        customFont.type = "text/css";
        customFont.rel = "stylesheet";

        document.head.appendChild(customFont);
    }());
</script>

    </body>
</html>
